{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to QUAM","text":"<p>Empowering Quantum Innovation with Enhanced Abstraction</p> <p>Welcome to the official documentation for the Quantum Abstract Machine (QUAM), a software framework designed to enhance the user experience of quantum computing by providing an abstraction layer over the QUA programming language. QUAM allows users, particularly physicists, to interact with the Quantum Orchestration Platform more intuitively, shifting from a hardware-centric to a physicist-friendly approach.</p>"},{"location":"#what-is-quam","title":"What is QUAM?","text":"<p>QUAM stands out by transforming the way quantum control is perceived and implemented. While QUA and its configurations tackle quantum control from a generic hardware perspective, QUAM introduces a higher level of abstraction. It allows you to think in terms of qubits and quantum operations rather than just channels and waveforms, aligning more closely with the thought processes of physicists.</p>"},{"location":"#why-choose-quam","title":"Why Choose QUAM?","text":"<p>QUAM is not just a tool but a gateway to streamlined and efficient quantum computing:</p> <ul> <li>Component-Based Setup: Utilize a standard set of QUAM components like Mixers and IQChannels to digitally represent and manipulate your quantum environment.</li> <li>Gate-Level Operations: Work with high-level quantum components like qubits and qubit pairs, and use macro operations for common quantum gate sequences, bringing your code closer to quantum circuit thinking.</li> <li>Automated Configuration: Automatically generate the necessary QUA configuration from your QUAM setup, simplifying the transition from design to deployment.</li> <li>Extensibility: Easily extend QUAM with custom classes to accommodate complex quantum setups, providing flexibility and power in your quantum computing applications.</li> <li>State Management: Effortlessly save and load your QUAM state, enabling consistent results and reproducibility in experiments.</li> </ul> <pre><code>from quam.components import BasicQUAM, SingleChannel, pulses\nfrom qm import qua\n\n# Create a root-level QUAM instance\nmachine = BasicQuam()\n\n# Add a qubit connected to an OPX output channel\nqubit = SingleChannel(opx_output=(\"con1\", 1))\nmachine.channels[\"qubit\"] = qubit\n\n# Add a Gaussian pulse to the channel\nqubit.operations[\"gaussian\"] = pulses.GaussianPulse(\n    length=100,  # Pulse length in ns\n    amplitude=0.5,  # Peak amplitude of Gaussian pulse\n    sigma=20,  # Standard deviation of Guassian pulse\n)\n\n# Play the Gaussian pulse on the channel within a QUA program\nwith qua.program() as prog:\n    qubit.play(\"gaussian\")\n\n# Generate the QUA configuration from QUAM\nqua_configuration = machine.generate_config()\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>QUAM Installation: Set up QUAM on your system and get ready to explore its capabilities.</li> <li>QUAM Demonstration: Witness QUAM in action with practical examples and hands-on tutorials.</li> <li>QUAM Components: Explore the core components that form the building blocks of the QUAM architecture.</li> <li>QUAM Features: Discover the unique features and capabilities that QUAM offers for your quantum projects.</li> <li>QUAM Migration: Already using QUA? Our detailed guide on migrating to QUAM are designed for a smooth transition to QUAM, letting you migrate your existing QUA projects without hassle.</li> <li>API References: Dive into the detailed API documentation to explore the classes, methods, and attributes available in QUAM.</li> </ul> <p>We are thrilled to support your journey into the quantum future with QUAM. Together, let's push the boundaries of what's possible in quantum computing!</p>"},{"location":"demonstration/","title":"QUAM Demonstration","text":""},{"location":"demonstration/#introduction","title":"Introduction","text":"<p>Welcome to our QUAM tutorial! This guide will demonstrate setting up a basic superconducting quantum circuit with two transmon qubits and their resonators. We'll equip these qubits with control and readout pulses and generate a QUA configuration for interacting with quantum hardware.</p> <p>QUAM is not limited to any specific quantum hardware platform. It is designed to be adaptable and extensible for various quantum systems. You can customize components or expand the framework to add new functionalities as needed. For details on customization, visit Custom QUAM Components.</p> <p>We will first demonstrate how to create a basic QUAM setup from scratch. This is typically done once at the beginning of a project. Then, we'll show how to modify the setup, save the changes, and generate a QUA configuration for running quantum programs.</p> <p>By the end of this tutorial, you'll know how to use QUAM effectively for setting up, controlling, and measuring quantum systems.</p>"},{"location":"demonstration/#setting-up","title":"Setting Up","text":"<p>Start by importing the necessary components for a superconducting quantum circuit from QUAM's library:</p> <pre><code>from quam.components import *\nfrom quam.examples.superconducting_qubits import Transmon, Quam\n</code></pre> <p>As can be seen, we use transmon-specific components from <code>quam.examples.superconducting_qubits</code> to set up the quantum circuit. Users are recommended to create their own custom components for specialized needs.</p>"},{"location":"demonstration/#initialization","title":"Initialization","text":"<p>QUAM requires an initial setup where all components are instantiated. Create the root QUAM object, which acts as the top-level container for your quantum setup (see QUAM Root Documentation for details):</p> <pre><code>machine = Quam() # (1)\n</code></pre> <ol> <li>The <code>Quam</code> instance is called <code>machine</code> instead of <code>quam</code> to avoid conflicts with the statement <code>import quam</code></li> </ol> <p>Initially, <code>machine</code> is an empty container. You'll populate it with quantum circuit components, specifically Transmon qubits and associated resonators.</p>"},{"location":"demonstration/#populating-the-machine","title":"Populating the Machine","text":"<p>Define the number of qubits and initialize them, along with their channels and resonators:</p> <pre><code>num_qubits = 2\nfor idx in range(num_qubits):\n    # Create transmon qubit component\n    transmon = Transmon(id=idx)\n    machine.qubits[transmon.name] = transmon\n\n    # Add xy drive line channel\n    transmon.xy = IQChannel(\n        opx_output_I=(\"con1\", 3 * idx + 3),\n        opx_output_Q=(\"con1\", 3 * idx + 4),\n        frequency_converter_up=FrequencyConverter(\n            mixer=Mixer(),\n            local_oscillator=LocalOscillator(power=10, frequency=6e9),\n        ),\n        intermediate_frequency=100e6,\n    )\n\n    # Add transmon flux line channel\n    transmon.z = SingleChannel(opx_output=(\"con1\", 3 * idx + 5))\n\n    # Add resonator channel\n    transmon.resonator = InOutIQChannel(\n        id=idx,\n        opx_output_I=(\"con1\", 1),\n        opx_output_Q=(\"con1\", 2),\n        opx_input_I=(\"con1\", 1),\n        opx_input_Q=(\"con1\", 2,),\n        frequency_converter_up=FrequencyConverter(\n            mixer=Mixer(), local_oscillator=LocalOscillator(power=10, frequency=6e9)\n        ),\n    )\n</code></pre> Autocomplete with IDEs <p>type: tip Code editors with Python language support (e.g., VS Code, PyCharm) are very useful here because they explain what attributes each class has, what the type should be, and docstrings. This makes it a breeze to create a QUAM from scratch.</p> <p>This setup reflects QUAM's flexibility and the hierarchical structure of its component system where each component can be a parent or a child.</p>"},{"location":"demonstration/#adding-a-pulse-to-a-qubit-and-its-resonator","title":"Adding a Pulse to a Qubit and its Resonator","text":"<p>After configuring the qubits and resonators, you can further customize your setup by adding operational pulses. This example will show how to add a Gaussian pulse to the <code>xy</code> channel of a qubit and a <code>ReadoutPulse</code> to its resonator.</p>"},{"location":"demonstration/#defining-and-attaching-the-pulses","title":"Defining and Attaching the Pulses","text":""},{"location":"demonstration/#gaussian-pulse-for-qubit-control","title":"Gaussian Pulse for Qubit Control","text":"<p>Define a basic Gaussian pulse for qubit manipulation and attach it to the <code>xy</code> channel of the first qubit:</p> <pre><code>from quam.components.pulses import GaussianPulse\n\n# Create a Gaussian pulse\ngaussian_pulse = GaussianPulse(length=20, amplitude=0.2, sigma=3)\n\n# Attach the pulse to the XY channel of the first qubit\nmachine.qubits[\"q0\"].xy.operations[\"X90\"] = gaussian_pulse\n</code></pre>"},{"location":"demonstration/#readout-pulse-for-qubit-resonator","title":"Readout Pulse for Qubit Resonator","text":"<p>Similarly, define a <code>SquareReadoutPulse</code> (constant in readout amplitude) for the resonator associated with the same qubit to enable quantum state measurement:</p> <pre><code>from quam.components.pulses import SquareReadoutPulse\n\n# Create a Readout pulse\nreadout_pulse = SquareReadoutPulse(length=1000, amplitude=0.1)\n\n# Attach the pulse to the resonator of the first qubit\nmachine.qubits[\"q0\"].resonator.operations[\"readout\"] = readout_pulse\n</code></pre>"},{"location":"demonstration/#invoking-the-pulses-in-a-function","title":"Invoking the Pulses in a Function","text":"<pre><code>from qm.qua import program\n\nwith program() as prog:\n    qubit = machine.qubits[\"q0\"]\n\n    # Apply the Gaussian pulse to the qubit\n    qubit.xy.play(\"X90\")\n\n    # Perform readout on the qubit\n    I, Q = qubit.resonator.measure(\"readout\")\n</code></pre>"},{"location":"demonstration/#overview-of-configuration","title":"Overview of Configuration","text":"<p>Display the current configuration of your QUAM setup:</p> <pre><code>machine.print_summary()\n</code></pre> <code>machine.print_summary()</code> output <pre><code>QUAM:\n  qubits: QuamDict\n    q0: Transmon\n      id: 0\n      xy: IQChannel\n        operations: QuamDict\n          X90: GaussianPulse\n            length: 20\n            id: None\n            digital_marker: None\n            amplitude: 0.2\n            sigma: 3\n            axis_angle: None\n            subtracted: True\n        id: None\n        digital_outputs: QuamDict Empty\n        opx_output_I: ('con1', 3)\n        opx_output_Q: ('con1', 4)\n        opx_output_offset_I: None\n        opx_output_offset_Q: None\n        frequency_converter_up: FrequencyConverter\n          local_oscillator: LocalOscillator\n            frequency: 6000000000.0\n            power: 10\n          mixer: Mixer\n            local_oscillator_frequency: \"#../local_oscillator/frequency\"\n            intermediate_frequency: \"#../../intermediate_frequency\"\n            correction_gain: 0\n            correction_phase: 0\n          gain: None\n        intermediate_frequency: 100000000.0\n      z: SingleChannel\n        operations: QuamDict Empty\n        id: None\n        digital_outputs: QuamDict Empty\n        opx_output: ('con1', 5)\n        filter_fir_taps: None\n        filter_iir_taps: None\n        opx_output_offset: None\n        intermediate_frequency: None\n      resonator: InOutIQChannel\n        operations: QuamDict\n          readout: SquareReadoutPulse\n            length: 1000\n            id: None\n            digital_marker: \"ON\"\n            amplitude: 0.1\n            axis_angle: None\n            threshold: None\n            rus_exit_threshold: None\n            integration_weights: None\n            integration_weights_angle: 0\n        id: 0\n        digital_outputs: QuamDict Empty\n        opx_output_I: ('con1', 1)\n        opx_output_Q: ('con1', 2)\n        opx_output_offset_I: None\n        opx_output_offset_Q: None\n        frequency_converter_up: FrequencyConverter\n          local_oscillator: LocalOscillator\n            frequency: 6000000000.0\n            power: 10\n          mixer: Mixer\n            local_oscillator_frequency: \"#../local_oscillator/frequency\"\n            intermediate_frequency: \"#../../intermediate_frequency\"\n            correction_gain: 0\n            correction_phase: 0\n          gain: None\n        intermediate_frequency: 0.0\n        opx_input_I: ('con1', 1)\n        opx_input_Q: ('con1', 2)\n        time_of_flight: 140\n        smearing: 0\n        opx_input_offset_I: None\n        opx_input_offset_Q: None\n        input_gain: None\n        frequency_converter_down: None\n    q1: Transmon\n      id: 1\n      xy: IQChannel\n        operations: QuamDict Empty\n        id: None\n        digital_outputs: QuamDict Empty\n        opx_output_I: ('con1', 6)\n        opx_output_Q: ('con1', 7)\n        opx_output_offset_I: None\n        opx_output_offset_Q: None\n        frequency_converter_up: FrequencyConverter\n          local_oscillator: LocalOscillator\n            frequency: 6000000000.0\n            power: 10\n          mixer: Mixer\n            local_oscillator_frequency: \"#../local_oscillator/frequency\"\n            intermediate_frequency: \"#../../intermediate_frequency\"\n            correction_gain: 0\n            correction_phase: 0\n          gain: None\n        intermediate_frequency: 100000000.0\n      z: SingleChannel\n        operations: QuamDict Empty\n        id: None\n        digital_outputs: QuamDict Empty\n        opx_output: ('con1', 8)\n        filter_fir_taps: None\n        filter_iir_taps: None\n        opx_output_offset: None\n        intermediate_frequency: None\n      resonator: InOutIQChannel\n        operations: QuamDict Empty\n        id: 1\n        digital_outputs: QuamDict Empty\n        opx_output_I: ('con1', 4)\n        opx_output_Q: ('con1', 5)\n        opx_output_offset_I: None\n        opx_output_offset_Q: None\n        frequency_converter_up: FrequencyConverter\n          local_oscillator: LocalOscillator\n            frequency: 6000000000.0\n            power: 10\n          mixer: Mixer\n            local_oscillator_frequency: \"#../local_oscillator/frequency\"\n            intermediate_frequency: \"#../../intermediate_frequency\"\n            correction_gain: 0\n            correction_phase: 0\n          gain: None\n        intermediate_frequency: 0.0\n        opx_input_I: ('con1', 1)\n        opx_input_Q: ('con1', 2)\n        time_of_flight: 140\n        smearing: 0\n        opx_input_offset_I: None\n        opx_input_offset_Q: None\n        input_gain: None\n        frequency_converter_down: None\n  wiring: QuamDict Empty\n</code></pre> <p>The output provides a detailed hierarchical view of the machine's configuration, illustrating the connectivity and settings of each component.</p>"},{"location":"demonstration/#saving-the-quam-setup","title":"Saving the QUAM Setup","text":"<p>Save the current state of your QUAM setup to a file for later use or inspection:</p> <pre><code>machine.save(\"state.json\")\n</code></pre> state.json <pre><code>{\n  \"__class__\": \"quam.examples.superconducting_qubits.components.Quam\",\n  \"qubits\": {\n    \"q0\": {\n      \"id\": 0,\n      \"resonator\": {\n        \"frequency_converter_up\": {\n          \"__class__\": \"quam.components.hardware.FrequencyConverter\",\n          \"local_oscillator\": { \"frequency\": 6000000000.0, \"power\": 10 },\n          \"mixer\": {}\n        },\n        \"id\": 0,\n        \"operations\": {\n          \"readout\": {\n            \"__class__\": \"quam.components.pulses.SquareReadoutPulse\",\n            \"amplitude\": 0.1,\n            \"length\": 1000\n          }\n        },\n        \"opx_input_I\": [\"con1\", 1],\n        \"opx_input_Q\": [\"con1\", 2],\n        \"opx_output_I\": [\"con1\", 1],\n        \"opx_output_Q\": [\"con1\", 2]\n      },\n      \"xy\": {\n        \"frequency_converter_up\": {\n          \"__class__\": \"quam.components.hardware.FrequencyConverter\",\n          \"local_oscillator\": { \"frequency\": 6000000000.0, \"power\": 10 },\n          \"mixer\": {}\n        },\n        \"intermediate_frequency\": 100000000.0,\n        \"operations\": {\n          \"X90\": {\n            \"__class__\": \"quam.components.pulses.GaussianPulse\",\n            \"amplitude\": 0.2,\n            \"length\": 20,\n            \"sigma\": 3\n          }\n        },\n        \"opx_output_I\": [\"con1\", 3],\n        \"opx_output_Q\": [\"con1\", 4]\n      },\n      \"z\": { \"opx_output\": [\"con1\", 5] }\n    },\n    \"q1\": {\n      \"id\": 1,\n      \"resonator\": {\n        \"frequency_converter_up\": {\n          \"__class__\": \"quam.components.hardware.FrequencyConverter\",\n          \"local_oscillator\": { \"frequency\": 6000000000.0, \"power\": 10 },\n          \"mixer\": {}\n        },\n        \"id\": 1,\n        \"opx_input_I\": [\"con1\", 1],\n        \"opx_input_Q\": [\"con1\", 2],\n        \"opx_output_I\": [\"con1\", 4],\n        \"opx_output_Q\": [\"con1\", 5]\n      },\n      \"xy\": {\n        \"frequency_converter_up\": {\n          \"__class__\": \"quam.components.hardware.FrequencyConverter\",\n          \"local_oscillator\": { \"frequency\": 6000000000.0, \"power\": 10 },\n          \"mixer\": {}\n        },\n        \"intermediate_frequency\": 100000000.0,\n        \"opx_output_I\": [\"con1\", 6],\n        \"opx_output_Q\": [\"con1\", 7]\n      },\n      \"z\": { \"opx_output\": [\"con1\", 8] }\n    }\n  }\n}\n</code></pre> <p>The contents of <code>state.json</code> will mirror the structure and settings of your QUAM machine.</p>"},{"location":"demonstration/#loading-the-configuration","title":"Loading the Configuration","text":"<p>To resume work with a previously configured setup:</p> <pre><code>loaded_machine = Quam.load(\"state.json\")\n</code></pre>"},{"location":"demonstration/#workflow","title":"Workflow","text":"<p>Follow these steps for a typical execution flow in QUAM:</p> <ol> <li>Initialize a New QUAM Setup: Start by generating a new QUAM configuration for your quantum system as demonstrated earlier, and save this initial setup to a file. This step sets the baseline for your system's configuration.</li> <li>Modify and Save: Load the QUAM setup from the configuration file whenever you need to run new calibrations. After running your experiments and analyzing the results, you might need to adjust the configuration, such as updating pulse amplitudes based on your findings.</li> </ol> <p>Example of Updating Pulse Amplitude: Suppose a calibration determines a new optimal pulse amplitude. You would update the pulse amplitude in your QUAM setup and save the changes back to the configuration file.</p> <pre><code># Load QUAM\nmachine = Quam.load(\"state.json\")\n\n# Run QUA program and analyse results to extract the optimal pulse amplitude\nresults = some_qua_program()\npulse_amplitude = amplitude_analysis_function(results)\n\n# Update the pulse amplitude for the relevant qubit\nmachine.qubits[\"q0\"].xy.operations[\"X90\"].amplitude = pulse_amplitude\n\n# Save the updated QUAM configuration\nmachine.save(\"state.json\")\n</code></pre> <p>This workflow ensures your QUAM setup remains current with the latest experimental adjustments, allowing for iterative enhancements and refinements based on empirical data.</p>"},{"location":"demonstration/#generating-a-qua-configuration","title":"Generating a QUA Configuration","text":"<p>Generate a QUA configuration from the current QUAM setup. This is essential for interfacing with quantum hardware:</p> <pre><code>qua_config = machine.generate_config()\n</code></pre> qua_config <pre><code>{\n    \"controllers\": {\n        \"con1\": {\n            \"analog_inputs\": {1: {\"offset\": 0.0}, 2: {\"offset\": 0.0}},\n            \"analog_outputs\": {\n                1: {\"offset\": 0.0},\n                2: {\"offset\": 0.0},\n                3: {\"offset\": 0.0},\n                4: {\"offset\": 0.0},\n                5: {\"offset\": 0.0},\n                6: {\"offset\": 0.0},\n                7: {\"offset\": 0.0},\n                8: {\"offset\": 0.0},\n            },\n            \"digital_outputs\": {},\n        }\n    },\n    \"digital_waveforms\": {\"ON\": {\"samples\": [[1, 0]]}},\n    \"elements\": {\n        \"IQ0\": {\n            \"intermediate_frequency\": 0.0,\n            \"mixInputs\": {\n                \"I\": (\"con1\", 1),\n                \"Q\": (\"con1\", 2),\n                \"lo_frequency\": 6000000000.0,\n                \"mixer\": \"IQ0.mixer\",\n            },\n            \"operations\": {\"readout\": \"IQ0.readout.pulse\"},\n            \"outputs\": {\"out1\": (\"con1\", 1), \"out2\": (\"con1\", 2)},\n            \"smearing\": 0,\n            \"time_of_flight\": 140,\n        },\n        \"IQ1\": {\n            \"intermediate_frequency\": 0.0,\n            \"mixInputs\": {\n                \"I\": (\"con1\", 4),\n                \"Q\": (\"con1\", 5),\n                \"lo_frequency\": 6000000000.0,\n                \"mixer\": \"IQ1.mixer\",\n            },\n            \"operations\": {},\n            \"outputs\": {\"out1\": (\"con1\", 1), \"out2\": (\"con1\", 2)},\n            \"smearing\": 0,\n            \"time_of_flight\": 140,\n        },\n        \"q0.xy\": {\n            \"intermediate_frequency\": 100000000.0,\n            \"mixInputs\": {\n                \"I\": (\"con1\", 3),\n                \"Q\": (\"con1\", 4),\n                \"lo_frequency\": 6000000000.0,\n                \"mixer\": \"q0.xy.mixer\",\n            },\n            \"operations\": {\"X90\": \"q0.xy.X90.pulse\"},\n        },\n        \"q0.z\": {\"operations\": {}, \"singleInput\": {\"port\": (\"con1\", 5)}},\n        \"q1.xy\": {\n            \"intermediate_frequency\": 100000000.0,\n            \"mixInputs\": {\n                \"I\": (\"con1\", 6),\n                \"Q\": (\"con1\", 7),\n                \"lo_frequency\": 6000000000.0,\n                \"mixer\": \"q1.xy.mixer\",\n            },\n            \"operations\": {},\n        },\n        \"q1.z\": {\"operations\": {}, \"singleInput\": {\"port\": (\"con1\", 8)}},\n    },\n    \"integration_weights\": {\n        \"IQ0.readout.iw1\": {\"cosine\": [(1.0, 1000)], \"sine\": [(-0.0, 1000)]},\n        \"IQ0.readout.iw2\": {\"cosine\": [(0.0, 1000)], \"sine\": [(1.0, 1000)]},\n        \"IQ0.readout.iw3\": {\"cosine\": [(-0.0, 1000)], \"sine\": [(-1.0, 1000)]},\n    },\n    \"mixers\": {\n        \"IQ0.mixer\": [\n            {\n                \"correction\": [1.0, 0.0, 0.0, 1.0],\n                \"intermediate_frequency\": 0.0,\n                \"lo_frequency\": 6000000000.0,\n            }\n        ],\n        \"IQ1.mixer\": [\n            {\n                \"correction\": [1.0, 0.0, 0.0, 1.0],\n                \"intermediate_frequency\": 0.0,\n                \"lo_frequency\": 6000000000.0,\n            }\n        ],\n        \"q0.xy.mixer\": [\n            {\n                \"correction\": [1.0, 0.0, 0.0, 1.0],\n                \"intermediate_frequency\": 100000000.0,\n                \"lo_frequency\": 6000000000.0,\n            }\n        ],\n        \"q1.xy.mixer\": [\n            {\n                \"correction\": [1.0, 0.0, 0.0, 1.0],\n                \"intermediate_frequency\": 100000000.0,\n                \"lo_frequency\": 6000000000.0,\n            }\n        ],\n    },\n    \"oscillators\": {},\n    \"pulses\": {\n        \"IQ0.readout.pulse\": {\n            \"digital_marker\": \"ON\",\n            \"integration_weights\": {\n                \"iw1\": \"IQ0.readout.iw1\",\n                \"iw2\": \"IQ0.readout.iw2\",\n                \"iw3\": \"IQ0.readout.iw3\",\n            },\n            \"length\": 1000,\n            \"operation\": \"measurement\",\n            \"waveforms\": {\"I\": \"IQ0.readout.wf.I\", \"Q\": \"IQ0.readout.wf.Q\"},\n        },\n        \"const_pulse\": {\n            \"length\": 1000,\n            \"operation\": \"control\",\n            \"waveforms\": {\"I\": \"const_wf\", \"Q\": \"zero_wf\"},\n        },\n        \"q0.xy.X90.pulse\": {\n            \"length\": 20,\n            \"operation\": \"control\",\n            \"waveforms\": {\"I\": \"q0.xy.X90.wf.I\", \"Q\": \"q0.xy.X90.wf.Q\"},\n        },\n    },\n    \"version\": 1,\n    \"waveforms\": {\n        \"IQ0.readout.wf.I\": {\"sample\": 0.1, \"type\": \"constant\"},\n        \"IQ0.readout.wf.Q\": {\"sample\": 0.0, \"type\": \"constant\"},\n        \"const_wf\": {\"sample\": 0.1, \"type\": \"constant\"},\n        \"q0.xy.X90.wf.I\": {\n            \"samples\": array(\n                [\n                    0.0,\n                    0.0022836,\n                    0.00745838,\n                    0.01779789,\n                    0.03592509,\n                    0.06360149,\n                    0.09993812,\n                    0.14000065,\n                    0.17517038,\n                    0.19591242,\n                    0.19591242,\n                    0.17517038,\n                    0.14000065,\n                    0.09993812,\n                    0.06360149,\n                    0.03592509,\n                    0.01779789,\n                    0.00745838,\n                    0.0022836,\n                    0.0,\n                ]\n            ),\n            \"type\": \"arbitrary\",\n        },\n        \"q0.xy.X90.wf.Q\": {\n            \"samples\": array(\n                [\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                    0.0,\n                ]\n            ),\n            \"type\": \"arbitrary\",\n        },\n        \"zero_wf\": {\"sample\": 0.0, \"type\": \"constant\"},\n    },\n}\n</code></pre> <p>The resulting configuration is ready for use with QUA scripts to control quantum experiments.</p> <pre><code>qm = qmm.open_qm(qua_config)  # Open a quantum machine with the configuration\n</code></pre>"},{"location":"installation/","title":"QUAM Installation","text":""},{"location":"installation/#pre-requisites","title":"Pre-requisites","text":"For WindowsFor MacOSFor Linux <ul> <li>Windows 10 (build 1809 and later), or Windows 11</li> <li>3.9 \u2264 Python \u2264 3.12, we recommend Python 3.10 or 3.11     </li> <li>Git version control system, or a Git GUI such as GitHub Desktop or GitKraken</li> </ul> Using a virtual environment <p>type: tip</p> <p>It is recommended to install QUAM in a Python virtual environment.</p> <p>If using Anaconda, this can be done via</p> <pre><code>conda create -n {environment_name}\nconda activate {environment_name}\n</code></pre> <p>Be sure to replace <code>{environment_name}</code> with a name of your choosing</p> <p>To create a virtual environment without Anaconda, open PowerShell , navigate to a folder where you would like to create a virtual environment, and execute the following command:</p> <pre><code>python -m venv {environment_name}\nsource {environment_name}\\Scripts\\Activate.ps1\n</code></pre> <ul> <li>Tested on MacOS Ventura and MacOS Sonoma</li> <li>Python 3.9 or higher, we recommend Python 3.10 or higher</li> <li>Git version control system, or a Git GUI such as GitHub Desktop or GitKraken</li> </ul> Using a virtual environment <p>type: tip</p> <p>It is recommended to install QUAM in a Python virtual environment. To create a virtual environment, open terminal , navigate to a folder where you would like to create a virtual environment, and execute the following command:</p> <pre><code>python -m venv {environment_name}\nsource {environment_name}/bin/activate\n</code></pre> <ul> <li>QUAM has not been tested on Linux. However, it should follow similar instructions as MacOS.</li> </ul>"},{"location":"installation/#installation","title":"Installation","text":"<p>QUAM can be installed directly using <code>pip</code> or by cloning the repository from GitHub.</p>"},{"location":"installation/#pip-installation-recommended","title":"Pip installation (recommended)","text":"<p>The easiest way to install QUAM is directly using <code>pip</code>:</p> <pre><code>pip install quam\n</code></pre>"},{"location":"installation/#developer-installation-from-git","title":"Developer installation from Git","text":"<p>Alternatively, The QUAM repository can be downloaded using Git. Open Powershell / terminal  in a desired installation folder and run the following command:</p> <pre><code>git clone https://github.com/qua-platform/quam.git\npip3 install ./quam\n</code></pre> Installation from a Git GUI <p>type: note</p> <p>If you're not using Git directly but a Git client, please clone the repository from https://github.com/qua-platform/quam.git. Then open Powershell / terminal , navigate to the downloaded folder <code>quam</code> and run</p> <pre><code>pip3 install .\n</code></pre> Error message \"command not found: pip3\" <p>type: warning</p> <p>In case the error message <code>command not found: pip3</code> is displayed, try using the alternative command</p> <pre><code>pip install ./quam\n</code></pre> <p>If this raises a similar error, it likely means that Python cannot be found. Please check that you have Python installed. If you've set up a virtual environment, please ensure that it has been activated (see <code>Pre-requisites</code>).</p>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>QUAM comes with a range of standard QUAM components that can kick-start experimental setups. An example of these components are used can be found at the QUAM demonstration.</p> <p>Beyond the standard components, QUAM provides a framework to create custom components that are tailored to a specific quantum setup. This allows you to create their own abstraction layers, enabling you to digitally represent and interact with your quantum setup. See Creating custom QUAM components for details</p>"},{"location":"migrating-to-quam/","title":"Migrating to QUAM","text":"<p>QUAM, the Quantum Abstract Machine, serves as a powerful abstraction framework built over the QUA programming language. This guide aims to facilitate a smooth transition for developers from QUA to QUAM by detailing the necessary steps and modifications.</p>"},{"location":"migrating-to-quam/#overview-of-migration-process","title":"Overview of Migration Process","text":"<p>Migrating from QUA to QUAM involves a structured, five-step process that methodically transitions your existing quantum programming framework. Here's a brief overview of each step:</p> <ol> <li> <p>Create a Root QUAM Object: Start by establishing a foundational QuamRoot object that serves as the top-level container for all other QUAM components. This is where you'll begin building your new QUAM configuration.</p> </li> <li> <p>Add Octaves: If your original QUA setup includes Octave components, this step involves integrating these components into the QUAM configuration, utilizing existing connectivity settings.</p> </li> <li> <p>Convert \"elements\" to Channels: Each element in the QUA configuration that handles signal processing is mapped to a corresponding channel type in QUAM. This critical step ensures that the functional properties of your setup are preserved and adapted to the new architecture.</p> </li> <li> <p>Convert Pulses: After setting up the channels, the next step is to configure the pulses. This involves translating QUA pulse specifications into QUAM's consolidated and parameterized pulse framework.</p> </li> <li> <p>Generate the QUA configuration: Once the QUAM structure has been created and populated, you can generate the QUA configuration using the QUAM object. This configuration can then be used to run quantum programs on the OPX.</p> </li> <li> <p>Create High-Level QUAM Components (Optional): This final step is about abstracting complex configurations into high-level components like qubits, which can simplify the management and scalability of your quantum programs.</p> </li> </ol> <p>Each of these steps is designed to ensure a seamless transition to QUAM, leveraging its robust abstraction capabilities to manage and organize your quantum computing elements more effectively.</p>"},{"location":"migrating-to-quam/#1-create-a-root-quam-object","title":"1: Create a Root QUAM Object","text":"<p>Begin by establishing a QuamRoot object, which serves as the top-level container for all other QUAM components. For simplicity, you can use the pre-defined BasicQuam class:</p> <pre><code>from quam.components import BasicQuam\n\nmachine = BasicQuam()\nmachine.print_summary()  # outputs the current QUAM state\n</code></pre> output<pre><code>QUAM:\n  channels: QuamDict Empty\n  octaves: QuamDict Empty\n</code></pre> <p>Next we populate the root-level <code>machine</code> object with QUAM components</p>"},{"location":"migrating-to-quam/#2-add-octaves","title":"2: Add Octaves","text":"<p>If you have one or more Octave components, you can add them to the QUA configuration:</p> <pre><code>from quam.components import Octave\n\nmachine.octaves[\"octave1\"] = Octave(name=\"octave1\", ip=\"127.0.0.1\", port=80)\n\n# Initialize all frequency converters using the default connectivity to the OPX\nmachine.octave.initialize_frequency_converters()\n</code></pre> <p>Refer to the Octave documentation for further configuration details</p>"},{"location":"migrating-to-quam/#3-convert-elements-to-channels","title":"3: Convert \"elements\" to Channels","text":"<p>The QUA configuration has a section labelled <code>\"elements\"</code>, which corresponds to a pulse processor that can send and/or receive signals. Each element has a direct mapping to one of the quam.components.channels in QUAM, though the channel type depends on the element.</p> <p>Here we show how to convert different types of elements to QUAM channels. We don't cover all possible properties; details for this can be found in the Channels documentation and the relevant API documentation for each channel type. We also postpone the discussion on the <code>\"operations\"</code> field for the next section on pulses.</p>"},{"location":"migrating-to-quam/#single-analog-output-channel","title":"Single Analog Output Channel","text":"<p>For straightforward configurations with only a single output port, use the SingleChannel in QUAM. This example demonstrates the conversion of a single output setup in QUA to a SingleChannel in QUAM:</p> qua_configuration[\"elements\"]<pre><code>\"qubit_z\": {\n    \"singleInput\": {\"port\": (\"con1\", 1)},\n    \"operations\": {...}\n}\n</code></pre> QUAM<pre><code>from quam.components import SingleChannel\n\nmachine.channels[\"qubit_z\"] = SingleChannel(\n    opx_output=(\"con1\", 1),\n)\n</code></pre>"},{"location":"migrating-to-quam/#iq-analog-output-channel","title":"IQ Analog Output Channel","text":"<p>When dealing with IQ modulation, the IQChannel provides the necessary framework. Below are examples of converting an element with IQ outputs and a frequency upconverter:</p> qua_configuration[\"elements\"]<pre><code>\"qubit_xy\": {\n    \"intermediate_frequency\": 100e6,\n    \"mixInputs\": {\n        \"I\": (\"con1\", 1),\n        \"Q\": (\"con1\", 2),\n        \"lo_frequency\": 5e9,\n        \"mixer\": \"mixer_qubit\",\n    },\n    \"operations\": {...}\n},\n</code></pre> QUAM<pre><code>from quam.components import IQChannel, FrequencyConverter, LocalOscillator, Mixer\n\nchannels[\"qubit_XY\"] = IQChannel(\n    opx_output_I=(\"con1\", 1),\n    opx_output_Q=(\"con1\", 2),\n    frequency_converter_up=FrequencyConverter(\n        local_oscillator=LocalOscillator(frequency=5e9),\n        mixer=Mixer()\n    )\n)\n</code></pre> <p>If an Octave is used for upconversion, the IQChannel should be connected to the OctaveUpConverter.</p> qua_configuration[\"elements\"]<pre><code>\"qubit_xy\": {\n    \"intermediate_frequency\": 100e6,\n    \"RF_inputs\": {\"port\": [\"octave1\", 1]},\n    \"operations\": {...}\n},\n</code></pre> QUAM<pre><code>from quam.components import IQChannel\n\n# Note the output/input is switched w.r.t. the QUA configuration\nRF_output = machine.octaves[\"octave1\"].RF_outputs[1]\n\nmachine.channels[\"qubit_xy\"] = channel = IQChannel(\n    opx_output_I=(\"con1\", 1),\n    opx_output_Q=(\"con1\", 2),\n    frequency_converter_up=RF_output.get_reference()\n)\nRF_output.channel = channel.get_reference()\n</code></pre> <p>Detailed instructions can be found at the Octave documentation.</p>"},{"location":"migrating-to-quam/#single-analog-output-input-channel","title":"Single Analog Output + Input Channel","text":"<p>For elements that function as both input and output channels, use InOutSingleChannel. This setup allows for efficient bidirectional communication:</p> qua_configuration[\"elements\"]<pre><code>\"qubit_readout\": {\n    \"singleInput\": {\n        \"port\": (\"con1\", 1),\n    },\n    \"outputs\": {\"out1\": (\"con1\", 2)},\n    \"operations\": {...}\n}\n</code></pre> QUAM<pre><code>from quam.components import InOutSingleChannel\n\nmachine.channels[\"qubit_readout\"] = InOutSingleChannel(\n    opx_output=(\"con1\", 1),\n    opx_input=(\"con1\", 2),\n)\n</code></pre>"},{"location":"migrating-to-quam/#iq-analog-output-input-channel","title":"IQ Analog Output + Input Channel","text":"<p>For complex setups involving both IQ modulation and bidirectional communication, the InOutIQChannel is the appropriate choice:</p> qua_configuration[\"elements\"]<pre><code>\"readout_resonator\": {\n    \"intermediate_frequency\": 100e6,\n    \"RF_inputs\": {\"port\": [\"octave1\", 1]},\n    \"RF_outputs\": {\"port\": [\"octave1\", 1]},\n    \"operations\": {...}\n},\n</code></pre> QUAM<pre><code>from quam.components import IQChannel\n\n# Note the output/input is switched w.r.t. the QUA configuration\nRF_output = machine.octaves[\"octave1\"].RF_outputs[1]\nRF_input = machine.octaves[\"octave1\"].RF_inputs[2]\n\nmachine.channels[\"readout_resonator\"] = channel = IQChannel(\n    opx_output_I=(\"con1\", 1),\n    opx_output_Q=(\"con1\", 2),\n    opx_input_I=(\"con1\", 1),\n    opx_input_Q=(\"con1\", 2),\n    frequency_converter_up=RF_output.get_reference()\n    frequency_converter_down=RF_input.get_reference()\n)\nRF_output.channel = channel.get_reference()\n</code></pre>"},{"location":"migrating-to-quam/#4-convert-pulses","title":"4: Convert Pulses","text":"<p>After converting elements into channels, the next step is to configure the pulses. Pulses in QUA are defined across several fields within the configuration, each contributing to how the pulse is shaped and controlled. In QUAM, these properties are consolidated, allowing for a more streamlined and parameterized approach to pulse definition.</p>"},{"location":"migrating-to-quam/#overview-of-qua-pulse-configuration","title":"Overview of QUA Pulse Configuration","text":"<p>In the QUA configuration, pulses are defined through the following components:</p> <ul> <li>\"waveforms\": These are the actual waveform shapes labeled for reference within pulses.</li> <li>\"digital_waveforms\": Digital signals that can be paired with analog waveforms to control pulse execution.</li> <li>\"integration_weights\": Used for defining how signals are integrated during readout.</li> <li>\"pulses\": This is a collection of pulse definitions, specifying labels, duration, and type of operation (<code>\"control\"</code> or <code>\"measurement\"</code>). Pulses may reference waveforms, digital waveforms, and integration weights specified in the other fields.</li> <li>element[\"operations\"]: Maps operation names to specific pulses defined in the <code>\"pulses\"</code> collection, linking them to the relevant channel.</li> </ul>"},{"location":"migrating-to-quam/#quam-pulse-configuration","title":"QUAM Pulse Configuration","text":"<p>In QUAM, pulse properties are grouped and parameterized by pulse type, simplifying the configuration process. Here is how you would convert a typical pulse setup from QUA to QUAM:</p>"},{"location":"migrating-to-quam/#example-converting-a-constant-voltage-pulse","title":"Example: Converting a Constant Voltage Pulse","text":"<p>Consider a QUA pulse configured to deliver a constant voltage. In QUAM, this corresponds to the SquarePulse component, which is designed for straightforward amplitude modulation.</p> <p>QUA Configuration:</p> <pre><code>{\n  \"elements\": {\n    \"qubit_xy\": {\n      \"intermediate_frequency\": 100e6,\n      \"mixInputs\": {\n        \"I\": [\"con1\", 1],\n        \"Q\": [\"con1\", 2],\n        \"lo_frequency\": 5e9,\n        \"mixer\": \"mixer_qubit\"\n      },\n      \"operations\": {\n        \"const_pulse\": \"const_pulse\"\n      }\n    }\n  },\n  \"pulses\": {\n    \"const_pulse\": {\n      \"operation\": \"control\",\n      \"length\": 1000,\n      \"waveforms\": { \"I\": \"const_wf\", \"Q\": \"zero_wf\" }\n    }\n  },\n  \"waveforms\": {\n    \"const_wf\": { \"type\": \"constant\", \"sample\": 0.5 },\n    \"zero_wf\": { \"type\": \"constant\", \"sample\": 0.0 }\n  }\n}\n</code></pre> <p>QUAM Conversion:</p> <pre><code>from quam.components import pulses\n\n# Assuming qubit_xy is configured as an IQChannel\nqubit_xy.operations[\"const_pulse\"] = pulses.SquarePulse(\n    length=1000,\n    amplitude=0.5,\n    axis_angle=0  # Phase angle on the IQ plane\n)\n</code></pre> <p>This example highlights the transformation of a basic pulse from QUA into a QUAM <code>SquarePulse</code>, demonstrating the streamlined approach QUAM offers for pulse configuration.</p> <p>For comprehensive details on configuring different types of pulses in QUAM, refer to the Pulses Documentation.</p>"},{"location":"migrating-to-quam/#5-generate-the-qua-configuration","title":"5: Generate the QUA configuration","text":"<p>Once the QUA configuration has been converted to QUAM, QUAM can in turn be used to generate the QUA configuration:</p> <pre><code>qua_config = machine.generate_config()\n</code></pre> <p>This <code>qua_config</code> can then be used to create a <code>QuantumMachine</code> object, which can be used to run quantum programs on the OPX.</p>"},{"location":"migrating-to-quam/#6-create-high-level-quam-components-optional","title":"6: Create High-Level QUAM Components (Optional)","text":"<p>After converting the QUA configuration to the corresponding QUAM components, an optional next step is to group similar components into higher-level abstractions. As an example, in the code above we had multiple channels belonging to the same qubit (<code>qubit_xy</code>, <code>qubit_z</code>, <code>qubit_readout</code>). We can group these channels into a single <code>Qubit</code> object to simplify the management of the qubit's configuration:</p> <pre><code>from quam.core import QuamComponent, quam_dataclass\nfrom quam.components import SingleChannel, IQChannel, InOutSingleChannel\n\n@quam_dataclass\nclass Qubit(QuamComponent):\n    xy: IQChannel\n    z: SingleChannel\n    readout: InOutSingleChannel\n\nqubit = Qubit(xy=qubit_xy, z=qubit_z, readout=qubit_readout)\n</code></pre> <p>This <code>Qubit</code> object can then be used to access the individual channels and their associated pulses, simplifying the management of the qubit's configuration.</p> <p>Note that the root-level QUAM object also needs to be customized to support the new <code>Qubit</code> object:</p> <pre><code>from typing import Dict\nfrom quam.core import QuamRoot\n\n@quam_dataclass\nclass Quam(QuamRoot):\n    qubits: Dict[str, Qubit]\n\nmachine = Quam(qubits={\"qubit1\": qubit})\n</code></pre> <p>See Custom QUAM Components for more information on creating custom QUAM components.</p>"},{"location":"migrating-to-quam/#conclusion","title":"Conclusion","text":"<p>Following these steps will guide you through transitioning your existing QUA codebase to QUAM. The primary goal of this migration is to harness QUAM's abstraction capabilities to organize and manage the underlying quantum-computing elements. QUAM provides a structured way to encapsulate the complexity of your configurations, which can facilitate maintenance and scalability. By understanding the mapping of QUA elements to QUAM components, you can effectively utilize this abstraction layer to enhance the organization of your quantum programs.</p>"},{"location":"API_references/","title":"QUAM API Reference","text":"<p>Welcome to the API Reference section of the Quantum Abstract Machine (QUAM) documentation. Here, you'll find comprehensive details on all components, classes, and methods that make up the QUAM framework. This documentation is designed to help developers understand and effectively utilize the powerful capabilities of QUAM for quantum computing applications.</p>"},{"location":"API_references/#quick-links","title":"Quick Links","text":"<ul> <li> <p>Core Components   Details on fundamental building blocks like QuamBase, QuamComponent and QuamRoot.   QuamBase</p> </li> <li> <p>Channel Components   Learn about channel configurations and their operations within the QUAM framework.</p> </li> <li> <p>Pulse Components   A detailed look at various pulse types and their properties used in quantum operations.</p> </li> <li> <p>Port Components   Comprehensive documentation on port abstractions including analog and digital inputs/outputs, and port containers.</p> </li> <li> <p>Hardware Components   Explore the hardware-related classes such as Mixer, LocalOscillator, and FrequencyConverter.</p> </li> <li> <p>Octave Components   Documentation on the <code>Octave</code> component and its associated up and down converters.</p> </li> <li> <p>Quantum Components   High-level abstractions for qubits and qubit pairs, enabling gate-level quantum programming.</p> </li> <li> <p>Macro Operations   Pre-built macro operations for common quantum gate sequences on qubits and qubit pairs.</p> </li> <li> <p>BasicQUAM Class   Details on the <code>BasicQUAM</code> class, the root-level QUAM instance that serves as the entry point for QUAM configurations.</p> </li> </ul>"},{"location":"API_references/_version/","title":"version","text":""},{"location":"API_references/components/basic_quam/","title":"Basic quam","text":""},{"location":"API_references/components/basic_quam/#quam.components.basic_quam.BasicFEMQuam","title":"<code>BasicFEMQuam</code>","text":"<p>               Bases: <code>BasicQuam</code></p> <p>Basic QUAM root component for FEM (Frequency Encoded Multiplexing) systems.</p> <p>Extends BasicQuam with FEM-specific port configurations for quantum control hardware.</p> <p>Attributes:</p> Name Type Description <code>ports</code> <code>FEMPortsContainer</code> <p>Container for FEM-specific analog and digital ports.</p> Source code in <code>quam/components/basic_quam.py</code> <pre><code>@quam_dataclass\nclass BasicFEMQuam(BasicQuam):\n    \"\"\"Basic QUAM root component for FEM (Frequency Encoded Multiplexing) systems.\n\n    Extends BasicQuam with FEM-specific port configurations for quantum control hardware.\n\n    Attributes:\n        ports (FEMPortsContainer): Container for FEM-specific analog and digital ports.\n    \"\"\"\n\n    ports: FEMPortsContainer = field(default_factory=FEMPortsContainer)\n</code></pre>"},{"location":"API_references/components/basic_quam/#quam.components.basic_quam.BasicOPXPlusQuam","title":"<code>BasicOPXPlusQuam</code>","text":"<p>               Bases: <code>BasicQuam</code></p> <p>Basic QUAM root component for OPX+ systems.</p> <p>Extends BasicQuam with OPX+-specific port configurations for quantum control hardware.</p> <p>Attributes:</p> Name Type Description <code>ports</code> <code>OPXPlusPortsContainer</code> <p>Container for OPX+ analog and digital ports.</p> Source code in <code>quam/components/basic_quam.py</code> <pre><code>@quam_dataclass\nclass BasicOPXPlusQuam(BasicQuam):\n    \"\"\"Basic QUAM root component for OPX+ systems.\n\n    Extends BasicQuam with OPX+-specific port configurations for quantum control hardware.\n\n    Attributes:\n        ports (OPXPlusPortsContainer): Container for OPX+ analog and digital ports.\n    \"\"\"\n\n    ports: OPXPlusPortsContainer = field(default_factory=OPXPlusPortsContainer)\n</code></pre>"},{"location":"API_references/components/basic_quam/#quam.components.basic_quam.BasicQuam","title":"<code>BasicQuam</code>","text":"<p>               Bases: <code>QuamRoot</code></p> <p>Basic top-level QUAM root component.</p> <p>If custom QUAM components are used, a custom QUAM root component should be created.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Dict[str, Channel]</code> <p>A dictionary of channels.</p> required <code>octaves</code> <code>Dict[str, Octave]</code> <p>A dictionary of octaves.</p> required Source code in <code>quam/components/basic_quam.py</code> <pre><code>@quam_dataclass\nclass BasicQuam(QuamRoot):\n    \"\"\"Basic top-level QUAM root component.\n\n    If custom QUAM components are used, a custom QUAM root component should be created.\n\n    Args:\n        channels (Dict[str, Channel], optional): A dictionary of channels.\n        octaves (Dict[str, Octave], optional): A dictionary of octaves.\n    \"\"\"\n\n    channels: Dict[str, Channel] = field(default_factory=dict)\n    octaves: Dict[str, Octave] = field(default_factory=dict)\n</code></pre>"},{"location":"API_references/components/basic_quam_API/","title":"BasicQuam API","text":""},{"location":"API_references/components/basic_quam_API/#quam.components.basic_quam.BasicFEMQuam","title":"<code>BasicFEMQuam</code>","text":"<p>               Bases: <code>BasicQuam</code></p> <p>Basic QUAM root component for FEM (Frequency Encoded Multiplexing) systems.</p> <p>Extends BasicQuam with FEM-specific port configurations for quantum control hardware.</p> <p>Attributes:</p> Name Type Description <code>ports</code> <code>FEMPortsContainer</code> <p>Container for FEM-specific analog and digital ports.</p> Source code in <code>quam/components/basic_quam.py</code> <pre><code>@quam_dataclass\nclass BasicFEMQuam(BasicQuam):\n    \"\"\"Basic QUAM root component for FEM (Frequency Encoded Multiplexing) systems.\n\n    Extends BasicQuam with FEM-specific port configurations for quantum control hardware.\n\n    Attributes:\n        ports (FEMPortsContainer): Container for FEM-specific analog and digital ports.\n    \"\"\"\n\n    ports: FEMPortsContainer = field(default_factory=FEMPortsContainer)\n</code></pre>"},{"location":"API_references/components/basic_quam_API/#quam.components.basic_quam.BasicOPXPlusQuam","title":"<code>BasicOPXPlusQuam</code>","text":"<p>               Bases: <code>BasicQuam</code></p> <p>Basic QUAM root component for OPX+ systems.</p> <p>Extends BasicQuam with OPX+-specific port configurations for quantum control hardware.</p> <p>Attributes:</p> Name Type Description <code>ports</code> <code>OPXPlusPortsContainer</code> <p>Container for OPX+ analog and digital ports.</p> Source code in <code>quam/components/basic_quam.py</code> <pre><code>@quam_dataclass\nclass BasicOPXPlusQuam(BasicQuam):\n    \"\"\"Basic QUAM root component for OPX+ systems.\n\n    Extends BasicQuam with OPX+-specific port configurations for quantum control hardware.\n\n    Attributes:\n        ports (OPXPlusPortsContainer): Container for OPX+ analog and digital ports.\n    \"\"\"\n\n    ports: OPXPlusPortsContainer = field(default_factory=OPXPlusPortsContainer)\n</code></pre>"},{"location":"API_references/components/basic_quam_API/#quam.components.basic_quam.BasicQuam","title":"<code>BasicQuam</code>","text":"<p>               Bases: <code>QuamRoot</code></p> <p>Basic top-level QUAM root component.</p> <p>If custom QUAM components are used, a custom QUAM root component should be created.</p> <p>Parameters:</p> Name Type Description Default <code>channels</code> <code>Dict[str, Channel]</code> <p>A dictionary of channels.</p> required <code>octaves</code> <code>Dict[str, Octave]</code> <p>A dictionary of octaves.</p> required Source code in <code>quam/components/basic_quam.py</code> <pre><code>@quam_dataclass\nclass BasicQuam(QuamRoot):\n    \"\"\"Basic top-level QUAM root component.\n\n    If custom QUAM components are used, a custom QUAM root component should be created.\n\n    Args:\n        channels (Dict[str, Channel], optional): A dictionary of channels.\n        octaves (Dict[str, Octave], optional): A dictionary of octaves.\n    \"\"\"\n\n    channels: Dict[str, Channel] = field(default_factory=dict)\n    octaves: Dict[str, Octave] = field(default_factory=dict)\n</code></pre>"},{"location":"API_references/components/channels/","title":"Channels","text":""},{"location":"API_references/components/channels/#quam.components.channels.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>QuamComponent</code>, <code>ABC</code></p> <p>Base QUAM component for a channel, can be output, input or both.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>sticky</code> <code>Sticky</code> <p>Optional sticky parameters for the channel, i.e. defining whether successive pulses are applied w.r.t the previous pulse or w.r.t 0 V. If not specified, this channel is not sticky.</p> required <code>digital_outputs</code> <code>Dict[str, DigitalOutputChannel]</code> <p>A dictionary of digital output channels to be used on this channel. The key is the label of the digital output channel (e.g. \"DO1\") and the value is a DigitalOutputChannel.</p> required <code>intermediate_frequency</code> <code>float</code> <p>The intermediate frequency of the channel in Hz. If not specified, the intermediate frequency is zero.</p> required <code>core</code> <code>str</code> <p>The core to use for the channel, useful when sharing a core between channels. If not specified, the core is assigned automatically.</p> required <code>thread</code> <code>str</code> <p>The channel core, duplicate of 'core' argument, and deprecated from qm.qua &gt;= 1.2.2.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass Channel(QuamComponent, ABC):\n    \"\"\"Base QUAM component for a channel, can be output, input or both.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        sticky (Sticky): Optional sticky parameters for the channel, i.e. defining\n            whether successive pulses are applied w.r.t the previous pulse or w.r.t 0 V.\n            If not specified, this channel is not sticky.\n        digital_outputs (Dict[str, DigitalOutputChannel]): A dictionary of digital\n            output channels to be used on this channel. The key is the label of the\n            digital output channel (e.g. \"DO1\") and the value is a DigitalOutputChannel.\n        intermediate_frequency (float, optional): The intermediate frequency of the\n            channel in Hz. If not specified, the intermediate frequency is zero.\n        core (str, optional): The core to use for the channel, useful when sharing a\n            core between channels. If not specified, the core is assigned automatically.\n        thread (str, optional): The channel core, duplicate of 'core' argument, and\n            deprecated from qm.qua &gt;= 1.2.2.\n    \"\"\"\n\n    operations: Dict[str, Pulse] = field(default_factory=dict)\n\n    id: Union[str, int] = None\n    _default_label: ClassVar[str] = \"ch\"  # Used to determine name from id\n\n    digital_outputs: Dict[str, DigitalOutputChannel] = field(default_factory=dict)\n    sticky: Optional[StickyChannelAddon] = None\n    intermediate_frequency: Optional[float] = None\n\n    thread: Optional[str] = None\n    core: Optional[str] = None\n\n    @property\n    def name(self) -&gt; str:\n        cls_name = self.__class__.__name__\n\n        if self.id is not None:\n            if str_ref.is_reference(self.id):\n                raise AttributeError(\n                    f\"{cls_name}.name cannot be determined. \"\n                    f\"Please either set {cls_name}.id to a string or integer, \"\n                    f\"or {cls_name} should be an attribute of another QUAM component.\"\n                )\n            if isinstance(self.id, str):\n                return self.id\n            else:\n                return f\"{self._default_label}{self.id}\"\n        if self.parent is None:\n            raise AttributeError(\n                f\"{cls_name}.name cannot be determined. \"\n                f\"Please either set {cls_name}.id to a string or integer, \"\n                f\"or {cls_name} should be an attribute of another QUAM component with \"\n                \"a name.\"\n            )\n        if isinstance(self.parent, QuamDict):\n            return self.parent.get_attr_name(self)\n        if not hasattr(self.parent, \"name\"):\n            raise AttributeError(\n                f\"{cls_name}.name cannot be determined. \"\n                f\"Please either set {cls_name}.id to a string or integer, \"\n                f\"or {cls_name} should be an attribute of another QUAM component with \"\n                \"a name.\"\n            )\n        return f\"{self.parent.name}{str_ref.DELIMITER}{self.parent.get_attr_name(self)}\"\n\n    @property\n    def pulse_mapping(self):\n        return {label: pulse.pulse_name for label, pulse in self.operations.items()}\n\n    def play(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        duration: ScalarInt = None,\n        condition: ScalarBool = None,\n        chirp: ChirpType = None,\n        truncate: ScalarInt = None,\n        timestamp_stream: StreamType = None,\n        continue_chirp: bool = False,\n        target: str = \"\",\n        validate: bool = True,\n    ):\n        \"\"\"Play a pulse on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            duration (Scalar[int]): Duration of the pulse in units of the\n                clock cycle (4ns). If not provided, the default pulse duration will be\n                used. It is possible to dynamically change the duration of both constant\n                and arbitrary pulses. Arbitrary pulses can only be stretched, not\n                compressed\n            chirp (Union[(list[int], str), (int, str)]): Allows to perform\n                piecewise linear sweep of the element's intermediate\n                frequency in time. Input should be a tuple, with the 1st\n                element being a list of rates and the second should be a\n                string with the units. The units can be either: 'Hz/nsec',\n                'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n                'KHz/sec', 'Hz/sec', 'mHz/sec'.\n            truncate (Scalar[int]): Allows playing\n                only part of the pulse, truncating the end. If provided,\n                will play only up to the given time in units of the clock\n                cycle (4ns).\n            condition (A logical expression to evaluate.): Will play analog\n                pulse only if the condition's value is true. Any digital\n                pulses associated with the operation will always play.\n            timestamp_stream (Union[str, _ResultSource]): (Supported from\n                QOP 2.2) Adding a `timestamp_stream` argument will save the\n                time at which the operation occurred to a stream. If the\n                `timestamp_stream` is a string ``label``, then the timestamp\n                handle can be retrieved with\n                `qm._results.JobResults.get` with the same ``label``.\n            validate (bool): If True (default), validate that the pulse is registered\n                in Channel.operations\n\n        Note:\n            The `element` argument from `qm.qua.play()`is not needed, as it is\n            automatically set to `self.name`.\n\n        \"\"\"\n        if validate and pulse_name not in self.operations:\n            raise KeyError(\n                f\"Operation '{pulse_name}' not found in channel '{self.name}'\"\n            )\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        # At the moment, self.name is not defined for Channel because it could\n        # be a property or dataclass field in a subclass.\n        # # TODO Find elegant solution for Channel.name.\n        play(\n            pulse=pulse_name_with_amp_scale,\n            element=self.name,\n            duration=duration,\n            condition=condition,\n            chirp=chirp,\n            truncate=truncate,\n            timestamp_stream=timestamp_stream,\n            continue_chirp=continue_chirp,\n            target=target,\n        )\n\n    def wait(self, duration: ScalarInt, *other_elements: Union[str, \"Channel\"]):\n        \"\"\"Wait for the given duration on all provided elements without outputting anything.\n\n        Duration is in units of the clock cycle (4ns)\n\n        Args:\n            duration (Scalar[int]): time to wait in units of the clock cycle\n                (4ns). Range: [4, $2^{31}-1$] in steps of 1.\n            *other_elements (Union[str,sequence of str]): elements to wait on,\n                in addition to this channel\n\n        Warning:\n            In case the value of this is outside the range above, unexpected results may occur.\n\n        Note:\n            The current channel element is always included in the wait operation.\n\n        Note:\n            The purpose of the `wait` operation is to add latency. In most cases, the\n            latency added will be exactly the same as that specified by the QUA variable or\n            the literal used. However, in some cases an additional computational latency may\n            be added. If the actual wait time has significance, such as in characterization\n            experiments, the actual wait time should always be verified with a simulator.\n        \"\"\"\n        other_elements_str = [\n            element if isinstance(element, str) else str(element)\n            for element in other_elements\n        ]\n        wait(duration, self.name, *other_elements_str)\n\n    def align(self, *other_elements):\n        if not other_elements:\n            align()\n        else:\n            other_elements_str = [\n                element if isinstance(element, str) else str(element)\n                for element in other_elements\n            ]\n            align(self.name, *other_elements_str)\n\n    def update_frequency(\n        self,\n        new_frequency: ScalarInt,\n        units: str = \"Hz\",\n        keep_phase: bool = False,\n    ):\n        \"\"\"Dynamically update the frequency of the associated oscillator.\n\n        This changes the frequency from the value defined in the channel.\n\n        The behavior of the phase (continuous vs. coherent) is controlled by the\n        ``keep_phase`` parameter and is discussed in the documentation.\n\n        Args:\n            new_frequency (Scalar[int]): The new frequency value to set\n                in units set by ``units`` parameter. In steps of 1.\n            units (str): units of new frequency. Useful when sub-Hz\n                precision is required. Allowed units are \"Hz\", \"mHz\", \"uHz\",\n                \"nHz\", \"pHz\"\n            keep_phase (bool): Determine whether phase will be continuous\n                through the change (if ``True``) or it will be coherent,\n                only the frequency will change (if ``False``).\n\n        Example:\n            ```python\n            with program() as prog:\n                update_frequency(\"q1\", 4e6) # will set the frequency to 4 MHz\n\n                ### Example for sub-Hz resolution\n                # will set the frequency to 100 Hz (due to casting to int)\n                update_frequency(\"q1\", 100.7)\n\n                # will set the frequency to 100.7 Hz\n                update_frequency(\"q1\", 100700, units='mHz')\n            ```\n        \"\"\"\n        update_frequency(self.name, new_frequency, units, keep_phase)\n\n    def reset_if_phase(self):\n        r\"\"\"\n        Resets the intermediate frequency phase of the oscillator, setting the phase of\n        the next pulse to absolute zero.\n        This sets the phase of the currently playing intermediate frequency\n        to the value it had at the beginning of the program (t=0).\n\n        Note:\n        - The phase will only be set to zero when the next play or align command is\n          executed on the element.\n        - Reset phase will only reset the phase of the intermediate frequency\n          (:math:`\\\\omega_{IF}`) currently in use.\n        \"\"\"\n        reset_if_phase(self.name)\n\n    def frame_rotation(self, angle: ScalarFloat):\n        r\"\"\"Shift the phase of the channel element's oscillator by the given angle.\n\n        This is typically used for virtual z-rotations.\n\n        Note:\n            The fixed point format of QUA variables of type fixed is 4.28, meaning the\n            phase must be between $-8$ and $8-2^{28}$. Otherwise the phase value will be\n            invalid. It is therefore better to use `frame_rotation_2pi()` which avoids\n            this issue.\n\n        Note:\n            The phase is accumulated with a resolution of 16 bit.\n            Therefore, *N* changes to the phase can result in a phase (and amplitude)\n            inaccuracy of about :math:`N \\cdot 2^{-16}`. To null out this accumulated\n            error, it is recommended to use `reset_frame(el)` from time to time.\n\n        Args:\n            angle (Scalar[float]): The angle to add to the current\n                phase (in radians)\n            *elements (str): a single element whose oscillator's phase will\n                be shifted. multiple elements can be given, in which case\n                all of their oscillators' phases will be shifted\n\n        \"\"\"\n        frame_rotation(angle, self.name)\n\n    def frame_rotation_2pi(self, angle: ScalarFloat):\n        r\"\"\"Shift the phase of the oscillator associated with an element by the given\n        angle in units of 2pi radians.\n\n        This is typically used for virtual z-rotations.\n\n        Note:\n            Unlike the case of frame_rotation(), this method performs the 2-pi radian\n            wrap around of the angle automatically.\n\n        Note:\n            The phase is accumulated with a resolution of 16 bit.\n            Therefore, *N* changes to the phase can result in a phase inaccuracy of\n            about :math:`N \\cdot 2^{-16}`. To null out this accumulated error, it is\n            recommended to use `reset_frame(el)` from time to time.\n\n        Args:\n            angle (Scalar[float]): The angle to add to the current\n                phase (in $2\\pi$ radians)\n        \"\"\"\n        frame_rotation_2pi(angle, self.name)\n\n    def _config_add_digital_outputs(self, config: Dict[str, dict]) -&gt; None:\n        \"\"\"Adds the digital outputs to the QUA config.\n\n        config.elements.&lt;element_name&gt;.digitalInputs will be updated with the digital\n        outputs of this channel.\n\n        Note that the digital outputs are added separately to the controller config in\n        `DigitalOutputChannel.apply_to_config`.\n\n        Args:\n            config (dict): The QUA config that's in the process of being generated.\n        \"\"\"\n        if not self.digital_outputs:\n            return\n\n        element_config = config[\"elements\"][self.name]\n        element_config.setdefault(\"digitalInputs\", {})\n\n        for name, digital_output in self.digital_outputs.items():\n            digital_cfg = digital_output.generate_element_config()\n            element_config[\"digitalInputs\"][name] = digital_cfg\n\n    def apply_to_config(self, config: Dict[str, dict]) -&gt; None:\n        \"\"\"Adds this Channel to the QUA configuration.\n\n        config.elements.&lt;element_name&gt; will be created, and the operations are added.\n\n        Args:\n            config (dict): The QUA config that's in the process of being generated.\n\n        Raises:\n            ValueError: If the channel already exists in the config.\n        \"\"\"\n        if self.name in config[\"elements\"]:\n            raise ValueError(\n                f\"Cannot add channel '{self.name}' to the config because it already \"\n                f\"exists. Existing entry: {config['elements'][self.name]}\"\n            )\n        config[\"elements\"][self.name] = {\"operations\": self.pulse_mapping}\n        element_config = config[\"elements\"][self.name]\n\n        if self.intermediate_frequency is not None:\n            element_config[\"intermediate_frequency\"] = self.intermediate_frequency\n\n        try:\n            qua_below_1_2_2 = Version(qm.__version__) &lt;= Version(\"1.2.1\")\n        except ImportError:\n            warnings.warn(\n                \"Unable to to determine qm package version, assuming &lt; 1.2.2. \"\n            )\n            qua_below_1_2_2 = True\n\n        if self.core is not None and self.thread is not None:\n            warnings.warn(\n                \"The 'thread' and 'core' arguments are mutually exclusive. \"\n                \"Using 'core' instead.\"\n            )\n            core = self.core\n        elif self.thread is not None:\n            if not qua_below_1_2_2:\n                warnings.warn(\n                    \"The 'thread' element argument is deprecated from qm.qua &gt;= 1.2.2. \"\n                    \"Use 'core' instead.\"\n                )\n            core = self.thread\n        else:\n            core = self.core\n\n        if core is not None:\n            if qua_below_1_2_2:\n                element_config[\"thread\"] = core\n            else:\n                element_config[\"core\"] = core\n\n        self._config_add_digital_outputs(config)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.Channel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this Channel to the QUA configuration.</p> <p>config.elements. will be created, and the operations are added. <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The QUA config that's in the process of being generated.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the channel already exists in the config.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: Dict[str, dict]) -&gt; None:\n    \"\"\"Adds this Channel to the QUA configuration.\n\n    config.elements.&lt;element_name&gt; will be created, and the operations are added.\n\n    Args:\n        config (dict): The QUA config that's in the process of being generated.\n\n    Raises:\n        ValueError: If the channel already exists in the config.\n    \"\"\"\n    if self.name in config[\"elements\"]:\n        raise ValueError(\n            f\"Cannot add channel '{self.name}' to the config because it already \"\n            f\"exists. Existing entry: {config['elements'][self.name]}\"\n        )\n    config[\"elements\"][self.name] = {\"operations\": self.pulse_mapping}\n    element_config = config[\"elements\"][self.name]\n\n    if self.intermediate_frequency is not None:\n        element_config[\"intermediate_frequency\"] = self.intermediate_frequency\n\n    try:\n        qua_below_1_2_2 = Version(qm.__version__) &lt;= Version(\"1.2.1\")\n    except ImportError:\n        warnings.warn(\n            \"Unable to to determine qm package version, assuming &lt; 1.2.2. \"\n        )\n        qua_below_1_2_2 = True\n\n    if self.core is not None and self.thread is not None:\n        warnings.warn(\n            \"The 'thread' and 'core' arguments are mutually exclusive. \"\n            \"Using 'core' instead.\"\n        )\n        core = self.core\n    elif self.thread is not None:\n        if not qua_below_1_2_2:\n            warnings.warn(\n                \"The 'thread' element argument is deprecated from qm.qua &gt;= 1.2.2. \"\n                \"Use 'core' instead.\"\n            )\n        core = self.thread\n    else:\n        core = self.core\n\n    if core is not None:\n        if qua_below_1_2_2:\n            element_config[\"thread\"] = core\n        else:\n            element_config[\"core\"] = core\n\n    self._config_add_digital_outputs(config)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.Channel.frame_rotation","title":"<code>frame_rotation(angle)</code>","text":"<p>Shift the phase of the channel element's oscillator by the given angle.</p> <p>This is typically used for virtual z-rotations.</p> Note <p>The fixed point format of QUA variables of type fixed is 4.28, meaning the phase must be between $-8$ and $8-2^{28}$. Otherwise the phase value will be invalid. It is therefore better to use <code>frame_rotation_2pi()</code> which avoids this issue.</p> Note <p>The phase is accumulated with a resolution of 16 bit. Therefore, N changes to the phase can result in a phase (and amplitude) inaccuracy of about :math:<code>N \\cdot 2^{-16}</code>. To null out this accumulated error, it is recommended to use <code>reset_frame(el)</code> from time to time.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Scalar[float]</code> <p>The angle to add to the current phase (in radians)</p> required <code>*elements</code> <code>str</code> <p>a single element whose oscillator's phase will be shifted. multiple elements can be given, in which case all of their oscillators' phases will be shifted</p> required Source code in <code>quam/components/channels.py</code> <pre><code>def frame_rotation(self, angle: ScalarFloat):\n    r\"\"\"Shift the phase of the channel element's oscillator by the given angle.\n\n    This is typically used for virtual z-rotations.\n\n    Note:\n        The fixed point format of QUA variables of type fixed is 4.28, meaning the\n        phase must be between $-8$ and $8-2^{28}$. Otherwise the phase value will be\n        invalid. It is therefore better to use `frame_rotation_2pi()` which avoids\n        this issue.\n\n    Note:\n        The phase is accumulated with a resolution of 16 bit.\n        Therefore, *N* changes to the phase can result in a phase (and amplitude)\n        inaccuracy of about :math:`N \\cdot 2^{-16}`. To null out this accumulated\n        error, it is recommended to use `reset_frame(el)` from time to time.\n\n    Args:\n        angle (Scalar[float]): The angle to add to the current\n            phase (in radians)\n        *elements (str): a single element whose oscillator's phase will\n            be shifted. multiple elements can be given, in which case\n            all of their oscillators' phases will be shifted\n\n    \"\"\"\n    frame_rotation(angle, self.name)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.Channel.frame_rotation_2pi","title":"<code>frame_rotation_2pi(angle)</code>","text":"<p>Shift the phase of the oscillator associated with an element by the given angle in units of 2pi radians.</p> <p>This is typically used for virtual z-rotations.</p> Note <p>Unlike the case of frame_rotation(), this method performs the 2-pi radian wrap around of the angle automatically.</p> Note <p>The phase is accumulated with a resolution of 16 bit. Therefore, N changes to the phase can result in a phase inaccuracy of about :math:<code>N \\cdot 2^{-16}</code>. To null out this accumulated error, it is recommended to use <code>reset_frame(el)</code> from time to time.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Scalar[float]</code> <p>The angle to add to the current phase (in $2\\pi$ radians)</p> required Source code in <code>quam/components/channels.py</code> <pre><code>def frame_rotation_2pi(self, angle: ScalarFloat):\n    r\"\"\"Shift the phase of the oscillator associated with an element by the given\n    angle in units of 2pi radians.\n\n    This is typically used for virtual z-rotations.\n\n    Note:\n        Unlike the case of frame_rotation(), this method performs the 2-pi radian\n        wrap around of the angle automatically.\n\n    Note:\n        The phase is accumulated with a resolution of 16 bit.\n        Therefore, *N* changes to the phase can result in a phase inaccuracy of\n        about :math:`N \\cdot 2^{-16}`. To null out this accumulated error, it is\n        recommended to use `reset_frame(el)` from time to time.\n\n    Args:\n        angle (Scalar[float]): The angle to add to the current\n            phase (in $2\\pi$ radians)\n    \"\"\"\n    frame_rotation_2pi(angle, self.name)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.Channel.play","title":"<code>play(pulse_name, amplitude_scale=None, duration=None, condition=None, chirp=None, truncate=None, timestamp_stream=None, continue_chirp=False, target='', validate=True)</code>","text":"<p>Play a pulse on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>duration</code> <code>Scalar[int]</code> <p>Duration of the pulse in units of the clock cycle (4ns). If not provided, the default pulse duration will be used. It is possible to dynamically change the duration of both constant and arbitrary pulses. Arbitrary pulses can only be stretched, not compressed</p> <code>None</code> <code>chirp</code> <code>Union[(list[int], str), (int, str)]</code> <p>Allows to perform piecewise linear sweep of the element's intermediate frequency in time. Input should be a tuple, with the 1st element being a list of rates and the second should be a string with the units. The units can be either: 'Hz/nsec', 'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec', 'KHz/sec', 'Hz/sec', 'mHz/sec'.</p> <code>None</code> <code>truncate</code> <code>Scalar[int]</code> <p>Allows playing only part of the pulse, truncating the end. If provided, will play only up to the given time in units of the clock cycle (4ns).</p> <code>None</code> <code>condition</code> <code>A logical expression to evaluate.</code> <p>Will play analog pulse only if the condition's value is true. Any digital pulses associated with the operation will always play.</p> <code>None</code> <code>timestamp_stream</code> <code>Union[str, _ResultSource]</code> <p>(Supported from QOP 2.2) Adding a <code>timestamp_stream</code> argument will save the time at which the operation occurred to a stream. If the <code>timestamp_stream</code> is a string <code>label</code>, then the timestamp handle can be retrieved with <code>qm._results.JobResults.get</code> with the same <code>label</code>.</p> <code>None</code> <code>validate</code> <code>bool</code> <p>If True (default), validate that the pulse is registered in Channel.operations</p> <code>True</code> Note <p>The <code>element</code> argument from <code>qm.qua.play()</code>is not needed, as it is automatically set to <code>self.name</code>.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def play(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    duration: ScalarInt = None,\n    condition: ScalarBool = None,\n    chirp: ChirpType = None,\n    truncate: ScalarInt = None,\n    timestamp_stream: StreamType = None,\n    continue_chirp: bool = False,\n    target: str = \"\",\n    validate: bool = True,\n):\n    \"\"\"Play a pulse on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        duration (Scalar[int]): Duration of the pulse in units of the\n            clock cycle (4ns). If not provided, the default pulse duration will be\n            used. It is possible to dynamically change the duration of both constant\n            and arbitrary pulses. Arbitrary pulses can only be stretched, not\n            compressed\n        chirp (Union[(list[int], str), (int, str)]): Allows to perform\n            piecewise linear sweep of the element's intermediate\n            frequency in time. Input should be a tuple, with the 1st\n            element being a list of rates and the second should be a\n            string with the units. The units can be either: 'Hz/nsec',\n            'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n            'KHz/sec', 'Hz/sec', 'mHz/sec'.\n        truncate (Scalar[int]): Allows playing\n            only part of the pulse, truncating the end. If provided,\n            will play only up to the given time in units of the clock\n            cycle (4ns).\n        condition (A logical expression to evaluate.): Will play analog\n            pulse only if the condition's value is true. Any digital\n            pulses associated with the operation will always play.\n        timestamp_stream (Union[str, _ResultSource]): (Supported from\n            QOP 2.2) Adding a `timestamp_stream` argument will save the\n            time at which the operation occurred to a stream. If the\n            `timestamp_stream` is a string ``label``, then the timestamp\n            handle can be retrieved with\n            `qm._results.JobResults.get` with the same ``label``.\n        validate (bool): If True (default), validate that the pulse is registered\n            in Channel.operations\n\n    Note:\n        The `element` argument from `qm.qua.play()`is not needed, as it is\n        automatically set to `self.name`.\n\n    \"\"\"\n    if validate and pulse_name not in self.operations:\n        raise KeyError(\n            f\"Operation '{pulse_name}' not found in channel '{self.name}'\"\n        )\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    # At the moment, self.name is not defined for Channel because it could\n    # be a property or dataclass field in a subclass.\n    # # TODO Find elegant solution for Channel.name.\n    play(\n        pulse=pulse_name_with_amp_scale,\n        element=self.name,\n        duration=duration,\n        condition=condition,\n        chirp=chirp,\n        truncate=truncate,\n        timestamp_stream=timestamp_stream,\n        continue_chirp=continue_chirp,\n        target=target,\n    )\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.Channel.reset_if_phase","title":"<code>reset_if_phase()</code>","text":"<p>Resets the intermediate frequency phase of the oscillator, setting the phase of the next pulse to absolute zero. This sets the phase of the currently playing intermediate frequency to the value it had at the beginning of the program (t=0).</p> <p>Note: - The phase will only be set to zero when the next play or align command is   executed on the element. - Reset phase will only reset the phase of the intermediate frequency   (:math:<code>\\\\omega_{IF}</code>) currently in use.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def reset_if_phase(self):\n    r\"\"\"\n    Resets the intermediate frequency phase of the oscillator, setting the phase of\n    the next pulse to absolute zero.\n    This sets the phase of the currently playing intermediate frequency\n    to the value it had at the beginning of the program (t=0).\n\n    Note:\n    - The phase will only be set to zero when the next play or align command is\n      executed on the element.\n    - Reset phase will only reset the phase of the intermediate frequency\n      (:math:`\\\\omega_{IF}`) currently in use.\n    \"\"\"\n    reset_if_phase(self.name)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.Channel.update_frequency","title":"<code>update_frequency(new_frequency, units='Hz', keep_phase=False)</code>","text":"<p>Dynamically update the frequency of the associated oscillator.</p> <p>This changes the frequency from the value defined in the channel.</p> <p>The behavior of the phase (continuous vs. coherent) is controlled by the <code>keep_phase</code> parameter and is discussed in the documentation.</p> <p>Parameters:</p> Name Type Description Default <code>new_frequency</code> <code>Scalar[int]</code> <p>The new frequency value to set in units set by <code>units</code> parameter. In steps of 1.</p> required <code>units</code> <code>str</code> <p>units of new frequency. Useful when sub-Hz precision is required. Allowed units are \"Hz\", \"mHz\", \"uHz\", \"nHz\", \"pHz\"</p> <code>'Hz'</code> <code>keep_phase</code> <code>bool</code> <p>Determine whether phase will be continuous through the change (if <code>True</code>) or it will be coherent, only the frequency will change (if <code>False</code>).</p> <code>False</code> Example <pre><code>with program() as prog:\n    update_frequency(\"q1\", 4e6) # will set the frequency to 4 MHz\n\n    ### Example for sub-Hz resolution\n    # will set the frequency to 100 Hz (due to casting to int)\n    update_frequency(\"q1\", 100.7)\n\n    # will set the frequency to 100.7 Hz\n    update_frequency(\"q1\", 100700, units='mHz')\n</code></pre> Source code in <code>quam/components/channels.py</code> <pre><code>def update_frequency(\n    self,\n    new_frequency: ScalarInt,\n    units: str = \"Hz\",\n    keep_phase: bool = False,\n):\n    \"\"\"Dynamically update the frequency of the associated oscillator.\n\n    This changes the frequency from the value defined in the channel.\n\n    The behavior of the phase (continuous vs. coherent) is controlled by the\n    ``keep_phase`` parameter and is discussed in the documentation.\n\n    Args:\n        new_frequency (Scalar[int]): The new frequency value to set\n            in units set by ``units`` parameter. In steps of 1.\n        units (str): units of new frequency. Useful when sub-Hz\n            precision is required. Allowed units are \"Hz\", \"mHz\", \"uHz\",\n            \"nHz\", \"pHz\"\n        keep_phase (bool): Determine whether phase will be continuous\n            through the change (if ``True``) or it will be coherent,\n            only the frequency will change (if ``False``).\n\n    Example:\n        ```python\n        with program() as prog:\n            update_frequency(\"q1\", 4e6) # will set the frequency to 4 MHz\n\n            ### Example for sub-Hz resolution\n            # will set the frequency to 100 Hz (due to casting to int)\n            update_frequency(\"q1\", 100.7)\n\n            # will set the frequency to 100.7 Hz\n            update_frequency(\"q1\", 100700, units='mHz')\n        ```\n    \"\"\"\n    update_frequency(self.name, new_frequency, units, keep_phase)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.Channel.wait","title":"<code>wait(duration, *other_elements)</code>","text":"<p>Wait for the given duration on all provided elements without outputting anything.</p> <p>Duration is in units of the clock cycle (4ns)</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Scalar[int]</code> <p>time to wait in units of the clock cycle (4ns). Range: [4, $2^{31}-1$] in steps of 1.</p> required <code>*other_elements</code> <code>Union[str,sequence of str]</code> <p>elements to wait on, in addition to this channel</p> <code>()</code> Warning <p>In case the value of this is outside the range above, unexpected results may occur.</p> Note <p>The current channel element is always included in the wait operation.</p> Note <p>The purpose of the <code>wait</code> operation is to add latency. In most cases, the latency added will be exactly the same as that specified by the QUA variable or the literal used. However, in some cases an additional computational latency may be added. If the actual wait time has significance, such as in characterization experiments, the actual wait time should always be verified with a simulator.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def wait(self, duration: ScalarInt, *other_elements: Union[str, \"Channel\"]):\n    \"\"\"Wait for the given duration on all provided elements without outputting anything.\n\n    Duration is in units of the clock cycle (4ns)\n\n    Args:\n        duration (Scalar[int]): time to wait in units of the clock cycle\n            (4ns). Range: [4, $2^{31}-1$] in steps of 1.\n        *other_elements (Union[str,sequence of str]): elements to wait on,\n            in addition to this channel\n\n    Warning:\n        In case the value of this is outside the range above, unexpected results may occur.\n\n    Note:\n        The current channel element is always included in the wait operation.\n\n    Note:\n        The purpose of the `wait` operation is to add latency. In most cases, the\n        latency added will be exactly the same as that specified by the QUA variable or\n        the literal used. However, in some cases an additional computational latency may\n        be added. If the actual wait time has significance, such as in characterization\n        experiments, the actual wait time should always be verified with a simulator.\n    \"\"\"\n    other_elements_str = [\n        element if isinstance(element, str) else str(element)\n        for element in other_elements\n    ]\n    wait(duration, self.name, *other_elements_str)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.DigitalOutputChannel","title":"<code>DigitalOutputChannel</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for a digital output channel (signal going out of the OPX)</p> <p>Should be added to <code>Channel.digital_outputs</code> so that it's also added to the respective element in the QUA config.</p> <p>Parameters:</p> Name Type Description Default <code>opx_output</code> <code>DigitalOutputPort</code> <p>Channel output port from the OPX perspective, E.g. FEMDigitalOutputPort(\"con1\", 1, 2)</p> required <code>delay</code> <code>int</code> <p>Delay in nanoseconds. An intrinsic negative delay of 136 ns exists by default.</p> required <code>buffer</code> <code>int</code> <p>Digital pulses played to this element will be convolved with a digital pulse of value 1 with this length [ns].</p> required <code>shareable</code> <code>(bool, deprecated)</code> <p>If True, the digital output can be shared with other QM instances. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusDigitalOutputPort(shareable=...)</code> instead. See Port documentation for details.</p> required <code>inverted</code> <code>(bool, deprecated)</code> <p>If True, the digital output is inverted. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusDigitalOutputPort(inverted=...)</code> instead. See Port documentation for details.</p> required <p>.</p> Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass DigitalOutputChannel(QuamComponent):\n    \"\"\"QUAM component for a digital output channel (signal going out of the OPX)\n\n    Should be added to `Channel.digital_outputs` so that it's also added to the\n    respective element in the QUA config.\n\n    Args:\n        opx_output (DigitalOutputPort): Channel output port from the OPX perspective,\n            E.g. FEMDigitalOutputPort(\"con1\", 1, 2)\n        delay (int, optional): Delay in nanoseconds. An intrinsic negative delay of\n            136 ns exists by default.\n        buffer (int, optional): Digital pulses played to this element will be convolved\n            with a digital pulse of value 1 with this length [ns].\n        shareable (bool, deprecated): If True, the digital output can be shared with other\n            QM instances.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusDigitalOutputPort(shareable=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        inverted (bool, deprecated): If True, the digital output is inverted.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusDigitalOutputPort(inverted=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n    .\"\"\"\n\n    opx_output: Union[Tuple[str, int], Tuple[str, int, int], DigitalOutputPort]\n    delay: int = None\n    buffer: int = None\n\n    shareable: bool = None\n    inverted: bool = None\n\n    def generate_element_config(self) -&gt; Dict[str, int]:\n        \"\"\"Generates the config entry for a digital channel in the QUA config.\n\n        This config entry goes into:\n        config.elements.&lt;element_name&gt;.digitalInputs.&lt;opx_output[1]&gt;\n\n        Returns:\n            Dict[str, int]: The digital channel config entry.\n                Contains \"port\", and optionally \"delay\", \"buffer\" if specified\n        \"\"\"\n        if isinstance(self.opx_output, DigitalOutputPort):\n            opx_output = self.opx_output.port_tuple\n        else:\n            opx_output = tuple(self.opx_output)\n\n        digital_cfg: Dict[str, Any] = {\"port\": opx_output}\n        if self.delay is not None:\n            digital_cfg[\"delay\"] = self.delay\n        if self.buffer is not None:\n            digital_cfg[\"buffer\"] = self.buffer\n        return digital_cfg\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Adds this DigitalOutputChannel to the QUA configuration.\n\n        config.controllers.&lt;controller_name&gt;.digital_outputs.&lt;port&gt; will be updated\n        with the shareable and inverted settings of this channel if specified.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        if isinstance(self.opx_output, DigitalOutputPort):\n            if self.shareable is not None:\n                msg = _create_port_property_deprecation_message(\n                    \"DigitalOutputChannel\",\n                    \"shareable\",\n                    self.shareable,\n                    self.opx_output,\n                )\n                warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            if self.inverted is not None:\n                msg = _create_port_property_deprecation_message(\n                    \"DigitalOutputChannel\",\n                    \"inverted\",\n                    self.inverted,\n                    self.opx_output,\n                )\n                warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            return\n\n        # Warn about deprecated port properties when using tuple notation\n        if self.shareable is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"shareable\",\n                self.shareable,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if self.inverted is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"inverted\",\n                self.inverted,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        shareable = self.shareable if self.shareable is not None else False\n        inverted = self.inverted if self.inverted is not None else False\n        if len(self.opx_output) == 2:\n            digital_output_port = OPXPlusDigitalOutputPort(\n                *self.opx_output, shareable=shareable, inverted=inverted\n            )\n        else:\n            digital_output_port = FEMDigitalOutputPort(\n                *self.opx_output, shareable=shareable, inverted=inverted\n            )\n        digital_output_port.apply_to_config(config)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.DigitalOutputChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this DigitalOutputChannel to the QUA configuration.</p> <p>config.controllers..digital_outputs. will be updated with the shareable and inverted settings of this channel if specified. <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Adds this DigitalOutputChannel to the QUA configuration.\n\n    config.controllers.&lt;controller_name&gt;.digital_outputs.&lt;port&gt; will be updated\n    with the shareable and inverted settings of this channel if specified.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    if isinstance(self.opx_output, DigitalOutputPort):\n        if self.shareable is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"shareable\",\n                self.shareable,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        if self.inverted is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"inverted\",\n                self.inverted,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        return\n\n    # Warn about deprecated port properties when using tuple notation\n    if self.shareable is not None:\n        msg = _create_port_property_deprecation_message(\n            \"DigitalOutputChannel\",\n            \"shareable\",\n            self.shareable,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if self.inverted is not None:\n        msg = _create_port_property_deprecation_message(\n            \"DigitalOutputChannel\",\n            \"inverted\",\n            self.inverted,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    shareable = self.shareable if self.shareable is not None else False\n    inverted = self.inverted if self.inverted is not None else False\n    if len(self.opx_output) == 2:\n        digital_output_port = OPXPlusDigitalOutputPort(\n            *self.opx_output, shareable=shareable, inverted=inverted\n        )\n    else:\n        digital_output_port = FEMDigitalOutputPort(\n            *self.opx_output, shareable=shareable, inverted=inverted\n        )\n    digital_output_port.apply_to_config(config)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.DigitalOutputChannel.generate_element_config","title":"<code>generate_element_config()</code>","text":"<p>Generates the config entry for a digital channel in the QUA config.</p> <p>This config entry goes into: config.elements..digitalInputs. <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: The digital channel config entry. Contains \"port\", and optionally \"delay\", \"buffer\" if specified</p> Source code in <code>quam/components/channels.py</code> <pre><code>def generate_element_config(self) -&gt; Dict[str, int]:\n    \"\"\"Generates the config entry for a digital channel in the QUA config.\n\n    This config entry goes into:\n    config.elements.&lt;element_name&gt;.digitalInputs.&lt;opx_output[1]&gt;\n\n    Returns:\n        Dict[str, int]: The digital channel config entry.\n            Contains \"port\", and optionally \"delay\", \"buffer\" if specified\n    \"\"\"\n    if isinstance(self.opx_output, DigitalOutputPort):\n        opx_output = self.opx_output.port_tuple\n    else:\n        opx_output = tuple(self.opx_output)\n\n    digital_cfg: Dict[str, Any] = {\"port\": opx_output}\n    if self.delay is not None:\n        digital_cfg[\"delay\"] = self.delay\n    if self.buffer is not None:\n        digital_cfg[\"buffer\"] = self.buffer\n    return digital_cfg\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.IQChannel","title":"<code>IQChannel</code>","text":"<p>               Bases: <code>_OutComplexChannel</code></p> <p>QUAM component for an IQ output channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output_I</code> <code>LF_output_port_types</code> <p>Channel I output port from the OPX perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_Q</code> <code>LF_output_port_types</code> <p>Channel Q output port from the OPX perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset_I</code> <code>(float, deprecated)</code> <p>The offset of the I channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(offset=...)</code> on the I port instead. See Port documentation for details.</p> required <code>opx_output_offset_Q</code> <code>(float, deprecated)</code> <p>The offset of the Q channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(offset=...)</code> on the Q port instead. See Port documentation for details.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of the mixer. Default is 0.0</p> required <code>LO_frequency</code> <code>float</code> <p>Local oscillator frequency. Default is the LO frequency of the frequency converter up component.</p> required <code>RF_frequency</code> <code>float</code> <p>RF frequency of the mixer. By default, the RF frequency is inferred by adding the LO frequency and the intermediate frequency.</p> required <code>frequency_converter_up</code> <code>FrequencyConverter</code> <p>Frequency converter QUAM component for the IQ output.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass IQChannel(_OutComplexChannel):\n    \"\"\"QUAM component for an IQ output channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output_I (LF_output_port_types): Channel I output port from the OPX\n            perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_Q (LF_output_port_types): Channel Q output port from the OPX\n            perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset_I (float, deprecated): The offset of the I channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(offset=...)` on the I port instead.\n            See [Port documentation](channel-ports.md) for details.\n        opx_output_offset_Q (float, deprecated): The offset of the Q channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(offset=...)` on the Q port instead.\n            See [Port documentation](channel-ports.md) for details.\n        intermediate_frequency (float): Intermediate frequency of the mixer.\n            Default is 0.0\n        LO_frequency (float): Local oscillator frequency. Default is the LO frequency\n            of the frequency converter up component.\n        RF_frequency (float): RF frequency of the mixer. By default, the RF frequency\n            is inferred by adding the LO frequency and the intermediate frequency.\n        frequency_converter_up (FrequencyConverter): Frequency converter QUAM component\n            for the IQ output.\n    \"\"\"\n\n    opx_output_I: LF_output_port_types\n    opx_output_Q: LF_output_port_types\n\n    opx_output_offset_I: float = None\n    opx_output_offset_Q: float = None\n\n    frequency_converter_up: BaseFrequencyConverter\n\n    LO_frequency: float = \"#./frequency_converter_up/LO_frequency\"\n    RF_frequency: float = \"#./inferred_RF_frequency\"\n\n    _default_label: ClassVar[str] = \"IQ\"\n\n    @property\n    def local_oscillator(self) -&gt; Optional[LocalOscillator]:\n        return getattr(self.frequency_converter_up, \"local_oscillator\", None)\n\n    @property\n    def mixer(self) -&gt; Optional[Mixer]:\n        return getattr(self.frequency_converter_up, \"mixer\", None)\n\n    @property\n    def rf_frequency(self):\n        warnings.warn(\n            \"rf_frequency is deprecated, use RF_frequency instead\", DeprecationWarning\n        )\n        return self.frequency_converter_up.LO_frequency + self.intermediate_frequency\n\n    def set_dc_offset(self, offset: ScalarFloat, element_input: Literal[\"I\", \"Q\"]):\n        \"\"\"Set the DC offset of an element's input to the given value.\n        This value will remain the DC offset until changed or until the Quantum Machine\n        is closed.\n\n        Args:\n            offset (Scalar[float]): The DC offset to set the input to.\n                This is limited by the OPX output voltage range.\n            element_input (Literal[\"I\", \"Q\"]): The element input to set the offset for.\n\n        Raises:\n            ValueError: If element_input is not \"I\" or \"Q\"\n        \"\"\"\n        if element_input not in [\"I\", \"Q\"]:\n            raise ValueError(\n                f\"element_input should be either 'I' or 'Q', got {element_input}\"\n            )\n        set_dc_offset(element=self.name, element_input=element_input, offset=offset)\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this IQChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        # Add pulses &amp; waveforms\n        super().apply_to_config(config)\n\n        if str_ref.is_reference(self.name):\n            raise AttributeError(\n                f\"Channel {self.get_reference()} cannot be added to the config because\"\n                \" it doesn't have a name. Either set channel.id to a string or\"\n                \" integer, or channel should be an attribute of another QUAM component\"\n                \" with a name.\"\n            )\n\n        element_config = config[\"elements\"][self.name]\n\n        # Check for deprecated port properties on channel\n        if self.opx_output_offset_I is not None:\n            msg = _create_port_property_deprecation_message(\n                \"IQChannel\",\n                \"opx_output_offset_I\",\n                self.opx_output_offset_I,\n                self.opx_output_I,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if self.opx_output_offset_Q is not None:\n            msg = _create_port_property_deprecation_message(\n                \"IQChannel\",\n                \"opx_output_offset_Q\",\n                self.opx_output_offset_Q,\n                self.opx_output_Q,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        from quam.components.octave import OctaveUpConverter\n\n        if isinstance(self.frequency_converter_up, OctaveUpConverter):\n            octave = self.frequency_converter_up.octave\n            if octave is None:\n                raise ValueError(\n                    f\"Error generating config: channel {self.name} has an \"\n                    f\"OctaveUpConverter (id={self.frequency_converter_up.id}) without \"\n                    \"an attached Octave\"\n                )\n            element_config[\"RF_inputs\"] = {\n                \"port\": (octave.name, self.frequency_converter_up.id)\n            }\n        elif str_ref.is_reference(self.frequency_converter_up):\n            raise ValueError(\n                f\"Error generating config: channel {self.name} could not determine \"\n                f'\"frequency_converter_up\", it seems to point to a non-existent '\n                f\"reference: {self.frequency_converter_up}\"\n            )\n        else:\n            element_config[\"mixInputs\"] = {}  # To be filled in next section\n            if self.mixer is not None:\n                element_config[\"mixInputs\"][\"mixer\"] = self.mixer.name\n            if self.local_oscillator is not None:\n                element_config[\"mixInputs\"][\"lo_frequency\"] = (\n                    self.local_oscillator.frequency\n                )\n\n        opx_outputs = [self.opx_output_I, self.opx_output_Q]\n        offsets = [self.opx_output_offset_I, self.opx_output_offset_Q]\n        for I_or_Q, opx_output, offset in zip(\"IQ\", opx_outputs, offsets):\n            if isinstance(opx_output, LFAnalogOutputPort):\n                opx_port = opx_output\n            elif len(opx_output) == 2:\n                opx_port = OPXPlusAnalogOutputPort(*opx_output, offset=offset)\n                opx_port.apply_to_config(config)\n            else:\n                opx_port = LFFEMAnalogOutputPort(*opx_output, offset=offset)\n                opx_port.apply_to_config(config)\n\n            if \"mixInputs\" in element_config:\n                element_config[\"mixInputs\"][I_or_Q] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.IQChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this IQChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this IQChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    # Add pulses &amp; waveforms\n    super().apply_to_config(config)\n\n    if str_ref.is_reference(self.name):\n        raise AttributeError(\n            f\"Channel {self.get_reference()} cannot be added to the config because\"\n            \" it doesn't have a name. Either set channel.id to a string or\"\n            \" integer, or channel should be an attribute of another QUAM component\"\n            \" with a name.\"\n        )\n\n    element_config = config[\"elements\"][self.name]\n\n    # Check for deprecated port properties on channel\n    if self.opx_output_offset_I is not None:\n        msg = _create_port_property_deprecation_message(\n            \"IQChannel\",\n            \"opx_output_offset_I\",\n            self.opx_output_offset_I,\n            self.opx_output_I,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if self.opx_output_offset_Q is not None:\n        msg = _create_port_property_deprecation_message(\n            \"IQChannel\",\n            \"opx_output_offset_Q\",\n            self.opx_output_offset_Q,\n            self.opx_output_Q,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    from quam.components.octave import OctaveUpConverter\n\n    if isinstance(self.frequency_converter_up, OctaveUpConverter):\n        octave = self.frequency_converter_up.octave\n        if octave is None:\n            raise ValueError(\n                f\"Error generating config: channel {self.name} has an \"\n                f\"OctaveUpConverter (id={self.frequency_converter_up.id}) without \"\n                \"an attached Octave\"\n            )\n        element_config[\"RF_inputs\"] = {\n            \"port\": (octave.name, self.frequency_converter_up.id)\n        }\n    elif str_ref.is_reference(self.frequency_converter_up):\n        raise ValueError(\n            f\"Error generating config: channel {self.name} could not determine \"\n            f'\"frequency_converter_up\", it seems to point to a non-existent '\n            f\"reference: {self.frequency_converter_up}\"\n        )\n    else:\n        element_config[\"mixInputs\"] = {}  # To be filled in next section\n        if self.mixer is not None:\n            element_config[\"mixInputs\"][\"mixer\"] = self.mixer.name\n        if self.local_oscillator is not None:\n            element_config[\"mixInputs\"][\"lo_frequency\"] = (\n                self.local_oscillator.frequency\n            )\n\n    opx_outputs = [self.opx_output_I, self.opx_output_Q]\n    offsets = [self.opx_output_offset_I, self.opx_output_offset_Q]\n    for I_or_Q, opx_output, offset in zip(\"IQ\", opx_outputs, offsets):\n        if isinstance(opx_output, LFAnalogOutputPort):\n            opx_port = opx_output\n        elif len(opx_output) == 2:\n            opx_port = OPXPlusAnalogOutputPort(*opx_output, offset=offset)\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogOutputPort(*opx_output, offset=offset)\n            opx_port.apply_to_config(config)\n\n        if \"mixInputs\" in element_config:\n            element_config[\"mixInputs\"][I_or_Q] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.IQChannel.set_dc_offset","title":"<code>set_dc_offset(offset, element_input)</code>","text":"<p>Set the DC offset of an element's input to the given value. This value will remain the DC offset until changed or until the Quantum Machine is closed.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>Scalar[float]</code> <p>The DC offset to set the input to. This is limited by the OPX output voltage range.</p> required <code>element_input</code> <code>Literal['I', 'Q']</code> <p>The element input to set the offset for.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If element_input is not \"I\" or \"Q\"</p> Source code in <code>quam/components/channels.py</code> <pre><code>def set_dc_offset(self, offset: ScalarFloat, element_input: Literal[\"I\", \"Q\"]):\n    \"\"\"Set the DC offset of an element's input to the given value.\n    This value will remain the DC offset until changed or until the Quantum Machine\n    is closed.\n\n    Args:\n        offset (Scalar[float]): The DC offset to set the input to.\n            This is limited by the OPX output voltage range.\n        element_input (Literal[\"I\", \"Q\"]): The element input to set the offset for.\n\n    Raises:\n        ValueError: If element_input is not \"I\" or \"Q\"\n    \"\"\"\n    if element_input not in [\"I\", \"Q\"]:\n        raise ValueError(\n            f\"element_input should be either 'I' or 'Q', got {element_input}\"\n        )\n    set_dc_offset(element=self.name, element_input=element_input, offset=offset)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InIQChannel","title":"<code>InIQChannel</code>","text":"<p>               Bases: <code>_InComplexChannel</code></p> <p>QUAM component for an IQ input channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_input_I</code> <code>LF_input_port_types</code> <p>Channel I input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_Q</code> <code>LF_input_port_types</code> <p>Channel Q input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset_I</code> <code>(float, deprecated)</code> <p>The offset of the I channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogInputPort(offset=...)</code> on the I port instead. See Port documentation for details.</p> required <code>opx_input_offset_Q</code> <code>(float, deprecated)</code> <p>The offset of the Q channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogInputPort(offset=...)</code> on the Q port instead. See Port documentation for details.</p> required <code>frequency_converter_down</code> <code>Optional[FrequencyConverter]</code> <p>Frequency converter QUAM component for the IQ input port. Only needed for the old Octave.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required <code>input_gain</code> <code>float</code> <p>The gain of the input channel. Default is None.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InIQChannel(_InComplexChannel):\n    \"\"\"QUAM component for an IQ input channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_input_I (LF_input_port_types): Channel I input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_Q (LF_input_port_types): Channel Q input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset_I (float, deprecated): The offset of the I channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogInputPort(offset=...)` on the I port instead.\n            See [Port documentation](channel-ports.md) for details.\n        opx_input_offset_Q (float, deprecated): The offset of the Q channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogInputPort(offset=...)` on the Q port instead.\n            See [Port documentation](channel-ports.md) for details.\n        frequency_converter_down (Optional[FrequencyConverter]): Frequency converter\n            QUAM component for the IQ input port. Only needed for the old Octave.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n        input_gain (float): The gain of the input channel. Default is None.\n    \"\"\"\n\n    opx_input_I: LF_input_port_types\n    opx_input_Q: LF_input_port_types\n\n    time_of_flight: int = 140\n    smearing: int = 0\n\n    opx_input_offset_I: float = None\n    opx_input_offset_Q: float = None\n\n    input_gain: Optional[int] = None\n\n    frequency_converter_down: BaseFrequencyConverter = None\n\n    _default_label: ClassVar[str] = \"IQ\"\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this InOutIQChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        super().apply_to_config(config)\n\n        # Note outputs instead of inputs because it's w.r.t. the QPU\n        element_config = config[\"elements\"][self.name]\n        element_config[\"smearing\"] = self.smearing\n        element_config[\"time_of_flight\"] = self.time_of_flight\n\n        from quam.components.octave import OctaveDownConverter\n\n        if isinstance(self.frequency_converter_down, OctaveDownConverter):\n            octave = self.frequency_converter_down.octave\n            if octave is None:\n                raise ValueError(\n                    f\"Error generating config: channel {self.name} has an \"\n                    f\"OctaveDownConverter (id={self.frequency_converter_down.id}) \"\n                    \"without an attached Octave\"\n                )\n            element_config[\"RF_outputs\"] = {\n                \"port\": (octave.name, self.frequency_converter_down.id)\n            }\n        elif str_ref.is_reference(self.frequency_converter_down):\n            raise ValueError(\n                f\"Error generating config: channel {self.name} could not determine \"\n                f'\"frequency_converter_down\", it seems to point to a non-existent '\n                f\"reference: {self.frequency_converter_down}\"\n            )\n        else:\n            # To be filled in next section\n            element_config[\"outputs\"] = {}\n\n        # Check for deprecated port properties on channel\n        if self.opx_input_offset_I is not None:\n            msg = _create_port_property_deprecation_message(\n                \"InIQChannel\",\n                \"opx_input_offset_I\",\n                self.opx_input_offset_I,\n                self.opx_input_I,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if self.opx_input_offset_Q is not None:\n            msg = _create_port_property_deprecation_message(\n                \"InIQChannel\",\n                \"opx_input_offset_Q\",\n                self.opx_input_offset_Q,\n                self.opx_input_Q,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        opx_inputs = [self.opx_input_I, self.opx_input_Q]\n        offsets = [self.opx_input_offset_I, self.opx_input_offset_Q]\n        input_gain = int(self.input_gain if self.input_gain is not None else 0)\n        for k, (opx_input, offset) in enumerate(zip(opx_inputs, offsets), start=1):\n            if isinstance(opx_input, LFAnalogInputPort):\n                opx_port = opx_input\n            elif len(opx_input) == 2:\n                opx_port = OPXPlusAnalogInputPort(\n                    *opx_input, offset=offset, gain_db=input_gain\n                )\n                opx_port.apply_to_config(config)\n            else:\n                opx_port = LFFEMAnalogInputPort(\n                    *opx_input, offset=offset, gain_db=input_gain\n                )\n                opx_port.apply_to_config(config)\n            if not isinstance(self.frequency_converter_down, OctaveDownConverter):\n                element_config[\"outputs\"][f\"out{k}\"] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InIQChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this InOutIQChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this InOutIQChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    super().apply_to_config(config)\n\n    # Note outputs instead of inputs because it's w.r.t. the QPU\n    element_config = config[\"elements\"][self.name]\n    element_config[\"smearing\"] = self.smearing\n    element_config[\"time_of_flight\"] = self.time_of_flight\n\n    from quam.components.octave import OctaveDownConverter\n\n    if isinstance(self.frequency_converter_down, OctaveDownConverter):\n        octave = self.frequency_converter_down.octave\n        if octave is None:\n            raise ValueError(\n                f\"Error generating config: channel {self.name} has an \"\n                f\"OctaveDownConverter (id={self.frequency_converter_down.id}) \"\n                \"without an attached Octave\"\n            )\n        element_config[\"RF_outputs\"] = {\n            \"port\": (octave.name, self.frequency_converter_down.id)\n        }\n    elif str_ref.is_reference(self.frequency_converter_down):\n        raise ValueError(\n            f\"Error generating config: channel {self.name} could not determine \"\n            f'\"frequency_converter_down\", it seems to point to a non-existent '\n            f\"reference: {self.frequency_converter_down}\"\n        )\n    else:\n        # To be filled in next section\n        element_config[\"outputs\"] = {}\n\n    # Check for deprecated port properties on channel\n    if self.opx_input_offset_I is not None:\n        msg = _create_port_property_deprecation_message(\n            \"InIQChannel\",\n            \"opx_input_offset_I\",\n            self.opx_input_offset_I,\n            self.opx_input_I,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if self.opx_input_offset_Q is not None:\n        msg = _create_port_property_deprecation_message(\n            \"InIQChannel\",\n            \"opx_input_offset_Q\",\n            self.opx_input_offset_Q,\n            self.opx_input_Q,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    opx_inputs = [self.opx_input_I, self.opx_input_Q]\n    offsets = [self.opx_input_offset_I, self.opx_input_offset_Q]\n    input_gain = int(self.input_gain if self.input_gain is not None else 0)\n    for k, (opx_input, offset) in enumerate(zip(opx_inputs, offsets), start=1):\n        if isinstance(opx_input, LFAnalogInputPort):\n            opx_port = opx_input\n        elif len(opx_input) == 2:\n            opx_port = OPXPlusAnalogInputPort(\n                *opx_input, offset=offset, gain_db=input_gain\n            )\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogInputPort(\n                *opx_input, offset=offset, gain_db=input_gain\n            )\n            opx_port.apply_to_config(config)\n        if not isinstance(self.frequency_converter_down, OctaveDownConverter):\n            element_config[\"outputs\"][f\"out{k}\"] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InIQOutSingleChannel","title":"<code>InIQOutSingleChannel</code>","text":"<p>               Bases: <code>SingleChannel</code>, <code>InIQChannel</code></p> <p>QUAM component for an IQ input channel with a single output.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>LF_output_port_types</code> <p>Channel output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_offset</code> <code>float</code> <p>DC offset for the output port.</p> required <code>opx_input_I</code> <code>LF_input_port_types</code> <p>Channel I input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_Q</code> <code>LF_input_port_types</code> <p>Channel Q input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_input_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>filter_fir_taps</code> <code>List[float]</code> <p>FIR filter taps for the output port.</p> required <code>filter_iir_taps</code> <code>List[float]</code> <p>IIR filter taps for the output port.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InIQOutSingleChannel(SingleChannel, InIQChannel):\n    \"\"\"QUAM component for an IQ input channel with a single output.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (LF_output_port_types): Channel output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_offset (float): DC offset for the output port.\n        opx_input_I (LF_input_port_types): Channel I input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_Q (LF_input_port_types): Channel Q input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset_I (float): The offset of the I channel. Default is 0.\n        opx_input_offset_Q (float): The offset of the Q channel. Default is 0.\n        filter_fir_taps (List[float]): FIR filter taps for the output port.\n        filter_iir_taps (List[float]): IIR filter taps for the output port.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InMWChannel","title":"<code>InMWChannel</code>","text":"<p>               Bases: <code>_InComplexChannel</code></p> <p>QUAM component for a MW FEM input channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_input</code> <code>MWFEMAnalogInputPort</code> <p>Channel input port from the OPX perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds. Default is 280, which is a reasonable default for the MW FEM.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing. Default is 0.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InMWChannel(_InComplexChannel):\n    \"\"\"QUAM component for a MW FEM input channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_input (MWFEMAnalogInputPort): Channel input port from the OPX\n            perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds. Default is 280,\n            which is a reasonable default for the MW FEM.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing. Default is 0.\n    \"\"\"\n\n    opx_input: MWFEMAnalogInputPort\n\n    time_of_flight: int = 280\n    smearing: int = 0\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        super().apply_to_config(config)\n\n        element_config = config[\"elements\"][self.name]\n        element_config[\"MWOutput\"] = {\"port\": self.opx_input.port_tuple}\n        element_config[\"smearing\"] = self.smearing\n        element_config[\"time_of_flight\"] = self.time_of_flight\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InOutIQChannel","title":"<code>InOutIQChannel</code>","text":"<p>               Bases: <code>IQChannel</code>, <code>InIQChannel</code></p> <p>QUAM component for an IQ channel with both input and output.</p> <p>An example of such a channel is a readout resonator, where you may want to apply a readout tone and then measure the response.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output_I</code> <code>LF_output_port_types</code> <p>Channel I output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_Q</code> <code>LF_output_port_types</code> <p>Channel Q output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_output_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>opx_input_I</code> <code>LF_input_port_types</code> <p>Channel I input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_Q</code> <code>LF_input_port_types</code> <p>Channel Q input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_input_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of the mixer. Default is 0.0</p> required <code>LO_frequency</code> <code>float</code> <p>Local oscillator frequency. Default is the LO frequency of the frequency converter up component.</p> required <code>RF_frequency</code> <code>float</code> <p>RF frequency of the mixer. By default, the RF frequency is inferred by adding the LO frequency and the intermediate frequency.</p> required <code>frequency_converter_up</code> <code>FrequencyConverter</code> <p>Frequency converter QUAM component for the IQ output.</p> required <code>frequency_converter_down</code> <code>Optional[FrequencyConverter]</code> <p>Frequency converter QUAM component for the IQ input port. Only needed for the old Octave.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InOutIQChannel(IQChannel, InIQChannel):\n    \"\"\"QUAM component for an IQ channel with both input and output.\n\n    An example of such a channel is a readout resonator, where you may want to\n    apply a readout tone and then measure the response.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output_I (LF_output_port_types): Channel I output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_Q (LF_output_port_types): Channel Q output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset_I (float): The offset of the I channel. Default is 0.\n        opx_output_offset_Q (float): The offset of the Q channel. Default is 0.\n        opx_input_I (LF_input_port_types): Channel I input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_Q (LF_input_port_types): Channel Q input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset_I (float): The offset of the I channel. Default is 0.\n        opx_input_offset_Q (float): The offset of the Q channel. Default is 0.\n        intermediate_frequency (float): Intermediate frequency of the mixer.\n            Default is 0.0\n        LO_frequency (float): Local oscillator frequency. Default is the LO frequency\n            of the frequency converter up component.\n        RF_frequency (float): RF frequency of the mixer. By default, the RF frequency\n            is inferred by adding the LO frequency and the intermediate frequency.\n        frequency_converter_up (FrequencyConverter): Frequency converter QUAM component\n            for the IQ output.\n        frequency_converter_down (Optional[FrequencyConverter]): Frequency converter\n            QUAM component for the IQ input port. Only needed for the old Octave.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InOutMWChannel","title":"<code>InOutMWChannel</code>","text":"<p>               Bases: <code>MWChannel</code>, <code>InMWChannel</code></p> <p>QUAM component for a MW FEM input channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>MWFEMAnalogOutputPort</code> <p>Channel output port from the OPX perspective, e.g. MWFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_input</code> <code>MWFEMAnalogInputPort</code> <p>Channel input port from the OPX perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>upconverter</code> <code>int</code> <p>The upconverter to use. Default is 1.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InOutMWChannel(MWChannel, InMWChannel):\n    \"\"\"QUAM component for a MW FEM input channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (MWFEMAnalogOutputPort): Channel output port from the OPX\n            perspective, e.g. MWFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_input (MWFEMAnalogInputPort): Channel input port from the OPX\n            perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        upconverter (int): The upconverter to use. Default is 1.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InOutSingleChannel","title":"<code>InOutSingleChannel</code>","text":"<p>               Bases: <code>SingleChannel</code>, <code>InSingleChannel</code></p> <p>QUAM component for a single (not IQ) input + output channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>LF_output_port_types</code> <p>Channel output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset</code> <code>float</code> <p>DC offset for the output port.</p> required <code>opx_input</code> <code>LF_input_port_types</code> <p>Channel input port from OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset</code> <code>float</code> <p>DC offset for the input port.</p> required <code>filter_fir_taps</code> <code>List[float]</code> <p>FIR filter taps for the output port.</p> required <code>filter_iir_taps</code> <code>List[float]</code> <p>IIR filter taps for the output port.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InOutSingleChannel(SingleChannel, InSingleChannel):\n    \"\"\"QUAM component for a single (not IQ) input + output channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (LF_output_port_types): Channel output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset (float): DC offset for the output port.\n        opx_input (LF_input_port_types): Channel input port from OPX perspective,\n            e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset (float): DC offset for the input port.\n        filter_fir_taps (List[float]): FIR filter taps for the output port.\n        filter_iir_taps (List[float]): IIR filter taps for the output port.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InSingleChannel","title":"<code>InSingleChannel</code>","text":"<p>               Bases: <code>Channel</code></p> <p>QUAM component for a single (not IQ) input channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_input</code> <code>LF_input_port_types</code> <p>Channel input port from OPX perspective, E.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset</code> <code>(float, deprecated)</code> <p>DC offset for the input port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogInputPort(offset=...)</code> instead. See Port documentation for details.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX input, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InSingleChannel(Channel):\n    \"\"\"QUAM component for a single (not IQ) input channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_input (LF_input_port_types): Channel input port from OPX perspective,\n            E.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset (float, deprecated): DC offset for the input port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogInputPort(offset=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        intermediate_frequency (float): Intermediate frequency of OPX input,\n            default is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    opx_input: LF_input_port_types\n    opx_input_offset: float = None\n\n    time_of_flight: int = 140\n    smearing: int = 0\n\n    time_tagging: Optional[TimeTaggingAddon] = None\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this InSingleChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        # Add output to config\n        super().apply_to_config(config)\n\n        # Note outputs instead of inputs because it's w.r.t. the QPU\n        element_config = config[\"elements\"][self.name]\n        element_config[\"smearing\"] = self.smearing\n        element_config[\"time_of_flight\"] = self.time_of_flight\n\n        # Check for deprecated port properties on channel\n        if self.opx_input_offset is not None:\n            msg = _create_port_property_deprecation_message(\n                \"InSingleChannel\",\n                \"opx_input_offset\",\n                self.opx_input_offset,\n                self.opx_input,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if isinstance(self.opx_input, LFAnalogInputPort):\n            opx_port = self.opx_input\n        elif len(self.opx_input) == 2:\n            opx_port = OPXPlusAnalogInputPort(\n                *self.opx_input, offset=self.opx_input_offset\n            )\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogInputPort(\n                *self.opx_input, offset=self.opx_input_offset\n            )\n            opx_port.apply_to_config(config)\n\n        element_config[\"outputs\"] = {\"out1\": opx_port.port_tuple}\n\n    def measure(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        qua_vars: Tuple[QuaVariableFloat, ...] = None,\n        stream=None,\n    ) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n        \"\"\"Perform a full demodulation measurement on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            qua_vars (Tuple[QuaVariable[float], ...], optional): Two QUA\n                variables to store the I, Q measurement results.\n                If not provided, new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n\n        Returns:\n            I, Q: The QUA variables used to store the measurement results.\n                If provided as input, the same variables will be returned.\n                If not provided, new variables will be declared and returned.\n\n        Raises:\n            ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n                variables.\n        \"\"\"\n\n        pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n        if qua_vars is not None:\n            if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n                raise ValueError(\n                    f\"InOutSingleChannel.measure received kwarg 'qua_vars' \"\n                    f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n                )\n        else:\n            qua_vars = [declare(fixed) for _ in range(2)]\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        integration_weight_labels = list(pulse.integration_weights_mapping)\n        measure(\n            pulse_name_with_amp_scale,\n            self.name,\n            demod.full(integration_weight_labels[0], qua_vars[0], \"out1\"),\n            demod.full(integration_weight_labels[1], qua_vars[1], \"out1\"),\n            adc_stream=stream,\n        )\n        return tuple(qua_vars)\n\n    def measure_accumulated(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        num_segments: int = None,\n        segment_length: int = None,\n        qua_vars: Tuple[QuaVariableFloat, ...] = None,\n        stream=None,\n    ) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n        \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            num_segments (int): The number of segments to accumulate.\n                Should either specify this or `segment_length`.\n            segment_length (int): The length of the segment to accumulate.\n                Should either specify this or `num_segments`.\n            qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n                variables to store the I, Q measurement results.\n                If not provided, new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n\n        Returns:\n            I, Q: The QUA variables used to store the measurement results.\n                If provided as input, the same variables will be returned.\n                If not provided, new variables will be declared and returned.\n\n        Raises:\n            ValueError: If both `num_segments` and `segment_length` are provided, or if\n                neither are provided.\n            ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n                variables.\n        \"\"\"\n        pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n        if num_segments is None and segment_length is None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_accumulated requires either 'segment_length' \"\n                \"or 'num_segments' to be provided.\"\n            )\n        elif num_segments is not None and segment_length is not None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_accumulated received both 'segment_length' \"\n                \"and 'num_segments'. Please provide only one.\"\n            )\n        elif num_segments is None:\n            num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n        elif segment_length is None:\n            segment_length = int(pulse.length / (4 * num_segments))\n\n        if qua_vars is not None:\n            if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n                raise ValueError(\n                    f\"InOutSingleChannel.measure_accumulated received kwarg 'qua_vars' \"\n                    f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n                )\n        else:\n            qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        integration_weight_labels = list(pulse.integration_weights_mapping)\n        measure(\n            pulse_name_with_amp_scale,\n            self.name,\n            demod.accumulated(\n                integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n            ),\n            demod.accumulated(\n                integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n            ),\n            adc_stream=stream,\n        )\n        return tuple(qua_vars)\n\n    def measure_sliced(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        num_segments: int = None,\n        segment_length: int = None,\n        qua_vars: Tuple[QuaVariableFloat, ...] = None,\n        stream=None,\n    ) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n        \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            num_segments (int): The number of segments to accumulate.\n                Should either specify this or `segment_length`.\n            segment_length (int): The length of the segment to accumulate.\n                Should either specify this or `num_segments`.\n            qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n                variables to store the I, Q measurement results.\n                If not provided, new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n\n        Returns:\n            I, Q: The QUA variables used to store the measurement results.\n                If provided as input, the same variables will be returned.\n                If not provided, new variables will be declared and returned.\n\n        Raises:\n            ValueError: If both `num_segments` and `segment_length` are provided, or if\n                neither are provided.\n            ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n                variables.\n        \"\"\"\n        pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n        if num_segments is None and segment_length is None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_sliced requires either 'segment_length' \"\n                \"or 'num_segments' to be provided.\"\n            )\n        elif num_segments is not None and segment_length is not None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_sliced received both 'segment_length' \"\n                \"and 'num_segments'. Please provide only one.\"\n            )\n        elif num_segments is None:\n            num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n        elif segment_length is None:\n            segment_length = int(pulse.length / (4 * num_segments))\n\n        if qua_vars is not None:\n            if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n                raise ValueError(\n                    f\"InOutSingleChannel.measure_sliced received kwarg 'qua_vars' \"\n                    f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n                )\n        else:\n            qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        integration_weight_labels = list(pulse.integration_weights_mapping)\n        measure(\n            pulse_name_with_amp_scale,\n            self.name,\n            demod.sliced(\n                integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n            ),\n            demod.sliced(\n                integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n            ),\n            adc_stream=stream,\n        )\n        return tuple(qua_vars)\n\n    def measure_time_tagging(\n        self,\n        pulse_name: str,\n        size: int,\n        max_time: int,\n        qua_vars: Optional[Tuple[QuaVariableInt, QuaScalarInt]] = None,\n        stream: Optional[StreamType] = None,\n        mode: Literal[\"analog\", \"high_res\", \"digital\"] = \"analog\",\n    ) -&gt; Tuple[QuaVariableInt, QuaScalarInt]:\n        \"\"\"Perform a time tagging measurement on this channel.\n\n        For details see https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            size (int): The size of the QUA array to store the times of the detected\n                pulses. Ignored if `qua_vars` is provided.\n            max_time (int): The maximum time to search for pulses.\n            qua_vars (Tuple[QuaVariableInt, QuaScalarInt], optional): QUA variables\n                to store the times and counts of the detected pulses. If not provided,\n                new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n            mode (Literal[\"analog\", \"high_res\", \"digital\"]): The time tagging mode.\n\n        Returns:\n            times (QuaVariable[Any]): The QUA variable to store the times of the detected\n                pulses.\n            counts (QuaScalar[int]): The number of detected pulses.\n\n        Example:\n            ```python\n            times, counts = channel.measure_time_tagging(\"readout\", size=1000, max_time=1000)\n            ```\n        \"\"\"\n        if mode == \"analog\":\n            time_tagging_func = time_tagging.analog\n        elif mode == \"high_res\":\n            time_tagging_func = time_tagging.high_res\n        elif mode == \"digital\":\n            time_tagging_func = time_tagging.digital\n        else:\n            raise ValueError(f\"Invalid time tagging mode: {mode}\")\n\n        if qua_vars is None:\n            times = declare(int, size=size)\n            counts = declare(int)\n        else:\n            times, counts = qua_vars\n\n        measure(\n            pulse_name,\n            self.name,\n            time_tagging_func(target=times, max_time=max_time, targetLen=counts),\n            adc_stream=stream,\n        )\n        return times, counts\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InSingleChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this InSingleChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this InSingleChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    # Add output to config\n    super().apply_to_config(config)\n\n    # Note outputs instead of inputs because it's w.r.t. the QPU\n    element_config = config[\"elements\"][self.name]\n    element_config[\"smearing\"] = self.smearing\n    element_config[\"time_of_flight\"] = self.time_of_flight\n\n    # Check for deprecated port properties on channel\n    if self.opx_input_offset is not None:\n        msg = _create_port_property_deprecation_message(\n            \"InSingleChannel\",\n            \"opx_input_offset\",\n            self.opx_input_offset,\n            self.opx_input,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if isinstance(self.opx_input, LFAnalogInputPort):\n        opx_port = self.opx_input\n    elif len(self.opx_input) == 2:\n        opx_port = OPXPlusAnalogInputPort(\n            *self.opx_input, offset=self.opx_input_offset\n        )\n        opx_port.apply_to_config(config)\n    else:\n        opx_port = LFFEMAnalogInputPort(\n            *self.opx_input, offset=self.opx_input_offset\n        )\n        opx_port.apply_to_config(config)\n\n    element_config[\"outputs\"] = {\"out1\": opx_port.port_tuple}\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InSingleChannel.measure","title":"<code>measure(pulse_name, amplitude_scale=None, qua_vars=None, stream=None)</code>","text":"<p>Perform a full demodulation measurement on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>qua_vars</code> <code>Tuple[QuaVariable[float], ...]</code> <p>Two QUA variables to store the I, Q measurement results. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[QuaVariableFloat, QuaVariableFloat]</code> <p>I, Q: The QUA variables used to store the measurement results. If provided as input, the same variables will be returned. If not provided, new variables will be declared and returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>qua_vars</code> is provided and is not a tuple of two QUA variables.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def measure(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    qua_vars: Tuple[QuaVariableFloat, ...] = None,\n    stream=None,\n) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n    \"\"\"Perform a full demodulation measurement on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        qua_vars (Tuple[QuaVariable[float], ...], optional): Two QUA\n            variables to store the I, Q measurement results.\n            If not provided, new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n\n    Returns:\n        I, Q: The QUA variables used to store the measurement results.\n            If provided as input, the same variables will be returned.\n            If not provided, new variables will be declared and returned.\n\n    Raises:\n        ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n            variables.\n    \"\"\"\n\n    pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n    if qua_vars is not None:\n        if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n            raise ValueError(\n                f\"InOutSingleChannel.measure received kwarg 'qua_vars' \"\n                f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n            )\n    else:\n        qua_vars = [declare(fixed) for _ in range(2)]\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    integration_weight_labels = list(pulse.integration_weights_mapping)\n    measure(\n        pulse_name_with_amp_scale,\n        self.name,\n        demod.full(integration_weight_labels[0], qua_vars[0], \"out1\"),\n        demod.full(integration_weight_labels[1], qua_vars[1], \"out1\"),\n        adc_stream=stream,\n    )\n    return tuple(qua_vars)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InSingleChannel.measure_accumulated","title":"<code>measure_accumulated(pulse_name, amplitude_scale=None, num_segments=None, segment_length=None, qua_vars=None, stream=None)</code>","text":"<p>Perform an accumulated demodulation measurement on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>num_segments</code> <code>int</code> <p>The number of segments to accumulate. Should either specify this or <code>segment_length</code>.</p> <code>None</code> <code>segment_length</code> <code>int</code> <p>The length of the segment to accumulate. Should either specify this or <code>num_segments</code>.</p> <code>None</code> <code>qua_vars</code> <code>Tuple[QuaVariableFloat, ...]</code> <p>Two QUA variables to store the I, Q measurement results. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[QuaVariableFloat, QuaVariableFloat]</code> <p>I, Q: The QUA variables used to store the measurement results. If provided as input, the same variables will be returned. If not provided, new variables will be declared and returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>num_segments</code> and <code>segment_length</code> are provided, or if neither are provided.</p> <code>ValueError</code> <p>If <code>qua_vars</code> is provided and is not a tuple of two QUA variables.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def measure_accumulated(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    num_segments: int = None,\n    segment_length: int = None,\n    qua_vars: Tuple[QuaVariableFloat, ...] = None,\n    stream=None,\n) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n    \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        num_segments (int): The number of segments to accumulate.\n            Should either specify this or `segment_length`.\n        segment_length (int): The length of the segment to accumulate.\n            Should either specify this or `num_segments`.\n        qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n            variables to store the I, Q measurement results.\n            If not provided, new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n\n    Returns:\n        I, Q: The QUA variables used to store the measurement results.\n            If provided as input, the same variables will be returned.\n            If not provided, new variables will be declared and returned.\n\n    Raises:\n        ValueError: If both `num_segments` and `segment_length` are provided, or if\n            neither are provided.\n        ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n            variables.\n    \"\"\"\n    pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n    if num_segments is None and segment_length is None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_accumulated requires either 'segment_length' \"\n            \"or 'num_segments' to be provided.\"\n        )\n    elif num_segments is not None and segment_length is not None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_accumulated received both 'segment_length' \"\n            \"and 'num_segments'. Please provide only one.\"\n        )\n    elif num_segments is None:\n        num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n    elif segment_length is None:\n        segment_length = int(pulse.length / (4 * num_segments))\n\n    if qua_vars is not None:\n        if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n            raise ValueError(\n                f\"InOutSingleChannel.measure_accumulated received kwarg 'qua_vars' \"\n                f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n            )\n    else:\n        qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    integration_weight_labels = list(pulse.integration_weights_mapping)\n    measure(\n        pulse_name_with_amp_scale,\n        self.name,\n        demod.accumulated(\n            integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n        ),\n        demod.accumulated(\n            integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n        ),\n        adc_stream=stream,\n    )\n    return tuple(qua_vars)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InSingleChannel.measure_sliced","title":"<code>measure_sliced(pulse_name, amplitude_scale=None, num_segments=None, segment_length=None, qua_vars=None, stream=None)</code>","text":"<p>Perform an accumulated demodulation measurement on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>num_segments</code> <code>int</code> <p>The number of segments to accumulate. Should either specify this or <code>segment_length</code>.</p> <code>None</code> <code>segment_length</code> <code>int</code> <p>The length of the segment to accumulate. Should either specify this or <code>num_segments</code>.</p> <code>None</code> <code>qua_vars</code> <code>Tuple[QuaVariableFloat, ...]</code> <p>Two QUA variables to store the I, Q measurement results. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[QuaVariableFloat, QuaVariableFloat]</code> <p>I, Q: The QUA variables used to store the measurement results. If provided as input, the same variables will be returned. If not provided, new variables will be declared and returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>num_segments</code> and <code>segment_length</code> are provided, or if neither are provided.</p> <code>ValueError</code> <p>If <code>qua_vars</code> is provided and is not a tuple of two QUA variables.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def measure_sliced(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    num_segments: int = None,\n    segment_length: int = None,\n    qua_vars: Tuple[QuaVariableFloat, ...] = None,\n    stream=None,\n) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n    \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        num_segments (int): The number of segments to accumulate.\n            Should either specify this or `segment_length`.\n        segment_length (int): The length of the segment to accumulate.\n            Should either specify this or `num_segments`.\n        qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n            variables to store the I, Q measurement results.\n            If not provided, new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n\n    Returns:\n        I, Q: The QUA variables used to store the measurement results.\n            If provided as input, the same variables will be returned.\n            If not provided, new variables will be declared and returned.\n\n    Raises:\n        ValueError: If both `num_segments` and `segment_length` are provided, or if\n            neither are provided.\n        ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n            variables.\n    \"\"\"\n    pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n    if num_segments is None and segment_length is None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_sliced requires either 'segment_length' \"\n            \"or 'num_segments' to be provided.\"\n        )\n    elif num_segments is not None and segment_length is not None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_sliced received both 'segment_length' \"\n            \"and 'num_segments'. Please provide only one.\"\n        )\n    elif num_segments is None:\n        num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n    elif segment_length is None:\n        segment_length = int(pulse.length / (4 * num_segments))\n\n    if qua_vars is not None:\n        if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n            raise ValueError(\n                f\"InOutSingleChannel.measure_sliced received kwarg 'qua_vars' \"\n                f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n            )\n    else:\n        qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    integration_weight_labels = list(pulse.integration_weights_mapping)\n    measure(\n        pulse_name_with_amp_scale,\n        self.name,\n        demod.sliced(\n            integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n        ),\n        demod.sliced(\n            integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n        ),\n        adc_stream=stream,\n    )\n    return tuple(qua_vars)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InSingleChannel.measure_time_tagging","title":"<code>measure_time_tagging(pulse_name, size, max_time, qua_vars=None, stream=None, mode='analog')</code>","text":"<p>Perform a time tagging measurement on this channel.</p> <p>For details see https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>size</code> <code>int</code> <p>The size of the QUA array to store the times of the detected pulses. Ignored if <code>qua_vars</code> is provided.</p> required <code>max_time</code> <code>int</code> <p>The maximum time to search for pulses.</p> required <code>qua_vars</code> <code>Tuple[QuaVariableInt, QuaScalarInt]</code> <p>QUA variables to store the times and counts of the detected pulses. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <code>mode</code> <code>Literal['analog', 'high_res', 'digital']</code> <p>The time tagging mode.</p> <code>'analog'</code> <p>Returns:</p> Name Type Description <code>times</code> <code>QuaVariable[Any]</code> <p>The QUA variable to store the times of the detected pulses.</p> <code>counts</code> <code>QuaScalar[int]</code> <p>The number of detected pulses.</p> Example <pre><code>times, counts = channel.measure_time_tagging(\"readout\", size=1000, max_time=1000)\n</code></pre> Source code in <code>quam/components/channels.py</code> <pre><code>def measure_time_tagging(\n    self,\n    pulse_name: str,\n    size: int,\n    max_time: int,\n    qua_vars: Optional[Tuple[QuaVariableInt, QuaScalarInt]] = None,\n    stream: Optional[StreamType] = None,\n    mode: Literal[\"analog\", \"high_res\", \"digital\"] = \"analog\",\n) -&gt; Tuple[QuaVariableInt, QuaScalarInt]:\n    \"\"\"Perform a time tagging measurement on this channel.\n\n    For details see https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        size (int): The size of the QUA array to store the times of the detected\n            pulses. Ignored if `qua_vars` is provided.\n        max_time (int): The maximum time to search for pulses.\n        qua_vars (Tuple[QuaVariableInt, QuaScalarInt], optional): QUA variables\n            to store the times and counts of the detected pulses. If not provided,\n            new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n        mode (Literal[\"analog\", \"high_res\", \"digital\"]): The time tagging mode.\n\n    Returns:\n        times (QuaVariable[Any]): The QUA variable to store the times of the detected\n            pulses.\n        counts (QuaScalar[int]): The number of detected pulses.\n\n    Example:\n        ```python\n        times, counts = channel.measure_time_tagging(\"readout\", size=1000, max_time=1000)\n        ```\n    \"\"\"\n    if mode == \"analog\":\n        time_tagging_func = time_tagging.analog\n    elif mode == \"high_res\":\n        time_tagging_func = time_tagging.high_res\n    elif mode == \"digital\":\n        time_tagging_func = time_tagging.digital\n    else:\n        raise ValueError(f\"Invalid time tagging mode: {mode}\")\n\n    if qua_vars is None:\n        times = declare(int, size=size)\n        counts = declare(int)\n    else:\n        times, counts = qua_vars\n\n    measure(\n        pulse_name,\n        self.name,\n        time_tagging_func(target=times, max_time=max_time, targetLen=counts),\n        adc_stream=stream,\n    )\n    return times, counts\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.InSingleOutIQChannel","title":"<code>InSingleOutIQChannel</code>","text":"<p>               Bases: <code>IQChannel</code>, <code>InSingleChannel</code></p> <p>QUAM component for an IQ output channel with a single input.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output_I</code> <code>LF_output_port_types</code> <p>Channel I output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_Q</code> <code>LF_output_port_types</code> <p>Channel Q output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_output_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>opx_input</code> <code>LF_input_port_types</code> <p>Channel input port from OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_offset</code> <code>float</code> <p>DC offset for the input port.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of the mixer. Default is 0.0</p> required <code>LO_frequency</code> <code>float</code> <p>Local oscillator frequency. Default is the LO frequency of the frequency converter up component.</p> required <code>RF_frequency</code> <code>float</code> <p>RF frequency of the mixer. By default, the RF frequency is inferred by adding the LO frequency and the intermediate frequency.</p> required <code>frequency_converter_up</code> <code>FrequencyConverter</code> <p>Frequency converter QUAM component for the IQ output.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InSingleOutIQChannel(IQChannel, InSingleChannel):\n    \"\"\"QUAM component for an IQ output channel with a single input.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output_I (LF_output_port_types): Channel I output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_Q (LF_output_port_types): Channel Q output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset_I (float): The offset of the I channel. Default is 0.\n        opx_output_offset_Q (float): The offset of the Q channel. Default is 0.\n        opx_input (LF_input_port_types): Channel input port from OPX perspective,\n            e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_offset (float): DC offset for the input port.\n        intermediate_frequency (float): Intermediate frequency of the mixer.\n            Default is 0.0\n        LO_frequency (float): Local oscillator frequency. Default is the LO frequency\n            of the frequency converter up component.\n        RF_frequency (float): RF frequency of the mixer. By default, the RF frequency\n            is inferred by adding the LO frequency and the intermediate frequency.\n        frequency_converter_up (FrequencyConverter): Frequency converter QUAM component\n            for the IQ output.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.MWChannel","title":"<code>MWChannel</code>","text":"<p>               Bases: <code>_OutComplexChannel</code></p> <p>QUAM component for a MW FEM output channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>MWFEMAnalogOutputPort</code> <p>Channel output port from the OPX perspective.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>upconverter</code> <code>int</code> <p>The upconverter to use. Default is 1.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass MWChannel(_OutComplexChannel):\n    \"\"\"QUAM component for a MW FEM output channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (MWFEMAnalogOutputPort): Channel output port from the OPX perspective.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        upconverter (int): The upconverter to use. Default is 1.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    opx_output: MWFEMAnalogOutputPort\n    upconverter: int = 1\n\n    LO_frequency: float = \"#./upconverter_frequency\"\n    RF_frequency: float = \"#./inferred_RF_frequency\"\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        super().apply_to_config(config)\n\n        element_config = config[\"elements\"][self.name]\n        element_config[\"MWInput\"] = {\n            \"port\": self.opx_output.port_tuple,\n            \"upconverter\": self.upconverter,\n        }\n\n    @property\n    def upconverter_frequency(self) -&gt; float:\n        \"\"\"Determine the upconverter frequency from the opx_output.\n\n        If the upconverter frequency is not set, the upconverter frequency is inferred\n        from the upconverters dictionary.\n\n        Returns:\n            The upconverter frequency.\n\n        Raises:\n            ValueError: If the upconverter frequency is not set and cannot be inferred.\n        \"\"\"\n        if self.opx_output.upconverter_frequency is not None:\n            return self.opx_output.upconverter_frequency\n        if self.opx_output.upconverters is not None:\n            upconverter_config = self.opx_output.upconverters.get(self.upconverter)\n            if upconverter_config is None:\n                raise ValueError(\n                    f\"MWChannel: Upconverter {self.upconverter} not found in upconverters dictionary\"\n                )\n            if \"frequency\" not in upconverter_config:\n                raise ValueError(\n                    f\"MWChannel: 'frequency' key not found in upconverter {self.upconverter} configuration\"\n                )\n            return upconverter_config[\"frequency\"]\n        raise ValueError(\n            \"MWChannel: Either upconverter_frequency or upconverters must be provided\"\n        )\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.MWChannel.upconverter_frequency","title":"<code>upconverter_frequency</code>  <code>property</code>","text":"<p>Determine the upconverter frequency from the opx_output.</p> <p>If the upconverter frequency is not set, the upconverter frequency is inferred from the upconverters dictionary.</p> <p>Returns:</p> Type Description <code>float</code> <p>The upconverter frequency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the upconverter frequency is not set and cannot be inferred.</p>"},{"location":"API_references/components/channels/#quam.components.channels.SingleChannel","title":"<code>SingleChannel</code>","text":"<p>               Bases: <code>Channel</code></p> <p>QUAM component for a single (not IQ) output channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>LF_output_port_types</code> <p>Channel output port from the OPX perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>filter_fir_taps</code> <code>(List[float], deprecated)</code> <p>FIR filter taps for the output port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(feedforward_filter=...)</code> instead. See Port documentation for details.</p> required <code>filter_iir_taps</code> <code>(List[float], deprecated)</code> <p>IIR filter taps for the output port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(feedback_filter=...)</code> instead. See Port documentation for details.</p> required <code>opx_output_offset</code> <code>(float, deprecated)</code> <p>DC offset for the output port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(offset=...)</code> instead. See Port documentation for details.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass SingleChannel(Channel):\n    \"\"\"QUAM component for a single (not IQ) output channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (LF_output_port_types): Channel output port from the OPX perspective,\n            E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        filter_fir_taps (List[float], deprecated): FIR filter taps for the output port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(feedforward_filter=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        filter_iir_taps (List[float], deprecated): IIR filter taps for the output port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(feedback_filter=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        opx_output_offset (float, deprecated): DC offset for the output port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(offset=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n    \"\"\"\n\n    opx_output: LF_output_port_types\n    filter_fir_taps: List[float] = None\n    filter_iir_taps: List[float] = None\n\n    opx_output_offset: float = None\n\n    def set_dc_offset(self, offset: ScalarFloat):\n        \"\"\"Set the DC offset of an element's input to the given value.\n        This value will remain the DC offset until changed or until the Quantum Machine\n        is closed.\n\n        Args:\n            offset (Scalar[float]): The DC offset to set the input to.\n                This is limited by the OPX output voltage range.\n        \"\"\"\n        set_dc_offset(element=self.name, element_input=\"single\", offset=offset)\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this SingleChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        # Add pulses &amp; waveforms\n        super().apply_to_config(config)\n\n        if str_ref.is_reference(self.name):\n            raise AttributeError(\n                f\"Channel {self.get_reference()} cannot be added to the config because\"\n                \" it doesn't have a name. Either set channel.id to a string or\"\n                \" integer, or channel should be an attribute of another QUAM component\"\n                \" with a name.\"\n            )\n\n        element_config = config[\"elements\"][self.name]\n\n        # Check for deprecated port properties on channel\n        if self.opx_output_offset is not None:\n            msg = _create_port_property_deprecation_message(\n                \"SingleChannel\",\n                \"opx_output_offset\",\n                self.opx_output_offset,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        filter_fir_taps = self.filter_fir_taps\n        if filter_fir_taps is not None:\n            msg = _create_port_property_deprecation_message(\n                \"SingleChannel\",\n                \"filter_fir_taps\",\n                filter_fir_taps,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            filter_fir_taps = list(filter_fir_taps)\n        filter_iir_taps = self.filter_iir_taps\n        if filter_iir_taps is not None:\n            msg = _create_port_property_deprecation_message(\n                \"SingleChannel\",\n                \"filter_iir_taps\",\n                filter_iir_taps,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            filter_iir_taps = list(filter_iir_taps)\n\n        if isinstance(self.opx_output, LFAnalogOutputPort):\n            opx_port = self.opx_output\n        elif len(self.opx_output) == 2:\n            opx_port = OPXPlusAnalogOutputPort(\n                *self.opx_output,\n                offset=self.opx_output_offset,\n                feedforward_filter=filter_fir_taps,\n                feedback_filter=filter_iir_taps,\n            )\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogOutputPort(\n                *self.opx_output,\n                offset=self.opx_output_offset,\n                feedforward_filter=filter_fir_taps,\n                feedback_filter=filter_iir_taps,\n            )\n            opx_port.apply_to_config(config)\n\n        element_config[\"singleInput\"] = {\"port\": opx_port.port_tuple}\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.SingleChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this SingleChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this SingleChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    # Add pulses &amp; waveforms\n    super().apply_to_config(config)\n\n    if str_ref.is_reference(self.name):\n        raise AttributeError(\n            f\"Channel {self.get_reference()} cannot be added to the config because\"\n            \" it doesn't have a name. Either set channel.id to a string or\"\n            \" integer, or channel should be an attribute of another QUAM component\"\n            \" with a name.\"\n        )\n\n    element_config = config[\"elements\"][self.name]\n\n    # Check for deprecated port properties on channel\n    if self.opx_output_offset is not None:\n        msg = _create_port_property_deprecation_message(\n            \"SingleChannel\",\n            \"opx_output_offset\",\n            self.opx_output_offset,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    filter_fir_taps = self.filter_fir_taps\n    if filter_fir_taps is not None:\n        msg = _create_port_property_deprecation_message(\n            \"SingleChannel\",\n            \"filter_fir_taps\",\n            filter_fir_taps,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        filter_fir_taps = list(filter_fir_taps)\n    filter_iir_taps = self.filter_iir_taps\n    if filter_iir_taps is not None:\n        msg = _create_port_property_deprecation_message(\n            \"SingleChannel\",\n            \"filter_iir_taps\",\n            filter_iir_taps,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        filter_iir_taps = list(filter_iir_taps)\n\n    if isinstance(self.opx_output, LFAnalogOutputPort):\n        opx_port = self.opx_output\n    elif len(self.opx_output) == 2:\n        opx_port = OPXPlusAnalogOutputPort(\n            *self.opx_output,\n            offset=self.opx_output_offset,\n            feedforward_filter=filter_fir_taps,\n            feedback_filter=filter_iir_taps,\n        )\n        opx_port.apply_to_config(config)\n    else:\n        opx_port = LFFEMAnalogOutputPort(\n            *self.opx_output,\n            offset=self.opx_output_offset,\n            feedforward_filter=filter_fir_taps,\n            feedback_filter=filter_iir_taps,\n        )\n        opx_port.apply_to_config(config)\n\n    element_config[\"singleInput\"] = {\"port\": opx_port.port_tuple}\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.SingleChannel.set_dc_offset","title":"<code>set_dc_offset(offset)</code>","text":"<p>Set the DC offset of an element's input to the given value. This value will remain the DC offset until changed or until the Quantum Machine is closed.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>Scalar[float]</code> <p>The DC offset to set the input to. This is limited by the OPX output voltage range.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>def set_dc_offset(self, offset: ScalarFloat):\n    \"\"\"Set the DC offset of an element's input to the given value.\n    This value will remain the DC offset until changed or until the Quantum Machine\n    is closed.\n\n    Args:\n        offset (Scalar[float]): The DC offset to set the input to.\n            This is limited by the OPX output voltage range.\n    \"\"\"\n    set_dc_offset(element=self.name, element_input=\"single\", offset=offset)\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.StickyChannelAddon","title":"<code>StickyChannelAddon</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>Addon to make channels sticky.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int</code> <p>The ramp to zero duration, in ns.</p> required <code>enabled</code> <code>bool</code> <p>If False, the sticky parameters are not applied. Default is True.</p> required <code>analog</code> <code>bool</code> <p>If False, the sticky parameters are not applied to analog outputs. Default is True.</p> required <code>digital</code> <code>bool</code> <p>If False, the sticky parameters are not applied to digital outputs. Default is True.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass StickyChannelAddon(QuamComponent):\n    \"\"\"Addon to make channels sticky.\n\n    Args:\n        duration (int): The ramp to zero duration, in ns.\n        enabled (bool, optional): If False, the sticky parameters are not applied.\n            Default is True.\n        analog (bool, optional): If False, the sticky parameters are not applied to\n            analog outputs. Default is True.\n        digital (bool, optional): If False, the sticky parameters are not applied to\n            digital outputs. Default is True.\n    \"\"\"\n\n    duration: int\n    enabled: bool = True\n    analog: bool = True\n    digital: bool = True\n\n    @property\n    def channel(self) -&gt; Optional[\"Channel\"]:\n        \"\"\"If the parent is a channel, returns the parent, otherwise returns None.\"\"\"\n        if isinstance(self.parent, Channel):\n            return self.parent\n        else:\n            return\n\n    @property\n    def config_settings(self):\n        if self.channel is not None:\n            return {\"after\": [self.channel]}\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        if self.channel is None:\n            return\n\n        if not self.enabled:\n            return\n\n        config[\"elements\"][self.channel.name][\"sticky\"] = {\n            \"analog\": self.analog,\n            \"digital\": self.digital,\n            \"duration\": self.duration,\n        }\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.StickyChannelAddon.channel","title":"<code>channel</code>  <code>property</code>","text":"<p>If the parent is a channel, returns the parent, otherwise returns None.</p>"},{"location":"API_references/components/channels/#quam.components.channels.TimeTaggingAddon","title":"<code>TimeTaggingAddon</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>Addon to perform time tagging on a channel.</p> <p>Parameters:</p> Name Type Description Default <code>signal_threshold</code> <code>float</code> <p>The signal threshold in volts. If not specified, the default value is 800 / 4096 \u2248 0.195 V.</p> required <code>signal_polarity</code> <code>Literal['above', 'below']</code> <p>The polarity of the signal threshold. Default is \"below\".</p> required <code>derivative_threshold</code> <code>float</code> <p>The derivative threshold in volts/ns. If not specified, the default value is 300 / 4096 \u2248 0.073 V/ns.</p> required <code>derivative_polarity</code> <code>Literal['above', 'below']</code> <p>The polarity of the derivative threshold. Default is \"below\".</p> required <p>For details see Time Tagging</p> Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass TimeTaggingAddon(QuamComponent):\n    \"\"\"Addon to perform time tagging on a channel.\n\n    Args:\n        signal_threshold (float, optional): The signal threshold in volts.\n            If not specified, the default value is 800 / 4096 \u2248 0.195 V.\n        signal_polarity (Literal[\"above\", \"below\"]): The polarity of the signal\n            threshold. Default is \"below\".\n        derivative_threshold (float, optional): The derivative threshold in volts/ns.\n            If not specified, the default value is 300 / 4096 \u2248 0.073 V/ns.\n        derivative_polarity (Literal[\"above\", \"below\"]): The polarity of the derivative\n            threshold. Default is \"below\".\n\n    For details see [Time Tagging](https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging)\n    \"\"\"\n\n    signal_threshold: float = 800 / 4096\n    signal_polarity: Literal[\"above\", \"below\"] = \"below\"\n    derivative_threshold: float = 300 / 4096\n    derivative_polarity: Literal[\"above\", \"below\"] = \"below\"\n    enabled: bool = True\n\n    @property\n    def channel(self) -&gt; Optional[\"Channel\"]:\n        \"\"\"If the parent is a channel, returns the parent, otherwise returns None.\"\"\"\n        if isinstance(self.parent, Channel):\n            return self.parent\n        else:\n            return\n\n    @property\n    def config_settings(self):\n        if self.channel is not None:\n            return {\"after\": [self.channel]}\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        if self.channel is None:\n            return\n\n        if not self.enabled:\n            return\n\n        if self.signal_threshold is not None and abs(self.signal_threshold) &gt; 1:\n            raise ValueError(\"TimeTaggingAddon.signal_threshold must be a voltage\")\n        # TODO should we also check derivative threshold? What should the max value be?\n\n        ch_cfg = config[\"elements\"][self.channel.name]\n        ch_cfg[\"timeTaggingParameters\"] = {\n            \"signalThreshold\": int(self.signal_threshold * 4096),\n            \"signalPolarity\": self.signal_polarity,\n            \"derivativeThreshold\": int(self.derivative_threshold * 4096),\n            \"derivativePolarity\": self.derivative_polarity,\n        }\n</code></pre>"},{"location":"API_references/components/channels/#quam.components.channels.TimeTaggingAddon.channel","title":"<code>channel</code>  <code>property</code>","text":"<p>If the parent is a channel, returns the parent, otherwise returns None.</p>"},{"location":"API_references/components/channels_API/","title":"QUAM Channels API","text":""},{"location":"API_references/components/channels_API/#quam.components.channels.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>QuamComponent</code>, <code>ABC</code></p> <p>Base QUAM component for a channel, can be output, input or both.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>sticky</code> <code>Sticky</code> <p>Optional sticky parameters for the channel, i.e. defining whether successive pulses are applied w.r.t the previous pulse or w.r.t 0 V. If not specified, this channel is not sticky.</p> required <code>digital_outputs</code> <code>Dict[str, DigitalOutputChannel]</code> <p>A dictionary of digital output channels to be used on this channel. The key is the label of the digital output channel (e.g. \"DO1\") and the value is a DigitalOutputChannel.</p> required <code>intermediate_frequency</code> <code>float</code> <p>The intermediate frequency of the channel in Hz. If not specified, the intermediate frequency is zero.</p> required <code>core</code> <code>str</code> <p>The core to use for the channel, useful when sharing a core between channels. If not specified, the core is assigned automatically.</p> required <code>thread</code> <code>str</code> <p>The channel core, duplicate of 'core' argument, and deprecated from qm.qua &gt;= 1.2.2.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass Channel(QuamComponent, ABC):\n    \"\"\"Base QUAM component for a channel, can be output, input or both.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        sticky (Sticky): Optional sticky parameters for the channel, i.e. defining\n            whether successive pulses are applied w.r.t the previous pulse or w.r.t 0 V.\n            If not specified, this channel is not sticky.\n        digital_outputs (Dict[str, DigitalOutputChannel]): A dictionary of digital\n            output channels to be used on this channel. The key is the label of the\n            digital output channel (e.g. \"DO1\") and the value is a DigitalOutputChannel.\n        intermediate_frequency (float, optional): The intermediate frequency of the\n            channel in Hz. If not specified, the intermediate frequency is zero.\n        core (str, optional): The core to use for the channel, useful when sharing a\n            core between channels. If not specified, the core is assigned automatically.\n        thread (str, optional): The channel core, duplicate of 'core' argument, and\n            deprecated from qm.qua &gt;= 1.2.2.\n    \"\"\"\n\n    operations: Dict[str, Pulse] = field(default_factory=dict)\n\n    id: Union[str, int] = None\n    _default_label: ClassVar[str] = \"ch\"  # Used to determine name from id\n\n    digital_outputs: Dict[str, DigitalOutputChannel] = field(default_factory=dict)\n    sticky: Optional[StickyChannelAddon] = None\n    intermediate_frequency: Optional[float] = None\n\n    thread: Optional[str] = None\n    core: Optional[str] = None\n\n    @property\n    def name(self) -&gt; str:\n        cls_name = self.__class__.__name__\n\n        if self.id is not None:\n            if str_ref.is_reference(self.id):\n                raise AttributeError(\n                    f\"{cls_name}.name cannot be determined. \"\n                    f\"Please either set {cls_name}.id to a string or integer, \"\n                    f\"or {cls_name} should be an attribute of another QUAM component.\"\n                )\n            if isinstance(self.id, str):\n                return self.id\n            else:\n                return f\"{self._default_label}{self.id}\"\n        if self.parent is None:\n            raise AttributeError(\n                f\"{cls_name}.name cannot be determined. \"\n                f\"Please either set {cls_name}.id to a string or integer, \"\n                f\"or {cls_name} should be an attribute of another QUAM component with \"\n                \"a name.\"\n            )\n        if isinstance(self.parent, QuamDict):\n            return self.parent.get_attr_name(self)\n        if not hasattr(self.parent, \"name\"):\n            raise AttributeError(\n                f\"{cls_name}.name cannot be determined. \"\n                f\"Please either set {cls_name}.id to a string or integer, \"\n                f\"or {cls_name} should be an attribute of another QUAM component with \"\n                \"a name.\"\n            )\n        return f\"{self.parent.name}{str_ref.DELIMITER}{self.parent.get_attr_name(self)}\"\n\n    @property\n    def pulse_mapping(self):\n        return {label: pulse.pulse_name for label, pulse in self.operations.items()}\n\n    def play(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        duration: ScalarInt = None,\n        condition: ScalarBool = None,\n        chirp: ChirpType = None,\n        truncate: ScalarInt = None,\n        timestamp_stream: StreamType = None,\n        continue_chirp: bool = False,\n        target: str = \"\",\n        validate: bool = True,\n    ):\n        \"\"\"Play a pulse on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            duration (Scalar[int]): Duration of the pulse in units of the\n                clock cycle (4ns). If not provided, the default pulse duration will be\n                used. It is possible to dynamically change the duration of both constant\n                and arbitrary pulses. Arbitrary pulses can only be stretched, not\n                compressed\n            chirp (Union[(list[int], str), (int, str)]): Allows to perform\n                piecewise linear sweep of the element's intermediate\n                frequency in time. Input should be a tuple, with the 1st\n                element being a list of rates and the second should be a\n                string with the units. The units can be either: 'Hz/nsec',\n                'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n                'KHz/sec', 'Hz/sec', 'mHz/sec'.\n            truncate (Scalar[int]): Allows playing\n                only part of the pulse, truncating the end. If provided,\n                will play only up to the given time in units of the clock\n                cycle (4ns).\n            condition (A logical expression to evaluate.): Will play analog\n                pulse only if the condition's value is true. Any digital\n                pulses associated with the operation will always play.\n            timestamp_stream (Union[str, _ResultSource]): (Supported from\n                QOP 2.2) Adding a `timestamp_stream` argument will save the\n                time at which the operation occurred to a stream. If the\n                `timestamp_stream` is a string ``label``, then the timestamp\n                handle can be retrieved with\n                `qm._results.JobResults.get` with the same ``label``.\n            validate (bool): If True (default), validate that the pulse is registered\n                in Channel.operations\n\n        Note:\n            The `element` argument from `qm.qua.play()`is not needed, as it is\n            automatically set to `self.name`.\n\n        \"\"\"\n        if validate and pulse_name not in self.operations:\n            raise KeyError(\n                f\"Operation '{pulse_name}' not found in channel '{self.name}'\"\n            )\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        # At the moment, self.name is not defined for Channel because it could\n        # be a property or dataclass field in a subclass.\n        # # TODO Find elegant solution for Channel.name.\n        play(\n            pulse=pulse_name_with_amp_scale,\n            element=self.name,\n            duration=duration,\n            condition=condition,\n            chirp=chirp,\n            truncate=truncate,\n            timestamp_stream=timestamp_stream,\n            continue_chirp=continue_chirp,\n            target=target,\n        )\n\n    def wait(self, duration: ScalarInt, *other_elements: Union[str, \"Channel\"]):\n        \"\"\"Wait for the given duration on all provided elements without outputting anything.\n\n        Duration is in units of the clock cycle (4ns)\n\n        Args:\n            duration (Scalar[int]): time to wait in units of the clock cycle\n                (4ns). Range: [4, $2^{31}-1$] in steps of 1.\n            *other_elements (Union[str,sequence of str]): elements to wait on,\n                in addition to this channel\n\n        Warning:\n            In case the value of this is outside the range above, unexpected results may occur.\n\n        Note:\n            The current channel element is always included in the wait operation.\n\n        Note:\n            The purpose of the `wait` operation is to add latency. In most cases, the\n            latency added will be exactly the same as that specified by the QUA variable or\n            the literal used. However, in some cases an additional computational latency may\n            be added. If the actual wait time has significance, such as in characterization\n            experiments, the actual wait time should always be verified with a simulator.\n        \"\"\"\n        other_elements_str = [\n            element if isinstance(element, str) else str(element)\n            for element in other_elements\n        ]\n        wait(duration, self.name, *other_elements_str)\n\n    def align(self, *other_elements):\n        if not other_elements:\n            align()\n        else:\n            other_elements_str = [\n                element if isinstance(element, str) else str(element)\n                for element in other_elements\n            ]\n            align(self.name, *other_elements_str)\n\n    def update_frequency(\n        self,\n        new_frequency: ScalarInt,\n        units: str = \"Hz\",\n        keep_phase: bool = False,\n    ):\n        \"\"\"Dynamically update the frequency of the associated oscillator.\n\n        This changes the frequency from the value defined in the channel.\n\n        The behavior of the phase (continuous vs. coherent) is controlled by the\n        ``keep_phase`` parameter and is discussed in the documentation.\n\n        Args:\n            new_frequency (Scalar[int]): The new frequency value to set\n                in units set by ``units`` parameter. In steps of 1.\n            units (str): units of new frequency. Useful when sub-Hz\n                precision is required. Allowed units are \"Hz\", \"mHz\", \"uHz\",\n                \"nHz\", \"pHz\"\n            keep_phase (bool): Determine whether phase will be continuous\n                through the change (if ``True``) or it will be coherent,\n                only the frequency will change (if ``False``).\n\n        Example:\n            ```python\n            with program() as prog:\n                update_frequency(\"q1\", 4e6) # will set the frequency to 4 MHz\n\n                ### Example for sub-Hz resolution\n                # will set the frequency to 100 Hz (due to casting to int)\n                update_frequency(\"q1\", 100.7)\n\n                # will set the frequency to 100.7 Hz\n                update_frequency(\"q1\", 100700, units='mHz')\n            ```\n        \"\"\"\n        update_frequency(self.name, new_frequency, units, keep_phase)\n\n    def reset_if_phase(self):\n        r\"\"\"\n        Resets the intermediate frequency phase of the oscillator, setting the phase of\n        the next pulse to absolute zero.\n        This sets the phase of the currently playing intermediate frequency\n        to the value it had at the beginning of the program (t=0).\n\n        Note:\n        - The phase will only be set to zero when the next play or align command is\n          executed on the element.\n        - Reset phase will only reset the phase of the intermediate frequency\n          (:math:`\\\\omega_{IF}`) currently in use.\n        \"\"\"\n        reset_if_phase(self.name)\n\n    def frame_rotation(self, angle: ScalarFloat):\n        r\"\"\"Shift the phase of the channel element's oscillator by the given angle.\n\n        This is typically used for virtual z-rotations.\n\n        Note:\n            The fixed point format of QUA variables of type fixed is 4.28, meaning the\n            phase must be between $-8$ and $8-2^{28}$. Otherwise the phase value will be\n            invalid. It is therefore better to use `frame_rotation_2pi()` which avoids\n            this issue.\n\n        Note:\n            The phase is accumulated with a resolution of 16 bit.\n            Therefore, *N* changes to the phase can result in a phase (and amplitude)\n            inaccuracy of about :math:`N \\cdot 2^{-16}`. To null out this accumulated\n            error, it is recommended to use `reset_frame(el)` from time to time.\n\n        Args:\n            angle (Scalar[float]): The angle to add to the current\n                phase (in radians)\n            *elements (str): a single element whose oscillator's phase will\n                be shifted. multiple elements can be given, in which case\n                all of their oscillators' phases will be shifted\n\n        \"\"\"\n        frame_rotation(angle, self.name)\n\n    def frame_rotation_2pi(self, angle: ScalarFloat):\n        r\"\"\"Shift the phase of the oscillator associated with an element by the given\n        angle in units of 2pi radians.\n\n        This is typically used for virtual z-rotations.\n\n        Note:\n            Unlike the case of frame_rotation(), this method performs the 2-pi radian\n            wrap around of the angle automatically.\n\n        Note:\n            The phase is accumulated with a resolution of 16 bit.\n            Therefore, *N* changes to the phase can result in a phase inaccuracy of\n            about :math:`N \\cdot 2^{-16}`. To null out this accumulated error, it is\n            recommended to use `reset_frame(el)` from time to time.\n\n        Args:\n            angle (Scalar[float]): The angle to add to the current\n                phase (in $2\\pi$ radians)\n        \"\"\"\n        frame_rotation_2pi(angle, self.name)\n\n    def _config_add_digital_outputs(self, config: Dict[str, dict]) -&gt; None:\n        \"\"\"Adds the digital outputs to the QUA config.\n\n        config.elements.&lt;element_name&gt;.digitalInputs will be updated with the digital\n        outputs of this channel.\n\n        Note that the digital outputs are added separately to the controller config in\n        `DigitalOutputChannel.apply_to_config`.\n\n        Args:\n            config (dict): The QUA config that's in the process of being generated.\n        \"\"\"\n        if not self.digital_outputs:\n            return\n\n        element_config = config[\"elements\"][self.name]\n        element_config.setdefault(\"digitalInputs\", {})\n\n        for name, digital_output in self.digital_outputs.items():\n            digital_cfg = digital_output.generate_element_config()\n            element_config[\"digitalInputs\"][name] = digital_cfg\n\n    def apply_to_config(self, config: Dict[str, dict]) -&gt; None:\n        \"\"\"Adds this Channel to the QUA configuration.\n\n        config.elements.&lt;element_name&gt; will be created, and the operations are added.\n\n        Args:\n            config (dict): The QUA config that's in the process of being generated.\n\n        Raises:\n            ValueError: If the channel already exists in the config.\n        \"\"\"\n        if self.name in config[\"elements\"]:\n            raise ValueError(\n                f\"Cannot add channel '{self.name}' to the config because it already \"\n                f\"exists. Existing entry: {config['elements'][self.name]}\"\n            )\n        config[\"elements\"][self.name] = {\"operations\": self.pulse_mapping}\n        element_config = config[\"elements\"][self.name]\n\n        if self.intermediate_frequency is not None:\n            element_config[\"intermediate_frequency\"] = self.intermediate_frequency\n\n        try:\n            qua_below_1_2_2 = Version(qm.__version__) &lt;= Version(\"1.2.1\")\n        except ImportError:\n            warnings.warn(\n                \"Unable to to determine qm package version, assuming &lt; 1.2.2. \"\n            )\n            qua_below_1_2_2 = True\n\n        if self.core is not None and self.thread is not None:\n            warnings.warn(\n                \"The 'thread' and 'core' arguments are mutually exclusive. \"\n                \"Using 'core' instead.\"\n            )\n            core = self.core\n        elif self.thread is not None:\n            if not qua_below_1_2_2:\n                warnings.warn(\n                    \"The 'thread' element argument is deprecated from qm.qua &gt;= 1.2.2. \"\n                    \"Use 'core' instead.\"\n                )\n            core = self.thread\n        else:\n            core = self.core\n\n        if core is not None:\n            if qua_below_1_2_2:\n                element_config[\"thread\"] = core\n            else:\n                element_config[\"core\"] = core\n\n        self._config_add_digital_outputs(config)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.Channel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this Channel to the QUA configuration.</p> <p>config.elements. will be created, and the operations are added. <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The QUA config that's in the process of being generated.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the channel already exists in the config.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: Dict[str, dict]) -&gt; None:\n    \"\"\"Adds this Channel to the QUA configuration.\n\n    config.elements.&lt;element_name&gt; will be created, and the operations are added.\n\n    Args:\n        config (dict): The QUA config that's in the process of being generated.\n\n    Raises:\n        ValueError: If the channel already exists in the config.\n    \"\"\"\n    if self.name in config[\"elements\"]:\n        raise ValueError(\n            f\"Cannot add channel '{self.name}' to the config because it already \"\n            f\"exists. Existing entry: {config['elements'][self.name]}\"\n        )\n    config[\"elements\"][self.name] = {\"operations\": self.pulse_mapping}\n    element_config = config[\"elements\"][self.name]\n\n    if self.intermediate_frequency is not None:\n        element_config[\"intermediate_frequency\"] = self.intermediate_frequency\n\n    try:\n        qua_below_1_2_2 = Version(qm.__version__) &lt;= Version(\"1.2.1\")\n    except ImportError:\n        warnings.warn(\n            \"Unable to to determine qm package version, assuming &lt; 1.2.2. \"\n        )\n        qua_below_1_2_2 = True\n\n    if self.core is not None and self.thread is not None:\n        warnings.warn(\n            \"The 'thread' and 'core' arguments are mutually exclusive. \"\n            \"Using 'core' instead.\"\n        )\n        core = self.core\n    elif self.thread is not None:\n        if not qua_below_1_2_2:\n            warnings.warn(\n                \"The 'thread' element argument is deprecated from qm.qua &gt;= 1.2.2. \"\n                \"Use 'core' instead.\"\n            )\n        core = self.thread\n    else:\n        core = self.core\n\n    if core is not None:\n        if qua_below_1_2_2:\n            element_config[\"thread\"] = core\n        else:\n            element_config[\"core\"] = core\n\n    self._config_add_digital_outputs(config)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.Channel.frame_rotation","title":"<code>frame_rotation(angle)</code>","text":"<p>Shift the phase of the channel element's oscillator by the given angle.</p> <p>This is typically used for virtual z-rotations.</p> Note <p>The fixed point format of QUA variables of type fixed is 4.28, meaning the phase must be between $-8$ and $8-2^{28}$. Otherwise the phase value will be invalid. It is therefore better to use <code>frame_rotation_2pi()</code> which avoids this issue.</p> Note <p>The phase is accumulated with a resolution of 16 bit. Therefore, N changes to the phase can result in a phase (and amplitude) inaccuracy of about :math:<code>N \\cdot 2^{-16}</code>. To null out this accumulated error, it is recommended to use <code>reset_frame(el)</code> from time to time.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Scalar[float]</code> <p>The angle to add to the current phase (in radians)</p> required <code>*elements</code> <code>str</code> <p>a single element whose oscillator's phase will be shifted. multiple elements can be given, in which case all of their oscillators' phases will be shifted</p> required Source code in <code>quam/components/channels.py</code> <pre><code>def frame_rotation(self, angle: ScalarFloat):\n    r\"\"\"Shift the phase of the channel element's oscillator by the given angle.\n\n    This is typically used for virtual z-rotations.\n\n    Note:\n        The fixed point format of QUA variables of type fixed is 4.28, meaning the\n        phase must be between $-8$ and $8-2^{28}$. Otherwise the phase value will be\n        invalid. It is therefore better to use `frame_rotation_2pi()` which avoids\n        this issue.\n\n    Note:\n        The phase is accumulated with a resolution of 16 bit.\n        Therefore, *N* changes to the phase can result in a phase (and amplitude)\n        inaccuracy of about :math:`N \\cdot 2^{-16}`. To null out this accumulated\n        error, it is recommended to use `reset_frame(el)` from time to time.\n\n    Args:\n        angle (Scalar[float]): The angle to add to the current\n            phase (in radians)\n        *elements (str): a single element whose oscillator's phase will\n            be shifted. multiple elements can be given, in which case\n            all of their oscillators' phases will be shifted\n\n    \"\"\"\n    frame_rotation(angle, self.name)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.Channel.frame_rotation_2pi","title":"<code>frame_rotation_2pi(angle)</code>","text":"<p>Shift the phase of the oscillator associated with an element by the given angle in units of 2pi radians.</p> <p>This is typically used for virtual z-rotations.</p> Note <p>Unlike the case of frame_rotation(), this method performs the 2-pi radian wrap around of the angle automatically.</p> Note <p>The phase is accumulated with a resolution of 16 bit. Therefore, N changes to the phase can result in a phase inaccuracy of about :math:<code>N \\cdot 2^{-16}</code>. To null out this accumulated error, it is recommended to use <code>reset_frame(el)</code> from time to time.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>Scalar[float]</code> <p>The angle to add to the current phase (in $2\\pi$ radians)</p> required Source code in <code>quam/components/channels.py</code> <pre><code>def frame_rotation_2pi(self, angle: ScalarFloat):\n    r\"\"\"Shift the phase of the oscillator associated with an element by the given\n    angle in units of 2pi radians.\n\n    This is typically used for virtual z-rotations.\n\n    Note:\n        Unlike the case of frame_rotation(), this method performs the 2-pi radian\n        wrap around of the angle automatically.\n\n    Note:\n        The phase is accumulated with a resolution of 16 bit.\n        Therefore, *N* changes to the phase can result in a phase inaccuracy of\n        about :math:`N \\cdot 2^{-16}`. To null out this accumulated error, it is\n        recommended to use `reset_frame(el)` from time to time.\n\n    Args:\n        angle (Scalar[float]): The angle to add to the current\n            phase (in $2\\pi$ radians)\n    \"\"\"\n    frame_rotation_2pi(angle, self.name)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.Channel.play","title":"<code>play(pulse_name, amplitude_scale=None, duration=None, condition=None, chirp=None, truncate=None, timestamp_stream=None, continue_chirp=False, target='', validate=True)</code>","text":"<p>Play a pulse on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>duration</code> <code>Scalar[int]</code> <p>Duration of the pulse in units of the clock cycle (4ns). If not provided, the default pulse duration will be used. It is possible to dynamically change the duration of both constant and arbitrary pulses. Arbitrary pulses can only be stretched, not compressed</p> <code>None</code> <code>chirp</code> <code>Union[(list[int], str), (int, str)]</code> <p>Allows to perform piecewise linear sweep of the element's intermediate frequency in time. Input should be a tuple, with the 1st element being a list of rates and the second should be a string with the units. The units can be either: 'Hz/nsec', 'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec', 'KHz/sec', 'Hz/sec', 'mHz/sec'.</p> <code>None</code> <code>truncate</code> <code>Scalar[int]</code> <p>Allows playing only part of the pulse, truncating the end. If provided, will play only up to the given time in units of the clock cycle (4ns).</p> <code>None</code> <code>condition</code> <code>A logical expression to evaluate.</code> <p>Will play analog pulse only if the condition's value is true. Any digital pulses associated with the operation will always play.</p> <code>None</code> <code>timestamp_stream</code> <code>Union[str, _ResultSource]</code> <p>(Supported from QOP 2.2) Adding a <code>timestamp_stream</code> argument will save the time at which the operation occurred to a stream. If the <code>timestamp_stream</code> is a string <code>label</code>, then the timestamp handle can be retrieved with <code>qm._results.JobResults.get</code> with the same <code>label</code>.</p> <code>None</code> <code>validate</code> <code>bool</code> <p>If True (default), validate that the pulse is registered in Channel.operations</p> <code>True</code> Note <p>The <code>element</code> argument from <code>qm.qua.play()</code>is not needed, as it is automatically set to <code>self.name</code>.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def play(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    duration: ScalarInt = None,\n    condition: ScalarBool = None,\n    chirp: ChirpType = None,\n    truncate: ScalarInt = None,\n    timestamp_stream: StreamType = None,\n    continue_chirp: bool = False,\n    target: str = \"\",\n    validate: bool = True,\n):\n    \"\"\"Play a pulse on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        duration (Scalar[int]): Duration of the pulse in units of the\n            clock cycle (4ns). If not provided, the default pulse duration will be\n            used. It is possible to dynamically change the duration of both constant\n            and arbitrary pulses. Arbitrary pulses can only be stretched, not\n            compressed\n        chirp (Union[(list[int], str), (int, str)]): Allows to perform\n            piecewise linear sweep of the element's intermediate\n            frequency in time. Input should be a tuple, with the 1st\n            element being a list of rates and the second should be a\n            string with the units. The units can be either: 'Hz/nsec',\n            'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n            'KHz/sec', 'Hz/sec', 'mHz/sec'.\n        truncate (Scalar[int]): Allows playing\n            only part of the pulse, truncating the end. If provided,\n            will play only up to the given time in units of the clock\n            cycle (4ns).\n        condition (A logical expression to evaluate.): Will play analog\n            pulse only if the condition's value is true. Any digital\n            pulses associated with the operation will always play.\n        timestamp_stream (Union[str, _ResultSource]): (Supported from\n            QOP 2.2) Adding a `timestamp_stream` argument will save the\n            time at which the operation occurred to a stream. If the\n            `timestamp_stream` is a string ``label``, then the timestamp\n            handle can be retrieved with\n            `qm._results.JobResults.get` with the same ``label``.\n        validate (bool): If True (default), validate that the pulse is registered\n            in Channel.operations\n\n    Note:\n        The `element` argument from `qm.qua.play()`is not needed, as it is\n        automatically set to `self.name`.\n\n    \"\"\"\n    if validate and pulse_name not in self.operations:\n        raise KeyError(\n            f\"Operation '{pulse_name}' not found in channel '{self.name}'\"\n        )\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    # At the moment, self.name is not defined for Channel because it could\n    # be a property or dataclass field in a subclass.\n    # # TODO Find elegant solution for Channel.name.\n    play(\n        pulse=pulse_name_with_amp_scale,\n        element=self.name,\n        duration=duration,\n        condition=condition,\n        chirp=chirp,\n        truncate=truncate,\n        timestamp_stream=timestamp_stream,\n        continue_chirp=continue_chirp,\n        target=target,\n    )\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.Channel.reset_if_phase","title":"<code>reset_if_phase()</code>","text":"<p>Resets the intermediate frequency phase of the oscillator, setting the phase of the next pulse to absolute zero. This sets the phase of the currently playing intermediate frequency to the value it had at the beginning of the program (t=0).</p> <p>Note: - The phase will only be set to zero when the next play or align command is   executed on the element. - Reset phase will only reset the phase of the intermediate frequency   (:math:<code>\\\\omega_{IF}</code>) currently in use.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def reset_if_phase(self):\n    r\"\"\"\n    Resets the intermediate frequency phase of the oscillator, setting the phase of\n    the next pulse to absolute zero.\n    This sets the phase of the currently playing intermediate frequency\n    to the value it had at the beginning of the program (t=0).\n\n    Note:\n    - The phase will only be set to zero when the next play or align command is\n      executed on the element.\n    - Reset phase will only reset the phase of the intermediate frequency\n      (:math:`\\\\omega_{IF}`) currently in use.\n    \"\"\"\n    reset_if_phase(self.name)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.Channel.update_frequency","title":"<code>update_frequency(new_frequency, units='Hz', keep_phase=False)</code>","text":"<p>Dynamically update the frequency of the associated oscillator.</p> <p>This changes the frequency from the value defined in the channel.</p> <p>The behavior of the phase (continuous vs. coherent) is controlled by the <code>keep_phase</code> parameter and is discussed in the documentation.</p> <p>Parameters:</p> Name Type Description Default <code>new_frequency</code> <code>Scalar[int]</code> <p>The new frequency value to set in units set by <code>units</code> parameter. In steps of 1.</p> required <code>units</code> <code>str</code> <p>units of new frequency. Useful when sub-Hz precision is required. Allowed units are \"Hz\", \"mHz\", \"uHz\", \"nHz\", \"pHz\"</p> <code>'Hz'</code> <code>keep_phase</code> <code>bool</code> <p>Determine whether phase will be continuous through the change (if <code>True</code>) or it will be coherent, only the frequency will change (if <code>False</code>).</p> <code>False</code> Example <pre><code>with program() as prog:\n    update_frequency(\"q1\", 4e6) # will set the frequency to 4 MHz\n\n    ### Example for sub-Hz resolution\n    # will set the frequency to 100 Hz (due to casting to int)\n    update_frequency(\"q1\", 100.7)\n\n    # will set the frequency to 100.7 Hz\n    update_frequency(\"q1\", 100700, units='mHz')\n</code></pre> Source code in <code>quam/components/channels.py</code> <pre><code>def update_frequency(\n    self,\n    new_frequency: ScalarInt,\n    units: str = \"Hz\",\n    keep_phase: bool = False,\n):\n    \"\"\"Dynamically update the frequency of the associated oscillator.\n\n    This changes the frequency from the value defined in the channel.\n\n    The behavior of the phase (continuous vs. coherent) is controlled by the\n    ``keep_phase`` parameter and is discussed in the documentation.\n\n    Args:\n        new_frequency (Scalar[int]): The new frequency value to set\n            in units set by ``units`` parameter. In steps of 1.\n        units (str): units of new frequency. Useful when sub-Hz\n            precision is required. Allowed units are \"Hz\", \"mHz\", \"uHz\",\n            \"nHz\", \"pHz\"\n        keep_phase (bool): Determine whether phase will be continuous\n            through the change (if ``True``) or it will be coherent,\n            only the frequency will change (if ``False``).\n\n    Example:\n        ```python\n        with program() as prog:\n            update_frequency(\"q1\", 4e6) # will set the frequency to 4 MHz\n\n            ### Example for sub-Hz resolution\n            # will set the frequency to 100 Hz (due to casting to int)\n            update_frequency(\"q1\", 100.7)\n\n            # will set the frequency to 100.7 Hz\n            update_frequency(\"q1\", 100700, units='mHz')\n        ```\n    \"\"\"\n    update_frequency(self.name, new_frequency, units, keep_phase)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.Channel.wait","title":"<code>wait(duration, *other_elements)</code>","text":"<p>Wait for the given duration on all provided elements without outputting anything.</p> <p>Duration is in units of the clock cycle (4ns)</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>Scalar[int]</code> <p>time to wait in units of the clock cycle (4ns). Range: [4, $2^{31}-1$] in steps of 1.</p> required <code>*other_elements</code> <code>Union[str,sequence of str]</code> <p>elements to wait on, in addition to this channel</p> <code>()</code> Warning <p>In case the value of this is outside the range above, unexpected results may occur.</p> Note <p>The current channel element is always included in the wait operation.</p> Note <p>The purpose of the <code>wait</code> operation is to add latency. In most cases, the latency added will be exactly the same as that specified by the QUA variable or the literal used. However, in some cases an additional computational latency may be added. If the actual wait time has significance, such as in characterization experiments, the actual wait time should always be verified with a simulator.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def wait(self, duration: ScalarInt, *other_elements: Union[str, \"Channel\"]):\n    \"\"\"Wait for the given duration on all provided elements without outputting anything.\n\n    Duration is in units of the clock cycle (4ns)\n\n    Args:\n        duration (Scalar[int]): time to wait in units of the clock cycle\n            (4ns). Range: [4, $2^{31}-1$] in steps of 1.\n        *other_elements (Union[str,sequence of str]): elements to wait on,\n            in addition to this channel\n\n    Warning:\n        In case the value of this is outside the range above, unexpected results may occur.\n\n    Note:\n        The current channel element is always included in the wait operation.\n\n    Note:\n        The purpose of the `wait` operation is to add latency. In most cases, the\n        latency added will be exactly the same as that specified by the QUA variable or\n        the literal used. However, in some cases an additional computational latency may\n        be added. If the actual wait time has significance, such as in characterization\n        experiments, the actual wait time should always be verified with a simulator.\n    \"\"\"\n    other_elements_str = [\n        element if isinstance(element, str) else str(element)\n        for element in other_elements\n    ]\n    wait(duration, self.name, *other_elements_str)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.DigitalOutputChannel","title":"<code>DigitalOutputChannel</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for a digital output channel (signal going out of the OPX)</p> <p>Should be added to <code>Channel.digital_outputs</code> so that it's also added to the respective element in the QUA config.</p> <p>Parameters:</p> Name Type Description Default <code>opx_output</code> <code>DigitalOutputPort</code> <p>Channel output port from the OPX perspective, E.g. FEMDigitalOutputPort(\"con1\", 1, 2)</p> required <code>delay</code> <code>int</code> <p>Delay in nanoseconds. An intrinsic negative delay of 136 ns exists by default.</p> required <code>buffer</code> <code>int</code> <p>Digital pulses played to this element will be convolved with a digital pulse of value 1 with this length [ns].</p> required <code>shareable</code> <code>(bool, deprecated)</code> <p>If True, the digital output can be shared with other QM instances. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusDigitalOutputPort(shareable=...)</code> instead. See Port documentation for details.</p> required <code>inverted</code> <code>(bool, deprecated)</code> <p>If True, the digital output is inverted. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusDigitalOutputPort(inverted=...)</code> instead. See Port documentation for details.</p> required <p>.</p> Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass DigitalOutputChannel(QuamComponent):\n    \"\"\"QUAM component for a digital output channel (signal going out of the OPX)\n\n    Should be added to `Channel.digital_outputs` so that it's also added to the\n    respective element in the QUA config.\n\n    Args:\n        opx_output (DigitalOutputPort): Channel output port from the OPX perspective,\n            E.g. FEMDigitalOutputPort(\"con1\", 1, 2)\n        delay (int, optional): Delay in nanoseconds. An intrinsic negative delay of\n            136 ns exists by default.\n        buffer (int, optional): Digital pulses played to this element will be convolved\n            with a digital pulse of value 1 with this length [ns].\n        shareable (bool, deprecated): If True, the digital output can be shared with other\n            QM instances.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusDigitalOutputPort(shareable=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        inverted (bool, deprecated): If True, the digital output is inverted.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusDigitalOutputPort(inverted=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n    .\"\"\"\n\n    opx_output: Union[Tuple[str, int], Tuple[str, int, int], DigitalOutputPort]\n    delay: int = None\n    buffer: int = None\n\n    shareable: bool = None\n    inverted: bool = None\n\n    def generate_element_config(self) -&gt; Dict[str, int]:\n        \"\"\"Generates the config entry for a digital channel in the QUA config.\n\n        This config entry goes into:\n        config.elements.&lt;element_name&gt;.digitalInputs.&lt;opx_output[1]&gt;\n\n        Returns:\n            Dict[str, int]: The digital channel config entry.\n                Contains \"port\", and optionally \"delay\", \"buffer\" if specified\n        \"\"\"\n        if isinstance(self.opx_output, DigitalOutputPort):\n            opx_output = self.opx_output.port_tuple\n        else:\n            opx_output = tuple(self.opx_output)\n\n        digital_cfg: Dict[str, Any] = {\"port\": opx_output}\n        if self.delay is not None:\n            digital_cfg[\"delay\"] = self.delay\n        if self.buffer is not None:\n            digital_cfg[\"buffer\"] = self.buffer\n        return digital_cfg\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Adds this DigitalOutputChannel to the QUA configuration.\n\n        config.controllers.&lt;controller_name&gt;.digital_outputs.&lt;port&gt; will be updated\n        with the shareable and inverted settings of this channel if specified.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        if isinstance(self.opx_output, DigitalOutputPort):\n            if self.shareable is not None:\n                msg = _create_port_property_deprecation_message(\n                    \"DigitalOutputChannel\",\n                    \"shareable\",\n                    self.shareable,\n                    self.opx_output,\n                )\n                warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            if self.inverted is not None:\n                msg = _create_port_property_deprecation_message(\n                    \"DigitalOutputChannel\",\n                    \"inverted\",\n                    self.inverted,\n                    self.opx_output,\n                )\n                warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            return\n\n        # Warn about deprecated port properties when using tuple notation\n        if self.shareable is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"shareable\",\n                self.shareable,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if self.inverted is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"inverted\",\n                self.inverted,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        shareable = self.shareable if self.shareable is not None else False\n        inverted = self.inverted if self.inverted is not None else False\n        if len(self.opx_output) == 2:\n            digital_output_port = OPXPlusDigitalOutputPort(\n                *self.opx_output, shareable=shareable, inverted=inverted\n            )\n        else:\n            digital_output_port = FEMDigitalOutputPort(\n                *self.opx_output, shareable=shareable, inverted=inverted\n            )\n        digital_output_port.apply_to_config(config)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.DigitalOutputChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this DigitalOutputChannel to the QUA configuration.</p> <p>config.controllers..digital_outputs. will be updated with the shareable and inverted settings of this channel if specified. <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Adds this DigitalOutputChannel to the QUA configuration.\n\n    config.controllers.&lt;controller_name&gt;.digital_outputs.&lt;port&gt; will be updated\n    with the shareable and inverted settings of this channel if specified.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    if isinstance(self.opx_output, DigitalOutputPort):\n        if self.shareable is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"shareable\",\n                self.shareable,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        if self.inverted is not None:\n            msg = _create_port_property_deprecation_message(\n                \"DigitalOutputChannel\",\n                \"inverted\",\n                self.inverted,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        return\n\n    # Warn about deprecated port properties when using tuple notation\n    if self.shareable is not None:\n        msg = _create_port_property_deprecation_message(\n            \"DigitalOutputChannel\",\n            \"shareable\",\n            self.shareable,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if self.inverted is not None:\n        msg = _create_port_property_deprecation_message(\n            \"DigitalOutputChannel\",\n            \"inverted\",\n            self.inverted,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    shareable = self.shareable if self.shareable is not None else False\n    inverted = self.inverted if self.inverted is not None else False\n    if len(self.opx_output) == 2:\n        digital_output_port = OPXPlusDigitalOutputPort(\n            *self.opx_output, shareable=shareable, inverted=inverted\n        )\n    else:\n        digital_output_port = FEMDigitalOutputPort(\n            *self.opx_output, shareable=shareable, inverted=inverted\n        )\n    digital_output_port.apply_to_config(config)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.DigitalOutputChannel.generate_element_config","title":"<code>generate_element_config()</code>","text":"<p>Generates the config entry for a digital channel in the QUA config.</p> <p>This config entry goes into: config.elements..digitalInputs. <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: The digital channel config entry. Contains \"port\", and optionally \"delay\", \"buffer\" if specified</p> Source code in <code>quam/components/channels.py</code> <pre><code>def generate_element_config(self) -&gt; Dict[str, int]:\n    \"\"\"Generates the config entry for a digital channel in the QUA config.\n\n    This config entry goes into:\n    config.elements.&lt;element_name&gt;.digitalInputs.&lt;opx_output[1]&gt;\n\n    Returns:\n        Dict[str, int]: The digital channel config entry.\n            Contains \"port\", and optionally \"delay\", \"buffer\" if specified\n    \"\"\"\n    if isinstance(self.opx_output, DigitalOutputPort):\n        opx_output = self.opx_output.port_tuple\n    else:\n        opx_output = tuple(self.opx_output)\n\n    digital_cfg: Dict[str, Any] = {\"port\": opx_output}\n    if self.delay is not None:\n        digital_cfg[\"delay\"] = self.delay\n    if self.buffer is not None:\n        digital_cfg[\"buffer\"] = self.buffer\n    return digital_cfg\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.IQChannel","title":"<code>IQChannel</code>","text":"<p>               Bases: <code>_OutComplexChannel</code></p> <p>QUAM component for an IQ output channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output_I</code> <code>LF_output_port_types</code> <p>Channel I output port from the OPX perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_Q</code> <code>LF_output_port_types</code> <p>Channel Q output port from the OPX perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset_I</code> <code>(float, deprecated)</code> <p>The offset of the I channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(offset=...)</code> on the I port instead. See Port documentation for details.</p> required <code>opx_output_offset_Q</code> <code>(float, deprecated)</code> <p>The offset of the Q channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(offset=...)</code> on the Q port instead. See Port documentation for details.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of the mixer. Default is 0.0</p> required <code>LO_frequency</code> <code>float</code> <p>Local oscillator frequency. Default is the LO frequency of the frequency converter up component.</p> required <code>RF_frequency</code> <code>float</code> <p>RF frequency of the mixer. By default, the RF frequency is inferred by adding the LO frequency and the intermediate frequency.</p> required <code>frequency_converter_up</code> <code>FrequencyConverter</code> <p>Frequency converter QUAM component for the IQ output.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass IQChannel(_OutComplexChannel):\n    \"\"\"QUAM component for an IQ output channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output_I (LF_output_port_types): Channel I output port from the OPX\n            perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_Q (LF_output_port_types): Channel Q output port from the OPX\n            perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset_I (float, deprecated): The offset of the I channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(offset=...)` on the I port instead.\n            See [Port documentation](channel-ports.md) for details.\n        opx_output_offset_Q (float, deprecated): The offset of the Q channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(offset=...)` on the Q port instead.\n            See [Port documentation](channel-ports.md) for details.\n        intermediate_frequency (float): Intermediate frequency of the mixer.\n            Default is 0.0\n        LO_frequency (float): Local oscillator frequency. Default is the LO frequency\n            of the frequency converter up component.\n        RF_frequency (float): RF frequency of the mixer. By default, the RF frequency\n            is inferred by adding the LO frequency and the intermediate frequency.\n        frequency_converter_up (FrequencyConverter): Frequency converter QUAM component\n            for the IQ output.\n    \"\"\"\n\n    opx_output_I: LF_output_port_types\n    opx_output_Q: LF_output_port_types\n\n    opx_output_offset_I: float = None\n    opx_output_offset_Q: float = None\n\n    frequency_converter_up: BaseFrequencyConverter\n\n    LO_frequency: float = \"#./frequency_converter_up/LO_frequency\"\n    RF_frequency: float = \"#./inferred_RF_frequency\"\n\n    _default_label: ClassVar[str] = \"IQ\"\n\n    @property\n    def local_oscillator(self) -&gt; Optional[LocalOscillator]:\n        return getattr(self.frequency_converter_up, \"local_oscillator\", None)\n\n    @property\n    def mixer(self) -&gt; Optional[Mixer]:\n        return getattr(self.frequency_converter_up, \"mixer\", None)\n\n    @property\n    def rf_frequency(self):\n        warnings.warn(\n            \"rf_frequency is deprecated, use RF_frequency instead\", DeprecationWarning\n        )\n        return self.frequency_converter_up.LO_frequency + self.intermediate_frequency\n\n    def set_dc_offset(self, offset: ScalarFloat, element_input: Literal[\"I\", \"Q\"]):\n        \"\"\"Set the DC offset of an element's input to the given value.\n        This value will remain the DC offset until changed or until the Quantum Machine\n        is closed.\n\n        Args:\n            offset (Scalar[float]): The DC offset to set the input to.\n                This is limited by the OPX output voltage range.\n            element_input (Literal[\"I\", \"Q\"]): The element input to set the offset for.\n\n        Raises:\n            ValueError: If element_input is not \"I\" or \"Q\"\n        \"\"\"\n        if element_input not in [\"I\", \"Q\"]:\n            raise ValueError(\n                f\"element_input should be either 'I' or 'Q', got {element_input}\"\n            )\n        set_dc_offset(element=self.name, element_input=element_input, offset=offset)\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this IQChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        # Add pulses &amp; waveforms\n        super().apply_to_config(config)\n\n        if str_ref.is_reference(self.name):\n            raise AttributeError(\n                f\"Channel {self.get_reference()} cannot be added to the config because\"\n                \" it doesn't have a name. Either set channel.id to a string or\"\n                \" integer, or channel should be an attribute of another QUAM component\"\n                \" with a name.\"\n            )\n\n        element_config = config[\"elements\"][self.name]\n\n        # Check for deprecated port properties on channel\n        if self.opx_output_offset_I is not None:\n            msg = _create_port_property_deprecation_message(\n                \"IQChannel\",\n                \"opx_output_offset_I\",\n                self.opx_output_offset_I,\n                self.opx_output_I,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if self.opx_output_offset_Q is not None:\n            msg = _create_port_property_deprecation_message(\n                \"IQChannel\",\n                \"opx_output_offset_Q\",\n                self.opx_output_offset_Q,\n                self.opx_output_Q,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        from quam.components.octave import OctaveUpConverter\n\n        if isinstance(self.frequency_converter_up, OctaveUpConverter):\n            octave = self.frequency_converter_up.octave\n            if octave is None:\n                raise ValueError(\n                    f\"Error generating config: channel {self.name} has an \"\n                    f\"OctaveUpConverter (id={self.frequency_converter_up.id}) without \"\n                    \"an attached Octave\"\n                )\n            element_config[\"RF_inputs\"] = {\n                \"port\": (octave.name, self.frequency_converter_up.id)\n            }\n        elif str_ref.is_reference(self.frequency_converter_up):\n            raise ValueError(\n                f\"Error generating config: channel {self.name} could not determine \"\n                f'\"frequency_converter_up\", it seems to point to a non-existent '\n                f\"reference: {self.frequency_converter_up}\"\n            )\n        else:\n            element_config[\"mixInputs\"] = {}  # To be filled in next section\n            if self.mixer is not None:\n                element_config[\"mixInputs\"][\"mixer\"] = self.mixer.name\n            if self.local_oscillator is not None:\n                element_config[\"mixInputs\"][\"lo_frequency\"] = (\n                    self.local_oscillator.frequency\n                )\n\n        opx_outputs = [self.opx_output_I, self.opx_output_Q]\n        offsets = [self.opx_output_offset_I, self.opx_output_offset_Q]\n        for I_or_Q, opx_output, offset in zip(\"IQ\", opx_outputs, offsets):\n            if isinstance(opx_output, LFAnalogOutputPort):\n                opx_port = opx_output\n            elif len(opx_output) == 2:\n                opx_port = OPXPlusAnalogOutputPort(*opx_output, offset=offset)\n                opx_port.apply_to_config(config)\n            else:\n                opx_port = LFFEMAnalogOutputPort(*opx_output, offset=offset)\n                opx_port.apply_to_config(config)\n\n            if \"mixInputs\" in element_config:\n                element_config[\"mixInputs\"][I_or_Q] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.IQChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this IQChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this IQChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    # Add pulses &amp; waveforms\n    super().apply_to_config(config)\n\n    if str_ref.is_reference(self.name):\n        raise AttributeError(\n            f\"Channel {self.get_reference()} cannot be added to the config because\"\n            \" it doesn't have a name. Either set channel.id to a string or\"\n            \" integer, or channel should be an attribute of another QUAM component\"\n            \" with a name.\"\n        )\n\n    element_config = config[\"elements\"][self.name]\n\n    # Check for deprecated port properties on channel\n    if self.opx_output_offset_I is not None:\n        msg = _create_port_property_deprecation_message(\n            \"IQChannel\",\n            \"opx_output_offset_I\",\n            self.opx_output_offset_I,\n            self.opx_output_I,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if self.opx_output_offset_Q is not None:\n        msg = _create_port_property_deprecation_message(\n            \"IQChannel\",\n            \"opx_output_offset_Q\",\n            self.opx_output_offset_Q,\n            self.opx_output_Q,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    from quam.components.octave import OctaveUpConverter\n\n    if isinstance(self.frequency_converter_up, OctaveUpConverter):\n        octave = self.frequency_converter_up.octave\n        if octave is None:\n            raise ValueError(\n                f\"Error generating config: channel {self.name} has an \"\n                f\"OctaveUpConverter (id={self.frequency_converter_up.id}) without \"\n                \"an attached Octave\"\n            )\n        element_config[\"RF_inputs\"] = {\n            \"port\": (octave.name, self.frequency_converter_up.id)\n        }\n    elif str_ref.is_reference(self.frequency_converter_up):\n        raise ValueError(\n            f\"Error generating config: channel {self.name} could not determine \"\n            f'\"frequency_converter_up\", it seems to point to a non-existent '\n            f\"reference: {self.frequency_converter_up}\"\n        )\n    else:\n        element_config[\"mixInputs\"] = {}  # To be filled in next section\n        if self.mixer is not None:\n            element_config[\"mixInputs\"][\"mixer\"] = self.mixer.name\n        if self.local_oscillator is not None:\n            element_config[\"mixInputs\"][\"lo_frequency\"] = (\n                self.local_oscillator.frequency\n            )\n\n    opx_outputs = [self.opx_output_I, self.opx_output_Q]\n    offsets = [self.opx_output_offset_I, self.opx_output_offset_Q]\n    for I_or_Q, opx_output, offset in zip(\"IQ\", opx_outputs, offsets):\n        if isinstance(opx_output, LFAnalogOutputPort):\n            opx_port = opx_output\n        elif len(opx_output) == 2:\n            opx_port = OPXPlusAnalogOutputPort(*opx_output, offset=offset)\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogOutputPort(*opx_output, offset=offset)\n            opx_port.apply_to_config(config)\n\n        if \"mixInputs\" in element_config:\n            element_config[\"mixInputs\"][I_or_Q] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.IQChannel.set_dc_offset","title":"<code>set_dc_offset(offset, element_input)</code>","text":"<p>Set the DC offset of an element's input to the given value. This value will remain the DC offset until changed or until the Quantum Machine is closed.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>Scalar[float]</code> <p>The DC offset to set the input to. This is limited by the OPX output voltage range.</p> required <code>element_input</code> <code>Literal['I', 'Q']</code> <p>The element input to set the offset for.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If element_input is not \"I\" or \"Q\"</p> Source code in <code>quam/components/channels.py</code> <pre><code>def set_dc_offset(self, offset: ScalarFloat, element_input: Literal[\"I\", \"Q\"]):\n    \"\"\"Set the DC offset of an element's input to the given value.\n    This value will remain the DC offset until changed or until the Quantum Machine\n    is closed.\n\n    Args:\n        offset (Scalar[float]): The DC offset to set the input to.\n            This is limited by the OPX output voltage range.\n        element_input (Literal[\"I\", \"Q\"]): The element input to set the offset for.\n\n    Raises:\n        ValueError: If element_input is not \"I\" or \"Q\"\n    \"\"\"\n    if element_input not in [\"I\", \"Q\"]:\n        raise ValueError(\n            f\"element_input should be either 'I' or 'Q', got {element_input}\"\n        )\n    set_dc_offset(element=self.name, element_input=element_input, offset=offset)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InIQChannel","title":"<code>InIQChannel</code>","text":"<p>               Bases: <code>_InComplexChannel</code></p> <p>QUAM component for an IQ input channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_input_I</code> <code>LF_input_port_types</code> <p>Channel I input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_Q</code> <code>LF_input_port_types</code> <p>Channel Q input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset_I</code> <code>(float, deprecated)</code> <p>The offset of the I channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogInputPort(offset=...)</code> on the I port instead. See Port documentation for details.</p> required <code>opx_input_offset_Q</code> <code>(float, deprecated)</code> <p>The offset of the Q channel. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogInputPort(offset=...)</code> on the Q port instead. See Port documentation for details.</p> required <code>frequency_converter_down</code> <code>Optional[FrequencyConverter]</code> <p>Frequency converter QUAM component for the IQ input port. Only needed for the old Octave.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required <code>input_gain</code> <code>float</code> <p>The gain of the input channel. Default is None.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InIQChannel(_InComplexChannel):\n    \"\"\"QUAM component for an IQ input channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_input_I (LF_input_port_types): Channel I input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_Q (LF_input_port_types): Channel Q input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset_I (float, deprecated): The offset of the I channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogInputPort(offset=...)` on the I port instead.\n            See [Port documentation](channel-ports.md) for details.\n        opx_input_offset_Q (float, deprecated): The offset of the Q channel.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogInputPort(offset=...)` on the Q port instead.\n            See [Port documentation](channel-ports.md) for details.\n        frequency_converter_down (Optional[FrequencyConverter]): Frequency converter\n            QUAM component for the IQ input port. Only needed for the old Octave.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n        input_gain (float): The gain of the input channel. Default is None.\n    \"\"\"\n\n    opx_input_I: LF_input_port_types\n    opx_input_Q: LF_input_port_types\n\n    time_of_flight: int = 140\n    smearing: int = 0\n\n    opx_input_offset_I: float = None\n    opx_input_offset_Q: float = None\n\n    input_gain: Optional[int] = None\n\n    frequency_converter_down: BaseFrequencyConverter = None\n\n    _default_label: ClassVar[str] = \"IQ\"\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this InOutIQChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        super().apply_to_config(config)\n\n        # Note outputs instead of inputs because it's w.r.t. the QPU\n        element_config = config[\"elements\"][self.name]\n        element_config[\"smearing\"] = self.smearing\n        element_config[\"time_of_flight\"] = self.time_of_flight\n\n        from quam.components.octave import OctaveDownConverter\n\n        if isinstance(self.frequency_converter_down, OctaveDownConverter):\n            octave = self.frequency_converter_down.octave\n            if octave is None:\n                raise ValueError(\n                    f\"Error generating config: channel {self.name} has an \"\n                    f\"OctaveDownConverter (id={self.frequency_converter_down.id}) \"\n                    \"without an attached Octave\"\n                )\n            element_config[\"RF_outputs\"] = {\n                \"port\": (octave.name, self.frequency_converter_down.id)\n            }\n        elif str_ref.is_reference(self.frequency_converter_down):\n            raise ValueError(\n                f\"Error generating config: channel {self.name} could not determine \"\n                f'\"frequency_converter_down\", it seems to point to a non-existent '\n                f\"reference: {self.frequency_converter_down}\"\n            )\n        else:\n            # To be filled in next section\n            element_config[\"outputs\"] = {}\n\n        # Check for deprecated port properties on channel\n        if self.opx_input_offset_I is not None:\n            msg = _create_port_property_deprecation_message(\n                \"InIQChannel\",\n                \"opx_input_offset_I\",\n                self.opx_input_offset_I,\n                self.opx_input_I,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if self.opx_input_offset_Q is not None:\n            msg = _create_port_property_deprecation_message(\n                \"InIQChannel\",\n                \"opx_input_offset_Q\",\n                self.opx_input_offset_Q,\n                self.opx_input_Q,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        opx_inputs = [self.opx_input_I, self.opx_input_Q]\n        offsets = [self.opx_input_offset_I, self.opx_input_offset_Q]\n        input_gain = int(self.input_gain if self.input_gain is not None else 0)\n        for k, (opx_input, offset) in enumerate(zip(opx_inputs, offsets), start=1):\n            if isinstance(opx_input, LFAnalogInputPort):\n                opx_port = opx_input\n            elif len(opx_input) == 2:\n                opx_port = OPXPlusAnalogInputPort(\n                    *opx_input, offset=offset, gain_db=input_gain\n                )\n                opx_port.apply_to_config(config)\n            else:\n                opx_port = LFFEMAnalogInputPort(\n                    *opx_input, offset=offset, gain_db=input_gain\n                )\n                opx_port.apply_to_config(config)\n            if not isinstance(self.frequency_converter_down, OctaveDownConverter):\n                element_config[\"outputs\"][f\"out{k}\"] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InIQChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this InOutIQChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this InOutIQChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    super().apply_to_config(config)\n\n    # Note outputs instead of inputs because it's w.r.t. the QPU\n    element_config = config[\"elements\"][self.name]\n    element_config[\"smearing\"] = self.smearing\n    element_config[\"time_of_flight\"] = self.time_of_flight\n\n    from quam.components.octave import OctaveDownConverter\n\n    if isinstance(self.frequency_converter_down, OctaveDownConverter):\n        octave = self.frequency_converter_down.octave\n        if octave is None:\n            raise ValueError(\n                f\"Error generating config: channel {self.name} has an \"\n                f\"OctaveDownConverter (id={self.frequency_converter_down.id}) \"\n                \"without an attached Octave\"\n            )\n        element_config[\"RF_outputs\"] = {\n            \"port\": (octave.name, self.frequency_converter_down.id)\n        }\n    elif str_ref.is_reference(self.frequency_converter_down):\n        raise ValueError(\n            f\"Error generating config: channel {self.name} could not determine \"\n            f'\"frequency_converter_down\", it seems to point to a non-existent '\n            f\"reference: {self.frequency_converter_down}\"\n        )\n    else:\n        # To be filled in next section\n        element_config[\"outputs\"] = {}\n\n    # Check for deprecated port properties on channel\n    if self.opx_input_offset_I is not None:\n        msg = _create_port_property_deprecation_message(\n            \"InIQChannel\",\n            \"opx_input_offset_I\",\n            self.opx_input_offset_I,\n            self.opx_input_I,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if self.opx_input_offset_Q is not None:\n        msg = _create_port_property_deprecation_message(\n            \"InIQChannel\",\n            \"opx_input_offset_Q\",\n            self.opx_input_offset_Q,\n            self.opx_input_Q,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    opx_inputs = [self.opx_input_I, self.opx_input_Q]\n    offsets = [self.opx_input_offset_I, self.opx_input_offset_Q]\n    input_gain = int(self.input_gain if self.input_gain is not None else 0)\n    for k, (opx_input, offset) in enumerate(zip(opx_inputs, offsets), start=1):\n        if isinstance(opx_input, LFAnalogInputPort):\n            opx_port = opx_input\n        elif len(opx_input) == 2:\n            opx_port = OPXPlusAnalogInputPort(\n                *opx_input, offset=offset, gain_db=input_gain\n            )\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogInputPort(\n                *opx_input, offset=offset, gain_db=input_gain\n            )\n            opx_port.apply_to_config(config)\n        if not isinstance(self.frequency_converter_down, OctaveDownConverter):\n            element_config[\"outputs\"][f\"out{k}\"] = opx_port.port_tuple\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InIQOutSingleChannel","title":"<code>InIQOutSingleChannel</code>","text":"<p>               Bases: <code>SingleChannel</code>, <code>InIQChannel</code></p> <p>QUAM component for an IQ input channel with a single output.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>LF_output_port_types</code> <p>Channel output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_offset</code> <code>float</code> <p>DC offset for the output port.</p> required <code>opx_input_I</code> <code>LF_input_port_types</code> <p>Channel I input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_Q</code> <code>LF_input_port_types</code> <p>Channel Q input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_input_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>filter_fir_taps</code> <code>List[float]</code> <p>FIR filter taps for the output port.</p> required <code>filter_iir_taps</code> <code>List[float]</code> <p>IIR filter taps for the output port.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InIQOutSingleChannel(SingleChannel, InIQChannel):\n    \"\"\"QUAM component for an IQ input channel with a single output.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (LF_output_port_types): Channel output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_offset (float): DC offset for the output port.\n        opx_input_I (LF_input_port_types): Channel I input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_Q (LF_input_port_types): Channel Q input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset_I (float): The offset of the I channel. Default is 0.\n        opx_input_offset_Q (float): The offset of the Q channel. Default is 0.\n        filter_fir_taps (List[float]): FIR filter taps for the output port.\n        filter_iir_taps (List[float]): IIR filter taps for the output port.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InMWChannel","title":"<code>InMWChannel</code>","text":"<p>               Bases: <code>_InComplexChannel</code></p> <p>QUAM component for a MW FEM input channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_input</code> <code>MWFEMAnalogInputPort</code> <p>Channel input port from the OPX perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds. Default is 280, which is a reasonable default for the MW FEM.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing. Default is 0.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InMWChannel(_InComplexChannel):\n    \"\"\"QUAM component for a MW FEM input channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_input (MWFEMAnalogInputPort): Channel input port from the OPX\n            perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds. Default is 280,\n            which is a reasonable default for the MW FEM.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing. Default is 0.\n    \"\"\"\n\n    opx_input: MWFEMAnalogInputPort\n\n    time_of_flight: int = 280\n    smearing: int = 0\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        super().apply_to_config(config)\n\n        element_config = config[\"elements\"][self.name]\n        element_config[\"MWOutput\"] = {\"port\": self.opx_input.port_tuple}\n        element_config[\"smearing\"] = self.smearing\n        element_config[\"time_of_flight\"] = self.time_of_flight\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InOutIQChannel","title":"<code>InOutIQChannel</code>","text":"<p>               Bases: <code>IQChannel</code>, <code>InIQChannel</code></p> <p>QUAM component for an IQ channel with both input and output.</p> <p>An example of such a channel is a readout resonator, where you may want to apply a readout tone and then measure the response.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output_I</code> <code>LF_output_port_types</code> <p>Channel I output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_Q</code> <code>LF_output_port_types</code> <p>Channel Q output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_output_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>opx_input_I</code> <code>LF_input_port_types</code> <p>Channel I input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_Q</code> <code>LF_input_port_types</code> <p>Channel Q input port from the OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_input_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of the mixer. Default is 0.0</p> required <code>LO_frequency</code> <code>float</code> <p>Local oscillator frequency. Default is the LO frequency of the frequency converter up component.</p> required <code>RF_frequency</code> <code>float</code> <p>RF frequency of the mixer. By default, the RF frequency is inferred by adding the LO frequency and the intermediate frequency.</p> required <code>frequency_converter_up</code> <code>FrequencyConverter</code> <p>Frequency converter QUAM component for the IQ output.</p> required <code>frequency_converter_down</code> <code>Optional[FrequencyConverter]</code> <p>Frequency converter QUAM component for the IQ input port. Only needed for the old Octave.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InOutIQChannel(IQChannel, InIQChannel):\n    \"\"\"QUAM component for an IQ channel with both input and output.\n\n    An example of such a channel is a readout resonator, where you may want to\n    apply a readout tone and then measure the response.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output_I (LF_output_port_types): Channel I output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_Q (LF_output_port_types): Channel Q output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset_I (float): The offset of the I channel. Default is 0.\n        opx_output_offset_Q (float): The offset of the Q channel. Default is 0.\n        opx_input_I (LF_input_port_types): Channel I input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_Q (LF_input_port_types): Channel Q input port from the OPX\n            perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset_I (float): The offset of the I channel. Default is 0.\n        opx_input_offset_Q (float): The offset of the Q channel. Default is 0.\n        intermediate_frequency (float): Intermediate frequency of the mixer.\n            Default is 0.0\n        LO_frequency (float): Local oscillator frequency. Default is the LO frequency\n            of the frequency converter up component.\n        RF_frequency (float): RF frequency of the mixer. By default, the RF frequency\n            is inferred by adding the LO frequency and the intermediate frequency.\n        frequency_converter_up (FrequencyConverter): Frequency converter QUAM component\n            for the IQ output.\n        frequency_converter_down (Optional[FrequencyConverter]): Frequency converter\n            QUAM component for the IQ input port. Only needed for the old Octave.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InOutMWChannel","title":"<code>InOutMWChannel</code>","text":"<p>               Bases: <code>MWChannel</code>, <code>InMWChannel</code></p> <p>QUAM component for a MW FEM input channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>MWFEMAnalogOutputPort</code> <p>Channel output port from the OPX perspective, e.g. MWFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_input</code> <code>MWFEMAnalogInputPort</code> <p>Channel input port from the OPX perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>upconverter</code> <code>int</code> <p>The upconverter to use. Default is 1.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InOutMWChannel(MWChannel, InMWChannel):\n    \"\"\"QUAM component for a MW FEM input channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (MWFEMAnalogOutputPort): Channel output port from the OPX\n            perspective, e.g. MWFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_input (MWFEMAnalogInputPort): Channel input port from the OPX\n            perspective, e.g. MWFEMAnalogInputPort(\"con1\", 1, 1)\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        upconverter (int): The upconverter to use. Default is 1.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InOutSingleChannel","title":"<code>InOutSingleChannel</code>","text":"<p>               Bases: <code>SingleChannel</code>, <code>InSingleChannel</code></p> <p>QUAM component for a single (not IQ) input + output channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>LF_output_port_types</code> <p>Channel output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset</code> <code>float</code> <p>DC offset for the output port.</p> required <code>opx_input</code> <code>LF_input_port_types</code> <p>Channel input port from OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset</code> <code>float</code> <p>DC offset for the input port.</p> required <code>filter_fir_taps</code> <code>List[float]</code> <p>FIR filter taps for the output port.</p> required <code>filter_iir_taps</code> <code>List[float]</code> <p>IIR filter taps for the output port.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InOutSingleChannel(SingleChannel, InSingleChannel):\n    \"\"\"QUAM component for a single (not IQ) input + output channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (LF_output_port_types): Channel output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset (float): DC offset for the output port.\n        opx_input (LF_input_port_types): Channel input port from OPX perspective,\n            e.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset (float): DC offset for the input port.\n        filter_fir_taps (List[float]): FIR filter taps for the output port.\n        filter_iir_taps (List[float]): IIR filter taps for the output port.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InSingleChannel","title":"<code>InSingleChannel</code>","text":"<p>               Bases: <code>Channel</code></p> <p>QUAM component for a single (not IQ) input channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_input</code> <code>LF_input_port_types</code> <p>Channel input port from OPX perspective, E.g. LFFEMAnalogInputPort(\"con1\", 1, 2)</p> required <code>opx_input_offset</code> <code>(float, deprecated)</code> <p>DC offset for the input port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogInputPort(offset=...)</code> instead. See Port documentation for details.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX input, default is None.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InSingleChannel(Channel):\n    \"\"\"QUAM component for a single (not IQ) input channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_input (LF_input_port_types): Channel input port from OPX perspective,\n            E.g. LFFEMAnalogInputPort(\"con1\", 1, 2)\n        opx_input_offset (float, deprecated): DC offset for the input port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogInputPort(offset=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        intermediate_frequency (float): Intermediate frequency of OPX input,\n            default is None.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    opx_input: LF_input_port_types\n    opx_input_offset: float = None\n\n    time_of_flight: int = 140\n    smearing: int = 0\n\n    time_tagging: Optional[TimeTaggingAddon] = None\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this InSingleChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        # Add output to config\n        super().apply_to_config(config)\n\n        # Note outputs instead of inputs because it's w.r.t. the QPU\n        element_config = config[\"elements\"][self.name]\n        element_config[\"smearing\"] = self.smearing\n        element_config[\"time_of_flight\"] = self.time_of_flight\n\n        # Check for deprecated port properties on channel\n        if self.opx_input_offset is not None:\n            msg = _create_port_property_deprecation_message(\n                \"InSingleChannel\",\n                \"opx_input_offset\",\n                self.opx_input_offset,\n                self.opx_input,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        if isinstance(self.opx_input, LFAnalogInputPort):\n            opx_port = self.opx_input\n        elif len(self.opx_input) == 2:\n            opx_port = OPXPlusAnalogInputPort(\n                *self.opx_input, offset=self.opx_input_offset\n            )\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogInputPort(\n                *self.opx_input, offset=self.opx_input_offset\n            )\n            opx_port.apply_to_config(config)\n\n        element_config[\"outputs\"] = {\"out1\": opx_port.port_tuple}\n\n    def measure(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        qua_vars: Tuple[QuaVariableFloat, ...] = None,\n        stream=None,\n    ) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n        \"\"\"Perform a full demodulation measurement on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            qua_vars (Tuple[QuaVariable[float], ...], optional): Two QUA\n                variables to store the I, Q measurement results.\n                If not provided, new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n\n        Returns:\n            I, Q: The QUA variables used to store the measurement results.\n                If provided as input, the same variables will be returned.\n                If not provided, new variables will be declared and returned.\n\n        Raises:\n            ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n                variables.\n        \"\"\"\n\n        pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n        if qua_vars is not None:\n            if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n                raise ValueError(\n                    f\"InOutSingleChannel.measure received kwarg 'qua_vars' \"\n                    f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n                )\n        else:\n            qua_vars = [declare(fixed) for _ in range(2)]\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        integration_weight_labels = list(pulse.integration_weights_mapping)\n        measure(\n            pulse_name_with_amp_scale,\n            self.name,\n            demod.full(integration_weight_labels[0], qua_vars[0], \"out1\"),\n            demod.full(integration_weight_labels[1], qua_vars[1], \"out1\"),\n            adc_stream=stream,\n        )\n        return tuple(qua_vars)\n\n    def measure_accumulated(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        num_segments: int = None,\n        segment_length: int = None,\n        qua_vars: Tuple[QuaVariableFloat, ...] = None,\n        stream=None,\n    ) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n        \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            num_segments (int): The number of segments to accumulate.\n                Should either specify this or `segment_length`.\n            segment_length (int): The length of the segment to accumulate.\n                Should either specify this or `num_segments`.\n            qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n                variables to store the I, Q measurement results.\n                If not provided, new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n\n        Returns:\n            I, Q: The QUA variables used to store the measurement results.\n                If provided as input, the same variables will be returned.\n                If not provided, new variables will be declared and returned.\n\n        Raises:\n            ValueError: If both `num_segments` and `segment_length` are provided, or if\n                neither are provided.\n            ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n                variables.\n        \"\"\"\n        pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n        if num_segments is None and segment_length is None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_accumulated requires either 'segment_length' \"\n                \"or 'num_segments' to be provided.\"\n            )\n        elif num_segments is not None and segment_length is not None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_accumulated received both 'segment_length' \"\n                \"and 'num_segments'. Please provide only one.\"\n            )\n        elif num_segments is None:\n            num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n        elif segment_length is None:\n            segment_length = int(pulse.length / (4 * num_segments))\n\n        if qua_vars is not None:\n            if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n                raise ValueError(\n                    f\"InOutSingleChannel.measure_accumulated received kwarg 'qua_vars' \"\n                    f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n                )\n        else:\n            qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        integration_weight_labels = list(pulse.integration_weights_mapping)\n        measure(\n            pulse_name_with_amp_scale,\n            self.name,\n            demod.accumulated(\n                integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n            ),\n            demod.accumulated(\n                integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n            ),\n            adc_stream=stream,\n        )\n        return tuple(qua_vars)\n\n    def measure_sliced(\n        self,\n        pulse_name: str,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        num_segments: int = None,\n        segment_length: int = None,\n        qua_vars: Tuple[QuaVariableFloat, ...] = None,\n        stream=None,\n    ) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n        \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            num_segments (int): The number of segments to accumulate.\n                Should either specify this or `segment_length`.\n            segment_length (int): The length of the segment to accumulate.\n                Should either specify this or `num_segments`.\n            qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n                variables to store the I, Q measurement results.\n                If not provided, new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n\n        Returns:\n            I, Q: The QUA variables used to store the measurement results.\n                If provided as input, the same variables will be returned.\n                If not provided, new variables will be declared and returned.\n\n        Raises:\n            ValueError: If both `num_segments` and `segment_length` are provided, or if\n                neither are provided.\n            ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n                variables.\n        \"\"\"\n        pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n        if num_segments is None and segment_length is None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_sliced requires either 'segment_length' \"\n                \"or 'num_segments' to be provided.\"\n            )\n        elif num_segments is not None and segment_length is not None:\n            raise ValueError(\n                \"InOutSingleChannel.measure_sliced received both 'segment_length' \"\n                \"and 'num_segments'. Please provide only one.\"\n            )\n        elif num_segments is None:\n            num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n        elif segment_length is None:\n            segment_length = int(pulse.length / (4 * num_segments))\n\n        if qua_vars is not None:\n            if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n                raise ValueError(\n                    f\"InOutSingleChannel.measure_sliced received kwarg 'qua_vars' \"\n                    f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n                )\n        else:\n            qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n        pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n            pulse_name, amplitude_scale\n        )\n\n        integration_weight_labels = list(pulse.integration_weights_mapping)\n        measure(\n            pulse_name_with_amp_scale,\n            self.name,\n            demod.sliced(\n                integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n            ),\n            demod.sliced(\n                integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n            ),\n            adc_stream=stream,\n        )\n        return tuple(qua_vars)\n\n    def measure_time_tagging(\n        self,\n        pulse_name: str,\n        size: int,\n        max_time: int,\n        qua_vars: Optional[Tuple[QuaVariableInt, QuaScalarInt]] = None,\n        stream: Optional[StreamType] = None,\n        mode: Literal[\"analog\", \"high_res\", \"digital\"] = \"analog\",\n    ) -&gt; Tuple[QuaVariableInt, QuaScalarInt]:\n        \"\"\"Perform a time tagging measurement on this channel.\n\n        For details see https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            size (int): The size of the QUA array to store the times of the detected\n                pulses. Ignored if `qua_vars` is provided.\n            max_time (int): The maximum time to search for pulses.\n            qua_vars (Tuple[QuaVariableInt, QuaScalarInt], optional): QUA variables\n                to store the times and counts of the detected pulses. If not provided,\n                new variables will be declared and returned.\n            stream (Optional[StreamType]): The stream to save the measurement result to.\n                If not provided, the raw ADC signal will not be streamed.\n            mode (Literal[\"analog\", \"high_res\", \"digital\"]): The time tagging mode.\n\n        Returns:\n            times (QuaVariable[Any]): The QUA variable to store the times of the detected\n                pulses.\n            counts (QuaScalar[int]): The number of detected pulses.\n\n        Example:\n            ```python\n            times, counts = channel.measure_time_tagging(\"readout\", size=1000, max_time=1000)\n            ```\n        \"\"\"\n        if mode == \"analog\":\n            time_tagging_func = time_tagging.analog\n        elif mode == \"high_res\":\n            time_tagging_func = time_tagging.high_res\n        elif mode == \"digital\":\n            time_tagging_func = time_tagging.digital\n        else:\n            raise ValueError(f\"Invalid time tagging mode: {mode}\")\n\n        if qua_vars is None:\n            times = declare(int, size=size)\n            counts = declare(int)\n        else:\n            times, counts = qua_vars\n\n        measure(\n            pulse_name,\n            self.name,\n            time_tagging_func(target=times, max_time=max_time, targetLen=counts),\n            adc_stream=stream,\n        )\n        return times, counts\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InSingleChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this InSingleChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this InSingleChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    # Add output to config\n    super().apply_to_config(config)\n\n    # Note outputs instead of inputs because it's w.r.t. the QPU\n    element_config = config[\"elements\"][self.name]\n    element_config[\"smearing\"] = self.smearing\n    element_config[\"time_of_flight\"] = self.time_of_flight\n\n    # Check for deprecated port properties on channel\n    if self.opx_input_offset is not None:\n        msg = _create_port_property_deprecation_message(\n            \"InSingleChannel\",\n            \"opx_input_offset\",\n            self.opx_input_offset,\n            self.opx_input,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    if isinstance(self.opx_input, LFAnalogInputPort):\n        opx_port = self.opx_input\n    elif len(self.opx_input) == 2:\n        opx_port = OPXPlusAnalogInputPort(\n            *self.opx_input, offset=self.opx_input_offset\n        )\n        opx_port.apply_to_config(config)\n    else:\n        opx_port = LFFEMAnalogInputPort(\n            *self.opx_input, offset=self.opx_input_offset\n        )\n        opx_port.apply_to_config(config)\n\n    element_config[\"outputs\"] = {\"out1\": opx_port.port_tuple}\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InSingleChannel.measure","title":"<code>measure(pulse_name, amplitude_scale=None, qua_vars=None, stream=None)</code>","text":"<p>Perform a full demodulation measurement on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>qua_vars</code> <code>Tuple[QuaVariable[float], ...]</code> <p>Two QUA variables to store the I, Q measurement results. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[QuaVariableFloat, QuaVariableFloat]</code> <p>I, Q: The QUA variables used to store the measurement results. If provided as input, the same variables will be returned. If not provided, new variables will be declared and returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>qua_vars</code> is provided and is not a tuple of two QUA variables.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def measure(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    qua_vars: Tuple[QuaVariableFloat, ...] = None,\n    stream=None,\n) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n    \"\"\"Perform a full demodulation measurement on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        qua_vars (Tuple[QuaVariable[float], ...], optional): Two QUA\n            variables to store the I, Q measurement results.\n            If not provided, new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n\n    Returns:\n        I, Q: The QUA variables used to store the measurement results.\n            If provided as input, the same variables will be returned.\n            If not provided, new variables will be declared and returned.\n\n    Raises:\n        ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n            variables.\n    \"\"\"\n\n    pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n    if qua_vars is not None:\n        if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n            raise ValueError(\n                f\"InOutSingleChannel.measure received kwarg 'qua_vars' \"\n                f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n            )\n    else:\n        qua_vars = [declare(fixed) for _ in range(2)]\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    integration_weight_labels = list(pulse.integration_weights_mapping)\n    measure(\n        pulse_name_with_amp_scale,\n        self.name,\n        demod.full(integration_weight_labels[0], qua_vars[0], \"out1\"),\n        demod.full(integration_weight_labels[1], qua_vars[1], \"out1\"),\n        adc_stream=stream,\n    )\n    return tuple(qua_vars)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InSingleChannel.measure_accumulated","title":"<code>measure_accumulated(pulse_name, amplitude_scale=None, num_segments=None, segment_length=None, qua_vars=None, stream=None)</code>","text":"<p>Perform an accumulated demodulation measurement on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>num_segments</code> <code>int</code> <p>The number of segments to accumulate. Should either specify this or <code>segment_length</code>.</p> <code>None</code> <code>segment_length</code> <code>int</code> <p>The length of the segment to accumulate. Should either specify this or <code>num_segments</code>.</p> <code>None</code> <code>qua_vars</code> <code>Tuple[QuaVariableFloat, ...]</code> <p>Two QUA variables to store the I, Q measurement results. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[QuaVariableFloat, QuaVariableFloat]</code> <p>I, Q: The QUA variables used to store the measurement results. If provided as input, the same variables will be returned. If not provided, new variables will be declared and returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>num_segments</code> and <code>segment_length</code> are provided, or if neither are provided.</p> <code>ValueError</code> <p>If <code>qua_vars</code> is provided and is not a tuple of two QUA variables.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def measure_accumulated(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    num_segments: int = None,\n    segment_length: int = None,\n    qua_vars: Tuple[QuaVariableFloat, ...] = None,\n    stream=None,\n) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n    \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        num_segments (int): The number of segments to accumulate.\n            Should either specify this or `segment_length`.\n        segment_length (int): The length of the segment to accumulate.\n            Should either specify this or `num_segments`.\n        qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n            variables to store the I, Q measurement results.\n            If not provided, new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n\n    Returns:\n        I, Q: The QUA variables used to store the measurement results.\n            If provided as input, the same variables will be returned.\n            If not provided, new variables will be declared and returned.\n\n    Raises:\n        ValueError: If both `num_segments` and `segment_length` are provided, or if\n            neither are provided.\n        ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n            variables.\n    \"\"\"\n    pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n    if num_segments is None and segment_length is None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_accumulated requires either 'segment_length' \"\n            \"or 'num_segments' to be provided.\"\n        )\n    elif num_segments is not None and segment_length is not None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_accumulated received both 'segment_length' \"\n            \"and 'num_segments'. Please provide only one.\"\n        )\n    elif num_segments is None:\n        num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n    elif segment_length is None:\n        segment_length = int(pulse.length / (4 * num_segments))\n\n    if qua_vars is not None:\n        if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n            raise ValueError(\n                f\"InOutSingleChannel.measure_accumulated received kwarg 'qua_vars' \"\n                f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n            )\n    else:\n        qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    integration_weight_labels = list(pulse.integration_weights_mapping)\n    measure(\n        pulse_name_with_amp_scale,\n        self.name,\n        demod.accumulated(\n            integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n        ),\n        demod.accumulated(\n            integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n        ),\n        adc_stream=stream,\n    )\n    return tuple(qua_vars)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InSingleChannel.measure_sliced","title":"<code>measure_sliced(pulse_name, amplitude_scale=None, num_segments=None, segment_length=None, qua_vars=None, stream=None)</code>","text":"<p>Perform an accumulated demodulation measurement on this channel.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>num_segments</code> <code>int</code> <p>The number of segments to accumulate. Should either specify this or <code>segment_length</code>.</p> <code>None</code> <code>segment_length</code> <code>int</code> <p>The length of the segment to accumulate. Should either specify this or <code>num_segments</code>.</p> <code>None</code> <code>qua_vars</code> <code>Tuple[QuaVariableFloat, ...]</code> <p>Two QUA variables to store the I, Q measurement results. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[QuaVariableFloat, QuaVariableFloat]</code> <p>I, Q: The QUA variables used to store the measurement results. If provided as input, the same variables will be returned. If not provided, new variables will be declared and returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>num_segments</code> and <code>segment_length</code> are provided, or if neither are provided.</p> <code>ValueError</code> <p>If <code>qua_vars</code> is provided and is not a tuple of two QUA variables.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def measure_sliced(\n    self,\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    num_segments: int = None,\n    segment_length: int = None,\n    qua_vars: Tuple[QuaVariableFloat, ...] = None,\n    stream=None,\n) -&gt; Tuple[QuaVariableFloat, QuaVariableFloat]:\n    \"\"\"Perform an accumulated demodulation measurement on this channel.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        num_segments (int): The number of segments to accumulate.\n            Should either specify this or `segment_length`.\n        segment_length (int): The length of the segment to accumulate.\n            Should either specify this or `num_segments`.\n        qua_vars (Tuple[QuaVariableFloat, ...], optional): Two QUA\n            variables to store the I, Q measurement results.\n            If not provided, new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n\n    Returns:\n        I, Q: The QUA variables used to store the measurement results.\n            If provided as input, the same variables will be returned.\n            If not provided, new variables will be declared and returned.\n\n    Raises:\n        ValueError: If both `num_segments` and `segment_length` are provided, or if\n            neither are provided.\n        ValueError: If `qua_vars` is provided and is not a tuple of two QUA\n            variables.\n    \"\"\"\n    pulse: BaseReadoutPulse = self.operations[pulse_name]\n\n    if num_segments is None and segment_length is None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_sliced requires either 'segment_length' \"\n            \"or 'num_segments' to be provided.\"\n        )\n    elif num_segments is not None and segment_length is not None:\n        raise ValueError(\n            \"InOutSingleChannel.measure_sliced received both 'segment_length' \"\n            \"and 'num_segments'. Please provide only one.\"\n        )\n    elif num_segments is None:\n        num_segments = int(pulse.length / (4 * segment_length))  # Number of slices\n    elif segment_length is None:\n        segment_length = int(pulse.length / (4 * num_segments))\n\n    if qua_vars is not None:\n        if not isinstance(qua_vars, Sequence) or len(qua_vars) != 2:\n            raise ValueError(\n                f\"InOutSingleChannel.measure_sliced received kwarg 'qua_vars' \"\n                f\"which is not a tuple of two QUA variables. Received {qua_vars=}\"\n            )\n    else:\n        qua_vars = [declare(fixed, size=num_segments) for _ in range(2)]\n\n    pulse_name_with_amp_scale = add_amplitude_scale_to_pulse_name(\n        pulse_name, amplitude_scale\n    )\n\n    integration_weight_labels = list(pulse.integration_weights_mapping)\n    measure(\n        pulse_name_with_amp_scale,\n        self.name,\n        demod.sliced(\n            integration_weight_labels[0], qua_vars[0], segment_length, \"out1\"\n        ),\n        demod.sliced(\n            integration_weight_labels[1], qua_vars[1], segment_length, \"out1\"\n        ),\n        adc_stream=stream,\n    )\n    return tuple(qua_vars)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InSingleChannel.measure_time_tagging","title":"<code>measure_time_tagging(pulse_name, size, max_time, qua_vars=None, stream=None, mode='analog')</code>","text":"<p>Perform a time tagging measurement on this channel.</p> <p>For details see https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>size</code> <code>int</code> <p>The size of the QUA array to store the times of the detected pulses. Ignored if <code>qua_vars</code> is provided.</p> required <code>max_time</code> <code>int</code> <p>The maximum time to search for pulses.</p> required <code>qua_vars</code> <code>Tuple[QuaVariableInt, QuaScalarInt]</code> <p>QUA variables to store the times and counts of the detected pulses. If not provided, new variables will be declared and returned.</p> <code>None</code> <code>stream</code> <code>Optional[StreamType]</code> <p>The stream to save the measurement result to. If not provided, the raw ADC signal will not be streamed.</p> <code>None</code> <code>mode</code> <code>Literal['analog', 'high_res', 'digital']</code> <p>The time tagging mode.</p> <code>'analog'</code> <p>Returns:</p> Name Type Description <code>times</code> <code>QuaVariable[Any]</code> <p>The QUA variable to store the times of the detected pulses.</p> <code>counts</code> <code>QuaScalar[int]</code> <p>The number of detected pulses.</p> Example <pre><code>times, counts = channel.measure_time_tagging(\"readout\", size=1000, max_time=1000)\n</code></pre> Source code in <code>quam/components/channels.py</code> <pre><code>def measure_time_tagging(\n    self,\n    pulse_name: str,\n    size: int,\n    max_time: int,\n    qua_vars: Optional[Tuple[QuaVariableInt, QuaScalarInt]] = None,\n    stream: Optional[StreamType] = None,\n    mode: Literal[\"analog\", \"high_res\", \"digital\"] = \"analog\",\n) -&gt; Tuple[QuaVariableInt, QuaScalarInt]:\n    \"\"\"Perform a time tagging measurement on this channel.\n\n    For details see https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        size (int): The size of the QUA array to store the times of the detected\n            pulses. Ignored if `qua_vars` is provided.\n        max_time (int): The maximum time to search for pulses.\n        qua_vars (Tuple[QuaVariableInt, QuaScalarInt], optional): QUA variables\n            to store the times and counts of the detected pulses. If not provided,\n            new variables will be declared and returned.\n        stream (Optional[StreamType]): The stream to save the measurement result to.\n            If not provided, the raw ADC signal will not be streamed.\n        mode (Literal[\"analog\", \"high_res\", \"digital\"]): The time tagging mode.\n\n    Returns:\n        times (QuaVariable[Any]): The QUA variable to store the times of the detected\n            pulses.\n        counts (QuaScalar[int]): The number of detected pulses.\n\n    Example:\n        ```python\n        times, counts = channel.measure_time_tagging(\"readout\", size=1000, max_time=1000)\n        ```\n    \"\"\"\n    if mode == \"analog\":\n        time_tagging_func = time_tagging.analog\n    elif mode == \"high_res\":\n        time_tagging_func = time_tagging.high_res\n    elif mode == \"digital\":\n        time_tagging_func = time_tagging.digital\n    else:\n        raise ValueError(f\"Invalid time tagging mode: {mode}\")\n\n    if qua_vars is None:\n        times = declare(int, size=size)\n        counts = declare(int)\n    else:\n        times, counts = qua_vars\n\n    measure(\n        pulse_name,\n        self.name,\n        time_tagging_func(target=times, max_time=max_time, targetLen=counts),\n        adc_stream=stream,\n    )\n    return times, counts\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.InSingleOutIQChannel","title":"<code>InSingleOutIQChannel</code>","text":"<p>               Bases: <code>IQChannel</code>, <code>InSingleChannel</code></p> <p>QUAM component for an IQ output channel with a single input.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"readout\") and value is a ReadoutPulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output_I</code> <code>LF_output_port_types</code> <p>Channel I output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)</p> required <code>opx_output_Q</code> <code>LF_output_port_types</code> <p>Channel Q output port from the OPX perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>opx_output_offset_I</code> <code>float</code> <p>The offset of the I channel. Default is 0.</p> required <code>opx_output_offset_Q</code> <code>float</code> <p>The offset of the Q channel. Default is 0.</p> required <code>opx_input</code> <code>LF_input_port_types</code> <p>Channel input port from OPX perspective, e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)</p> required <code>opx_input_offset</code> <code>float</code> <p>DC offset for the input port.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of the mixer. Default is 0.0</p> required <code>LO_frequency</code> <code>float</code> <p>Local oscillator frequency. Default is the LO frequency of the frequency converter up component.</p> required <code>RF_frequency</code> <code>float</code> <p>RF frequency of the mixer. By default, the RF frequency is inferred by adding the LO frequency and the intermediate frequency.</p> required <code>frequency_converter_up</code> <code>FrequencyConverter</code> <p>Frequency converter QUAM component for the IQ output.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass InSingleOutIQChannel(IQChannel, InSingleChannel):\n    \"\"\"QUAM component for an IQ output channel with a single input.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"readout\") and value is a\n            ReadoutPulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output_I (LF_output_port_types): Channel I output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 1)\n        opx_output_Q (LF_output_port_types): Channel Q output port from the OPX\n            perspective, e.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        opx_output_offset_I (float): The offset of the I channel. Default is 0.\n        opx_output_offset_Q (float): The offset of the Q channel. Default is 0.\n        opx_input (LF_input_port_types): Channel input port from OPX perspective,\n            e.g. LFFEMAnalogInputPort(\"con1\", 1, 1)\n        opx_input_offset (float): DC offset for the input port.\n        intermediate_frequency (float): Intermediate frequency of the mixer.\n            Default is 0.0\n        LO_frequency (float): Local oscillator frequency. Default is the LO frequency\n            of the frequency converter up component.\n        RF_frequency (float): RF frequency of the mixer. By default, the RF frequency\n            is inferred by adding the LO frequency and the intermediate frequency.\n        frequency_converter_up (FrequencyConverter): Frequency converter QUAM component\n            for the IQ output.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.MWChannel","title":"<code>MWChannel</code>","text":"<p>               Bases: <code>_OutComplexChannel</code></p> <p>QUAM component for a MW FEM output channel</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>MWFEMAnalogOutputPort</code> <p>Channel output port from the OPX perspective.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required <code>upconverter</code> <code>int</code> <p>The upconverter to use. Default is 1.</p> required <code>time_of_flight</code> <code>int</code> <p>Round-trip signal duration in nanoseconds.</p> required <code>smearing</code> <code>int</code> <p>Additional window of ADC integration in nanoseconds. Used to account for signal smearing.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass MWChannel(_OutComplexChannel):\n    \"\"\"QUAM component for a MW FEM output channel\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (MWFEMAnalogOutputPort): Channel output port from the OPX perspective.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n        upconverter (int): The upconverter to use. Default is 1.\n        time_of_flight (int): Round-trip signal duration in nanoseconds.\n        smearing (int): Additional window of ADC integration in nanoseconds.\n            Used to account for signal smearing.\n    \"\"\"\n\n    opx_output: MWFEMAnalogOutputPort\n    upconverter: int = 1\n\n    LO_frequency: float = \"#./upconverter_frequency\"\n    RF_frequency: float = \"#./inferred_RF_frequency\"\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        super().apply_to_config(config)\n\n        element_config = config[\"elements\"][self.name]\n        element_config[\"MWInput\"] = {\n            \"port\": self.opx_output.port_tuple,\n            \"upconverter\": self.upconverter,\n        }\n\n    @property\n    def upconverter_frequency(self) -&gt; float:\n        \"\"\"Determine the upconverter frequency from the opx_output.\n\n        If the upconverter frequency is not set, the upconverter frequency is inferred\n        from the upconverters dictionary.\n\n        Returns:\n            The upconverter frequency.\n\n        Raises:\n            ValueError: If the upconverter frequency is not set and cannot be inferred.\n        \"\"\"\n        if self.opx_output.upconverter_frequency is not None:\n            return self.opx_output.upconverter_frequency\n        if self.opx_output.upconverters is not None:\n            upconverter_config = self.opx_output.upconverters.get(self.upconverter)\n            if upconverter_config is None:\n                raise ValueError(\n                    f\"MWChannel: Upconverter {self.upconverter} not found in upconverters dictionary\"\n                )\n            if \"frequency\" not in upconverter_config:\n                raise ValueError(\n                    f\"MWChannel: 'frequency' key not found in upconverter {self.upconverter} configuration\"\n                )\n            return upconverter_config[\"frequency\"]\n        raise ValueError(\n            \"MWChannel: Either upconverter_frequency or upconverters must be provided\"\n        )\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.MWChannel.upconverter_frequency","title":"<code>upconverter_frequency</code>  <code>property</code>","text":"<p>Determine the upconverter frequency from the opx_output.</p> <p>If the upconverter frequency is not set, the upconverter frequency is inferred from the upconverters dictionary.</p> <p>Returns:</p> Type Description <code>float</code> <p>The upconverter frequency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the upconverter frequency is not set and cannot be inferred.</p>"},{"location":"API_references/components/channels_API/#quam.components.channels.SingleChannel","title":"<code>SingleChannel</code>","text":"<p>               Bases: <code>Channel</code></p> <p>QUAM component for a single (not IQ) output channel.</p> <p>Parameters:</p> Name Type Description Default <code>operations</code> <code>Dict[str, Pulse]</code> <p>A dictionary of pulses to be played on this channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.</p> required <code>id</code> <code>(str, int)</code> <p>The id of the channel, used to generate the name. Can be a string, or an integer in which case it will add <code>Channel._default_label</code>.</p> required <code>opx_output</code> <code>LF_output_port_types</code> <p>Channel output port from the OPX perspective, E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)</p> required <code>filter_fir_taps</code> <code>(List[float], deprecated)</code> <p>FIR filter taps for the output port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(feedforward_filter=...)</code> instead. See Port documentation for details.</p> required <code>filter_iir_taps</code> <code>(List[float], deprecated)</code> <p>IIR filter taps for the output port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(feedback_filter=...)</code> instead. See Port documentation for details.</p> required <code>opx_output_offset</code> <code>(float, deprecated)</code> <p>DC offset for the output port. Deprecated: This property has been moved to Port objects. Use <code>OPXPlusAnalogOutputPort(offset=...)</code> instead. See Port documentation for details.</p> required <code>intermediate_frequency</code> <code>float</code> <p>Intermediate frequency of OPX output, default is None.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass SingleChannel(Channel):\n    \"\"\"QUAM component for a single (not IQ) output channel.\n\n    Args:\n        operations (Dict[str, Pulse]): A dictionary of pulses to be played on this\n            channel. The key is the pulse label (e.g. \"X90\") and value is a Pulse.\n        id (str, int): The id of the channel, used to generate the name.\n            Can be a string, or an integer in which case it will add\n            `Channel._default_label`.\n        opx_output (LF_output_port_types): Channel output port from the OPX perspective,\n            E.g. LFFEMAnalogOutputPort(\"con1\", 1, 2)\n        filter_fir_taps (List[float], deprecated): FIR filter taps for the output port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(feedforward_filter=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        filter_iir_taps (List[float], deprecated): IIR filter taps for the output port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(feedback_filter=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        opx_output_offset (float, deprecated): DC offset for the output port.\n            **Deprecated**: This property has been moved to Port objects. Use\n            `OPXPlusAnalogOutputPort(offset=...)` instead.\n            See [Port documentation](channel-ports.md) for details.\n        intermediate_frequency (float): Intermediate frequency of OPX output, default\n            is None.\n    \"\"\"\n\n    opx_output: LF_output_port_types\n    filter_fir_taps: List[float] = None\n    filter_iir_taps: List[float] = None\n\n    opx_output_offset: float = None\n\n    def set_dc_offset(self, offset: ScalarFloat):\n        \"\"\"Set the DC offset of an element's input to the given value.\n        This value will remain the DC offset until changed or until the Quantum Machine\n        is closed.\n\n        Args:\n            offset (Scalar[float]): The DC offset to set the input to.\n                This is limited by the OPX output voltage range.\n        \"\"\"\n        set_dc_offset(element=self.name, element_input=\"single\", offset=offset)\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this SingleChannel to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        # Add pulses &amp; waveforms\n        super().apply_to_config(config)\n\n        if str_ref.is_reference(self.name):\n            raise AttributeError(\n                f\"Channel {self.get_reference()} cannot be added to the config because\"\n                \" it doesn't have a name. Either set channel.id to a string or\"\n                \" integer, or channel should be an attribute of another QUAM component\"\n                \" with a name.\"\n            )\n\n        element_config = config[\"elements\"][self.name]\n\n        # Check for deprecated port properties on channel\n        if self.opx_output_offset is not None:\n            msg = _create_port_property_deprecation_message(\n                \"SingleChannel\",\n                \"opx_output_offset\",\n                self.opx_output_offset,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n        filter_fir_taps = self.filter_fir_taps\n        if filter_fir_taps is not None:\n            msg = _create_port_property_deprecation_message(\n                \"SingleChannel\",\n                \"filter_fir_taps\",\n                filter_fir_taps,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            filter_fir_taps = list(filter_fir_taps)\n        filter_iir_taps = self.filter_iir_taps\n        if filter_iir_taps is not None:\n            msg = _create_port_property_deprecation_message(\n                \"SingleChannel\",\n                \"filter_iir_taps\",\n                filter_iir_taps,\n                self.opx_output,\n            )\n            warnings.warn(msg, DeprecationWarning, stacklevel=2)\n            filter_iir_taps = list(filter_iir_taps)\n\n        if isinstance(self.opx_output, LFAnalogOutputPort):\n            opx_port = self.opx_output\n        elif len(self.opx_output) == 2:\n            opx_port = OPXPlusAnalogOutputPort(\n                *self.opx_output,\n                offset=self.opx_output_offset,\n                feedforward_filter=filter_fir_taps,\n                feedback_filter=filter_iir_taps,\n            )\n            opx_port.apply_to_config(config)\n        else:\n            opx_port = LFFEMAnalogOutputPort(\n                *self.opx_output,\n                offset=self.opx_output_offset,\n                feedforward_filter=filter_fir_taps,\n                feedback_filter=filter_iir_taps,\n            )\n            opx_port.apply_to_config(config)\n\n        element_config[\"singleInput\"] = {\"port\": opx_port.port_tuple}\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.SingleChannel.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this SingleChannel to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/channels.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this SingleChannel to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    # Add pulses &amp; waveforms\n    super().apply_to_config(config)\n\n    if str_ref.is_reference(self.name):\n        raise AttributeError(\n            f\"Channel {self.get_reference()} cannot be added to the config because\"\n            \" it doesn't have a name. Either set channel.id to a string or\"\n            \" integer, or channel should be an attribute of another QUAM component\"\n            \" with a name.\"\n        )\n\n    element_config = config[\"elements\"][self.name]\n\n    # Check for deprecated port properties on channel\n    if self.opx_output_offset is not None:\n        msg = _create_port_property_deprecation_message(\n            \"SingleChannel\",\n            \"opx_output_offset\",\n            self.opx_output_offset,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    filter_fir_taps = self.filter_fir_taps\n    if filter_fir_taps is not None:\n        msg = _create_port_property_deprecation_message(\n            \"SingleChannel\",\n            \"filter_fir_taps\",\n            filter_fir_taps,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        filter_fir_taps = list(filter_fir_taps)\n    filter_iir_taps = self.filter_iir_taps\n    if filter_iir_taps is not None:\n        msg = _create_port_property_deprecation_message(\n            \"SingleChannel\",\n            \"filter_iir_taps\",\n            filter_iir_taps,\n            self.opx_output,\n        )\n        warnings.warn(msg, DeprecationWarning, stacklevel=2)\n        filter_iir_taps = list(filter_iir_taps)\n\n    if isinstance(self.opx_output, LFAnalogOutputPort):\n        opx_port = self.opx_output\n    elif len(self.opx_output) == 2:\n        opx_port = OPXPlusAnalogOutputPort(\n            *self.opx_output,\n            offset=self.opx_output_offset,\n            feedforward_filter=filter_fir_taps,\n            feedback_filter=filter_iir_taps,\n        )\n        opx_port.apply_to_config(config)\n    else:\n        opx_port = LFFEMAnalogOutputPort(\n            *self.opx_output,\n            offset=self.opx_output_offset,\n            feedforward_filter=filter_fir_taps,\n            feedback_filter=filter_iir_taps,\n        )\n        opx_port.apply_to_config(config)\n\n    element_config[\"singleInput\"] = {\"port\": opx_port.port_tuple}\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.SingleChannel.set_dc_offset","title":"<code>set_dc_offset(offset)</code>","text":"<p>Set the DC offset of an element's input to the given value. This value will remain the DC offset until changed or until the Quantum Machine is closed.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>Scalar[float]</code> <p>The DC offset to set the input to. This is limited by the OPX output voltage range.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>def set_dc_offset(self, offset: ScalarFloat):\n    \"\"\"Set the DC offset of an element's input to the given value.\n    This value will remain the DC offset until changed or until the Quantum Machine\n    is closed.\n\n    Args:\n        offset (Scalar[float]): The DC offset to set the input to.\n            This is limited by the OPX output voltage range.\n    \"\"\"\n    set_dc_offset(element=self.name, element_input=\"single\", offset=offset)\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.StickyChannelAddon","title":"<code>StickyChannelAddon</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>Addon to make channels sticky.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>int</code> <p>The ramp to zero duration, in ns.</p> required <code>enabled</code> <code>bool</code> <p>If False, the sticky parameters are not applied. Default is True.</p> required <code>analog</code> <code>bool</code> <p>If False, the sticky parameters are not applied to analog outputs. Default is True.</p> required <code>digital</code> <code>bool</code> <p>If False, the sticky parameters are not applied to digital outputs. Default is True.</p> required Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass StickyChannelAddon(QuamComponent):\n    \"\"\"Addon to make channels sticky.\n\n    Args:\n        duration (int): The ramp to zero duration, in ns.\n        enabled (bool, optional): If False, the sticky parameters are not applied.\n            Default is True.\n        analog (bool, optional): If False, the sticky parameters are not applied to\n            analog outputs. Default is True.\n        digital (bool, optional): If False, the sticky parameters are not applied to\n            digital outputs. Default is True.\n    \"\"\"\n\n    duration: int\n    enabled: bool = True\n    analog: bool = True\n    digital: bool = True\n\n    @property\n    def channel(self) -&gt; Optional[\"Channel\"]:\n        \"\"\"If the parent is a channel, returns the parent, otherwise returns None.\"\"\"\n        if isinstance(self.parent, Channel):\n            return self.parent\n        else:\n            return\n\n    @property\n    def config_settings(self):\n        if self.channel is not None:\n            return {\"after\": [self.channel]}\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        if self.channel is None:\n            return\n\n        if not self.enabled:\n            return\n\n        config[\"elements\"][self.channel.name][\"sticky\"] = {\n            \"analog\": self.analog,\n            \"digital\": self.digital,\n            \"duration\": self.duration,\n        }\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.StickyChannelAddon.channel","title":"<code>channel</code>  <code>property</code>","text":"<p>If the parent is a channel, returns the parent, otherwise returns None.</p>"},{"location":"API_references/components/channels_API/#quam.components.channels.TimeTaggingAddon","title":"<code>TimeTaggingAddon</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>Addon to perform time tagging on a channel.</p> <p>Parameters:</p> Name Type Description Default <code>signal_threshold</code> <code>float</code> <p>The signal threshold in volts. If not specified, the default value is 800 / 4096 \u2248 0.195 V.</p> required <code>signal_polarity</code> <code>Literal['above', 'below']</code> <p>The polarity of the signal threshold. Default is \"below\".</p> required <code>derivative_threshold</code> <code>float</code> <p>The derivative threshold in volts/ns. If not specified, the default value is 300 / 4096 \u2248 0.073 V/ns.</p> required <code>derivative_polarity</code> <code>Literal['above', 'below']</code> <p>The polarity of the derivative threshold. Default is \"below\".</p> required <p>For details see Time Tagging</p> Source code in <code>quam/components/channels.py</code> <pre><code>@quam_dataclass\nclass TimeTaggingAddon(QuamComponent):\n    \"\"\"Addon to perform time tagging on a channel.\n\n    Args:\n        signal_threshold (float, optional): The signal threshold in volts.\n            If not specified, the default value is 800 / 4096 \u2248 0.195 V.\n        signal_polarity (Literal[\"above\", \"below\"]): The polarity of the signal\n            threshold. Default is \"below\".\n        derivative_threshold (float, optional): The derivative threshold in volts/ns.\n            If not specified, the default value is 300 / 4096 \u2248 0.073 V/ns.\n        derivative_polarity (Literal[\"above\", \"below\"]): The polarity of the derivative\n            threshold. Default is \"below\".\n\n    For details see [Time Tagging](https://docs.quantum-machines.co/latest/docs/Guides/features/#time-tagging)\n    \"\"\"\n\n    signal_threshold: float = 800 / 4096\n    signal_polarity: Literal[\"above\", \"below\"] = \"below\"\n    derivative_threshold: float = 300 / 4096\n    derivative_polarity: Literal[\"above\", \"below\"] = \"below\"\n    enabled: bool = True\n\n    @property\n    def channel(self) -&gt; Optional[\"Channel\"]:\n        \"\"\"If the parent is a channel, returns the parent, otherwise returns None.\"\"\"\n        if isinstance(self.parent, Channel):\n            return self.parent\n        else:\n            return\n\n    @property\n    def config_settings(self):\n        if self.channel is not None:\n            return {\"after\": [self.channel]}\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        if self.channel is None:\n            return\n\n        if not self.enabled:\n            return\n\n        if self.signal_threshold is not None and abs(self.signal_threshold) &gt; 1:\n            raise ValueError(\"TimeTaggingAddon.signal_threshold must be a voltage\")\n        # TODO should we also check derivative threshold? What should the max value be?\n\n        ch_cfg = config[\"elements\"][self.channel.name]\n        ch_cfg[\"timeTaggingParameters\"] = {\n            \"signalThreshold\": int(self.signal_threshold * 4096),\n            \"signalPolarity\": self.signal_polarity,\n            \"derivativeThreshold\": int(self.derivative_threshold * 4096),\n            \"derivativePolarity\": self.derivative_polarity,\n        }\n</code></pre>"},{"location":"API_references/components/channels_API/#quam.components.channels.TimeTaggingAddon.channel","title":"<code>channel</code>  <code>property</code>","text":"<p>If the parent is a channel, returns the parent, otherwise returns None.</p>"},{"location":"API_references/components/hardware/","title":"Hardware","text":""},{"location":"API_references/components/hardware/#quam.components.hardware.BaseFrequencyConverter","title":"<code>BaseFrequencyConverter</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>Base class for frequency converters.</p> Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass BaseFrequencyConverter(QuamComponent):\n    \"\"\"Base class for frequency converters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/hardware/#quam.components.hardware.FrequencyConverter","title":"<code>FrequencyConverter</code>","text":"<p>               Bases: <code>BaseFrequencyConverter</code></p> <p>Frequency up/down converter component.</p> <p>This component encapsulates the local oscillator and mixer used to upconvert or downconvert an RF signal.</p> <p>The FrequencyConverter component is attached to IQ channels through</p> <ul> <li><code>IQChannel.frequency_converter_up</code></li> <li><code>InOutIQChannel.frequency_converter_down</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>local_oscillator</code> <code>LocalOscillator</code> <p>The local oscillator for the frequency converter.</p> required <code>mixer</code> <code>Mixer</code> <p>The mixer for the frequency converter.</p> required <code>gain</code> <code>float</code> <p>The gain of the frequency converter.</p> required Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass FrequencyConverter(BaseFrequencyConverter):\n    \"\"\"Frequency up/down converter component.\n\n    This component encapsulates the local oscillator and mixer used to upconvert or\n    downconvert an RF signal.\n\n    The FrequencyConverter component is attached to IQ channels through\n\n    - `IQChannel.frequency_converter_up`\n    - `InOutIQChannel.frequency_converter_down`\n\n    Args:\n        local_oscillator (LocalOscillator): The local oscillator for the frequency converter.\n        mixer (Mixer): The mixer for the frequency converter.\n        gain (float): The gain of the frequency converter.\n    \"\"\"\n\n    local_oscillator: LocalOscillator = None\n    mixer: Mixer = None\n    gain: float = None\n\n    @property\n    def LO_frequency(self):\n        return self.local_oscillator.frequency\n\n    @LO_frequency.setter\n    def LO_frequency(self, value):\n        \"\"\"Sets the frequency of the local oscillator object\"\"\"\n        if self.local_oscillator is None:\n            raise AttributeError(\n                f\"Unable to set LO frequency for {self} as it has no local oscillator\"\n            )\n\n        # Use set_at_reference to ensure the frequency is updated, even if the local\n        # oscillator frequency is a reference\n        self.local_oscillator.set_at_reference(\"frequency\", value)\n\n    def configure(self):\n        if self.local_oscillator is not None:\n            self.local_oscillator.configure()\n</code></pre>"},{"location":"API_references/components/hardware/#quam.components.hardware.LocalOscillator","title":"<code>LocalOscillator</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for a local oscillator.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>The frequency of the local oscillator. Used by the mixer to determine the intermediate frequency.</p> required <code>power</code> <code>float</code> <p>The power of the local oscillator. Not used for the QUA configuration</p> required Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass LocalOscillator(QuamComponent):\n    \"\"\"QUAM component for a local oscillator.\n\n    Args:\n        frequency (float): The frequency of the local oscillator.\n            Used by the mixer to determine the intermediate frequency.\n        power (float, optional): The power of the local oscillator.\n            Not used for the QUA configuration\n    \"\"\"\n\n    frequency: float = None\n    power: float = None\n\n    def configure(self): ...\n</code></pre>"},{"location":"API_references/components/hardware/#quam.components.hardware.Mixer","title":"<code>Mixer</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for a mixer.</p> <p>All properties are optional, so it can be instantiated as <code>Mixer()</code>. For the default values, it is assumed that the mixer parent is an <code>IQChannel</code> that has a <code>LocalOscillator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>local_oscillator_frequency</code> <code>float</code> <p>The frequency of the local oscillator. Default is <code>#../local_oscillator/frequency</code>, meaning that the frequency is extracted from the the local_oscillator of the parent.</p> required <code>intermediate_frequency</code> <code>float</code> <p>The intermediate frequency of the mixer. Default is <code>#../intermediate_frequency</code>, meaning that the frequency references the intermediate_frequency of the parent.</p> required <code>correction_gain</code> <code>float</code> <p>The gain imbalance of the mixer. Default is 0, see <code>Mixer.IQ_imbalance</code> for details.</p> required <code>correction_phase</code> <code>float</code> <p>The phase imbalance of the mixer in radians.</p> required Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass Mixer(QuamComponent):\n    \"\"\"QUAM component for a mixer.\n\n    All properties are optional, so it can be instantiated as `Mixer()`.\n    For the default values, it is assumed that the mixer parent is an `IQChannel`\n    that has a `LocalOscillator`.\n\n    Args:\n        local_oscillator_frequency (float, optional): The frequency of the local\n            oscillator. Default is `#../local_oscillator/frequency`, meaning that\n            the frequency is extracted from the the local_oscillator of the parent.\n        intermediate_frequency (float, optional): The intermediate frequency of the\n            mixer. Default is `#../intermediate_frequency`, meaning that the frequency\n            references the intermediate_frequency of the parent.\n        correction_gain (float, optional): The gain imbalance of the mixer.\n            Default is 0, see `Mixer.IQ_imbalance` for details.\n        correction_phase (float, optional): The phase imbalance of the mixer in radians.\n    \"\"\"\n\n    local_oscillator_frequency: float = \"#../local_oscillator/frequency\"\n    intermediate_frequency: float = \"#../../intermediate_frequency\"\n\n    correction_gain: float = 0\n    correction_phase: float = 0\n\n    @property\n    def name(self):\n        frequency_converter = getattr(self, \"parent\", None)\n        if frequency_converter is None:\n            raise AttributeError(\n                f\"Mixer.parent must be a frequency converter for {self}\"\n            )\n\n        channel = getattr(frequency_converter, \"parent\", None)\n        channel_name = getattr(channel, \"name\", None)\n        if channel is None or channel_name is None:\n            raise AttributeError(f\"Mixer.parent.parent must be a channel for {self}\")\n\n        return f\"{channel_name}{str_ref.DELIMITER}mixer\"\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this mixer to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        correction_matrix = self.IQ_imbalance(\n            self.correction_gain, self.correction_phase\n        )\n\n        config[\"mixers\"][self.name] = [\n            {\n                \"intermediate_frequency\": self.intermediate_frequency,\n                \"lo_frequency\": self.local_oscillator_frequency,\n                \"correction\": correction_matrix,\n            }\n        ]\n\n    @staticmethod\n    def IQ_imbalance(g: float, phi: float) -&gt; List[float]:\n        \"\"\"\n        Creates the correction matrix for the mixer imbalance caused by the gain and\n        phase imbalances, more information can be seen here:\n        https://docs.qualang.io/libs/examples/mixer-calibration/#non-ideal-mixer\n        :param g: relative gain imbalance between the I &amp; Q ports. (unit-less),\n            set to 0 for no gain imbalance.\n        :param phi: relative phase imbalance between the I &amp; Q ports (radians),\n            set to 0 for no phase imbalance.\n        \"\"\"\n        c = np.cos(phi)\n        s = np.sin(phi)\n        N = 1 / ((1 - g**2) * (2 * c**2 - 1))\n        return [\n            float(N * x) for x in [(1 - g) * c, (1 + g) * s, (1 - g) * s, (1 + g) * c]\n        ]\n</code></pre>"},{"location":"API_references/components/hardware/#quam.components.hardware.Mixer.IQ_imbalance","title":"<code>IQ_imbalance(g, phi)</code>  <code>staticmethod</code>","text":"<p>Creates the correction matrix for the mixer imbalance caused by the gain and phase imbalances, more information can be seen here: https://docs.qualang.io/libs/examples/mixer-calibration/#non-ideal-mixer :param g: relative gain imbalance between the I &amp; Q ports. (unit-less),     set to 0 for no gain imbalance. :param phi: relative phase imbalance between the I &amp; Q ports (radians),     set to 0 for no phase imbalance.</p> Source code in <code>quam/components/hardware.py</code> <pre><code>@staticmethod\ndef IQ_imbalance(g: float, phi: float) -&gt; List[float]:\n    \"\"\"\n    Creates the correction matrix for the mixer imbalance caused by the gain and\n    phase imbalances, more information can be seen here:\n    https://docs.qualang.io/libs/examples/mixer-calibration/#non-ideal-mixer\n    :param g: relative gain imbalance between the I &amp; Q ports. (unit-less),\n        set to 0 for no gain imbalance.\n    :param phi: relative phase imbalance between the I &amp; Q ports (radians),\n        set to 0 for no phase imbalance.\n    \"\"\"\n    c = np.cos(phi)\n    s = np.sin(phi)\n    N = 1 / ((1 - g**2) * (2 * c**2 - 1))\n    return [\n        float(N * x) for x in [(1 - g) * c, (1 + g) * s, (1 - g) * s, (1 + g) * c]\n    ]\n</code></pre>"},{"location":"API_references/components/hardware/#quam.components.hardware.Mixer.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this mixer to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/hardware.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this mixer to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    correction_matrix = self.IQ_imbalance(\n        self.correction_gain, self.correction_phase\n    )\n\n    config[\"mixers\"][self.name] = [\n        {\n            \"intermediate_frequency\": self.intermediate_frequency,\n            \"lo_frequency\": self.local_oscillator_frequency,\n            \"correction\": correction_matrix,\n        }\n    ]\n</code></pre>"},{"location":"API_references/components/hardware_API/","title":"QUAM Hardware API","text":""},{"location":"API_references/components/hardware_API/#quam.components.hardware.BaseFrequencyConverter","title":"<code>BaseFrequencyConverter</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>Base class for frequency converters.</p> Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass BaseFrequencyConverter(QuamComponent):\n    \"\"\"Base class for frequency converters.\"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/components/hardware_API/#quam.components.hardware.FrequencyConverter","title":"<code>FrequencyConverter</code>","text":"<p>               Bases: <code>BaseFrequencyConverter</code></p> <p>Frequency up/down converter component.</p> <p>This component encapsulates the local oscillator and mixer used to upconvert or downconvert an RF signal.</p> <p>The FrequencyConverter component is attached to IQ channels through</p> <ul> <li><code>IQChannel.frequency_converter_up</code></li> <li><code>InOutIQChannel.frequency_converter_down</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>local_oscillator</code> <code>LocalOscillator</code> <p>The local oscillator for the frequency converter.</p> required <code>mixer</code> <code>Mixer</code> <p>The mixer for the frequency converter.</p> required <code>gain</code> <code>float</code> <p>The gain of the frequency converter.</p> required Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass FrequencyConverter(BaseFrequencyConverter):\n    \"\"\"Frequency up/down converter component.\n\n    This component encapsulates the local oscillator and mixer used to upconvert or\n    downconvert an RF signal.\n\n    The FrequencyConverter component is attached to IQ channels through\n\n    - `IQChannel.frequency_converter_up`\n    - `InOutIQChannel.frequency_converter_down`\n\n    Args:\n        local_oscillator (LocalOscillator): The local oscillator for the frequency converter.\n        mixer (Mixer): The mixer for the frequency converter.\n        gain (float): The gain of the frequency converter.\n    \"\"\"\n\n    local_oscillator: LocalOscillator = None\n    mixer: Mixer = None\n    gain: float = None\n\n    @property\n    def LO_frequency(self):\n        return self.local_oscillator.frequency\n\n    @LO_frequency.setter\n    def LO_frequency(self, value):\n        \"\"\"Sets the frequency of the local oscillator object\"\"\"\n        if self.local_oscillator is None:\n            raise AttributeError(\n                f\"Unable to set LO frequency for {self} as it has no local oscillator\"\n            )\n\n        # Use set_at_reference to ensure the frequency is updated, even if the local\n        # oscillator frequency is a reference\n        self.local_oscillator.set_at_reference(\"frequency\", value)\n\n    def configure(self):\n        if self.local_oscillator is not None:\n            self.local_oscillator.configure()\n</code></pre>"},{"location":"API_references/components/hardware_API/#quam.components.hardware.LocalOscillator","title":"<code>LocalOscillator</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for a local oscillator.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>The frequency of the local oscillator. Used by the mixer to determine the intermediate frequency.</p> required <code>power</code> <code>float</code> <p>The power of the local oscillator. Not used for the QUA configuration</p> required Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass LocalOscillator(QuamComponent):\n    \"\"\"QUAM component for a local oscillator.\n\n    Args:\n        frequency (float): The frequency of the local oscillator.\n            Used by the mixer to determine the intermediate frequency.\n        power (float, optional): The power of the local oscillator.\n            Not used for the QUA configuration\n    \"\"\"\n\n    frequency: float = None\n    power: float = None\n\n    def configure(self): ...\n</code></pre>"},{"location":"API_references/components/hardware_API/#quam.components.hardware.Mixer","title":"<code>Mixer</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for a mixer.</p> <p>All properties are optional, so it can be instantiated as <code>Mixer()</code>. For the default values, it is assumed that the mixer parent is an <code>IQChannel</code> that has a <code>LocalOscillator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>local_oscillator_frequency</code> <code>float</code> <p>The frequency of the local oscillator. Default is <code>#../local_oscillator/frequency</code>, meaning that the frequency is extracted from the the local_oscillator of the parent.</p> required <code>intermediate_frequency</code> <code>float</code> <p>The intermediate frequency of the mixer. Default is <code>#../intermediate_frequency</code>, meaning that the frequency references the intermediate_frequency of the parent.</p> required <code>correction_gain</code> <code>float</code> <p>The gain imbalance of the mixer. Default is 0, see <code>Mixer.IQ_imbalance</code> for details.</p> required <code>correction_phase</code> <code>float</code> <p>The phase imbalance of the mixer in radians.</p> required Source code in <code>quam/components/hardware.py</code> <pre><code>@quam_dataclass\nclass Mixer(QuamComponent):\n    \"\"\"QUAM component for a mixer.\n\n    All properties are optional, so it can be instantiated as `Mixer()`.\n    For the default values, it is assumed that the mixer parent is an `IQChannel`\n    that has a `LocalOscillator`.\n\n    Args:\n        local_oscillator_frequency (float, optional): The frequency of the local\n            oscillator. Default is `#../local_oscillator/frequency`, meaning that\n            the frequency is extracted from the the local_oscillator of the parent.\n        intermediate_frequency (float, optional): The intermediate frequency of the\n            mixer. Default is `#../intermediate_frequency`, meaning that the frequency\n            references the intermediate_frequency of the parent.\n        correction_gain (float, optional): The gain imbalance of the mixer.\n            Default is 0, see `Mixer.IQ_imbalance` for details.\n        correction_phase (float, optional): The phase imbalance of the mixer in radians.\n    \"\"\"\n\n    local_oscillator_frequency: float = \"#../local_oscillator/frequency\"\n    intermediate_frequency: float = \"#../../intermediate_frequency\"\n\n    correction_gain: float = 0\n    correction_phase: float = 0\n\n    @property\n    def name(self):\n        frequency_converter = getattr(self, \"parent\", None)\n        if frequency_converter is None:\n            raise AttributeError(\n                f\"Mixer.parent must be a frequency converter for {self}\"\n            )\n\n        channel = getattr(frequency_converter, \"parent\", None)\n        channel_name = getattr(channel, \"name\", None)\n        if channel is None or channel_name is None:\n            raise AttributeError(f\"Mixer.parent.parent must be a channel for {self}\")\n\n        return f\"{channel_name}{str_ref.DELIMITER}mixer\"\n\n    def apply_to_config(self, config: dict):\n        \"\"\"Adds this mixer to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        correction_matrix = self.IQ_imbalance(\n            self.correction_gain, self.correction_phase\n        )\n\n        config[\"mixers\"][self.name] = [\n            {\n                \"intermediate_frequency\": self.intermediate_frequency,\n                \"lo_frequency\": self.local_oscillator_frequency,\n                \"correction\": correction_matrix,\n            }\n        ]\n\n    @staticmethod\n    def IQ_imbalance(g: float, phi: float) -&gt; List[float]:\n        \"\"\"\n        Creates the correction matrix for the mixer imbalance caused by the gain and\n        phase imbalances, more information can be seen here:\n        https://docs.qualang.io/libs/examples/mixer-calibration/#non-ideal-mixer\n        :param g: relative gain imbalance between the I &amp; Q ports. (unit-less),\n            set to 0 for no gain imbalance.\n        :param phi: relative phase imbalance between the I &amp; Q ports (radians),\n            set to 0 for no phase imbalance.\n        \"\"\"\n        c = np.cos(phi)\n        s = np.sin(phi)\n        N = 1 / ((1 - g**2) * (2 * c**2 - 1))\n        return [\n            float(N * x) for x in [(1 - g) * c, (1 + g) * s, (1 - g) * s, (1 + g) * c]\n        ]\n</code></pre>"},{"location":"API_references/components/hardware_API/#quam.components.hardware.Mixer.IQ_imbalance","title":"<code>IQ_imbalance(g, phi)</code>  <code>staticmethod</code>","text":"<p>Creates the correction matrix for the mixer imbalance caused by the gain and phase imbalances, more information can be seen here: https://docs.qualang.io/libs/examples/mixer-calibration/#non-ideal-mixer :param g: relative gain imbalance between the I &amp; Q ports. (unit-less),     set to 0 for no gain imbalance. :param phi: relative phase imbalance between the I &amp; Q ports (radians),     set to 0 for no phase imbalance.</p> Source code in <code>quam/components/hardware.py</code> <pre><code>@staticmethod\ndef IQ_imbalance(g: float, phi: float) -&gt; List[float]:\n    \"\"\"\n    Creates the correction matrix for the mixer imbalance caused by the gain and\n    phase imbalances, more information can be seen here:\n    https://docs.qualang.io/libs/examples/mixer-calibration/#non-ideal-mixer\n    :param g: relative gain imbalance between the I &amp; Q ports. (unit-less),\n        set to 0 for no gain imbalance.\n    :param phi: relative phase imbalance between the I &amp; Q ports (radians),\n        set to 0 for no phase imbalance.\n    \"\"\"\n    c = np.cos(phi)\n    s = np.sin(phi)\n    N = 1 / ((1 - g**2) * (2 * c**2 - 1))\n    return [\n        float(N * x) for x in [(1 - g) * c, (1 + g) * s, (1 - g) * s, (1 + g) * c]\n    ]\n</code></pre>"},{"location":"API_references/components/hardware_API/#quam.components.hardware.Mixer.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this mixer to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/hardware.py</code> <pre><code>def apply_to_config(self, config: dict):\n    \"\"\"Adds this mixer to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    correction_matrix = self.IQ_imbalance(\n        self.correction_gain, self.correction_phase\n    )\n\n    config[\"mixers\"][self.name] = [\n        {\n            \"intermediate_frequency\": self.intermediate_frequency,\n            \"lo_frequency\": self.local_oscillator_frequency,\n            \"correction\": correction_matrix,\n        }\n    ]\n</code></pre>"},{"location":"API_references/components/macro_API/","title":"QUAM Macro API","text":"<p>Welcome to the QUAM Macro API Documentation. The QUAM Macro module provides pre-built macro operations for common quantum gate sequences on qubits and qubit pairs. Information can be found in QUAM Gate-Level Operations Documentation in the User Guide.</p> <p>This section provides detailed API references for macro operations\u2014high-level functions that encapsulate common quantum operations and gate sequences\u2014simplifying the implementation of complex quantum experiments.</p> Advanced: Core Macro Infrastructure <p>For creating custom macro types or understanding the underlying macro system, see the core macro classes:</p> <ul> <li>BaseMacro - Base class for all macros</li> <li>QuamMacro - Base class for QUAM component macros</li> <li>method_macro - Decorator for exposing methods as macros</li> </ul>"},{"location":"API_references/components/macro_API/#quam.components.macro.PulseMacro","title":"<code>PulseMacro</code>","text":"<p>               Bases: <code>QubitMacro</code></p> <p>Single-qubit gate for a qubit consisting of a single pulse</p> <p>Parameters:</p> Name Type Description Default <code>pulse</code> <p>Name of pulse to be played on qubit. Should be a key in <code>channel.operations</code> for one of the qubit's channels</p> required Source code in <code>quam/components/macro/qubit_macros.py</code> <pre><code>@quam_dataclass\nclass PulseMacro(QubitMacro):\n    \"\"\"Single-qubit gate for a qubit consisting of a single pulse\n\n    Args:\n        pulse: Name of pulse to be played on qubit. Should be a key in\n            `channel.operations` for one of the qubit's channels\n    \"\"\"\n\n    pulse: Union[Pulse, str]  # type: ignore\n\n    def apply(self, *, amplitude_scale=None, duration=None, **kwargs):\n        if isinstance(self.pulse, Pulse):\n            pulse = self.pulse\n        else:\n            pulse = self.qubit.get_pulse(self.pulse)\n        pulse.play(\n            amplitude_scale=amplitude_scale, duration=duration, **kwargs  # type: ignore\n        )\n\n    @property\n    def inferred_duration(self) -&gt; float:\n        if isinstance(self.pulse, Pulse):\n            return self.pulse.length * 1e-9\n        else:\n            return self.qubit.get_pulse(self.pulse).length * 1e-9\n</code></pre>"},{"location":"API_references/components/macro_API/#quam.components.macro.QubitMacro","title":"<code>QubitMacro</code>","text":"<p>               Bases: <code>QuamMacro</code>, <code>ABC</code></p> Source code in <code>quam/components/macro/qubit_macros.py</code> <pre><code>@quam_dataclass\nclass QubitMacro(QuamMacro, ABC):\n    @property\n    def qubit(self):\n        from quam.components.quantum_components.qubit import Qubit\n\n        if isinstance(self.parent, Qubit):\n            return self.parent\n        elif hasattr(self.parent, \"parent\") and isinstance(self.parent.parent, Qubit):\n            return self.parent.parent\n        else:\n            raise AttributeError(\"QubitOperation is not attached to a qubit: {self}\")\n</code></pre>"},{"location":"API_references/components/macro_API/#quam.components.macro.QubitPairMacro","title":"<code>QubitPairMacro</code>","text":"<p>               Bases: <code>QuamMacro</code>, <code>ABC</code></p> Source code in <code>quam/components/macro/qubit_pair_macros.py</code> <pre><code>@quam_dataclass\nclass QubitPairMacro(QuamMacro, ABC):\n    @property\n    def qubit_pair(self):  # TODO Add QubitPair return type\n        from quam.components.quantum_components.qubit_pair import QubitPair\n\n        if isinstance(self.parent, QubitPair):\n            return self.parent\n        elif hasattr(self.parent, \"parent\") and isinstance(\n            self.parent.parent, QubitPair\n        ):\n            return self.parent.parent\n        else:\n            raise AttributeError(\n                \"TwoQubitGate is not attached to a QubitPair. 2Q_gate: {self}\"\n            )\n\n    @property\n    def qubit_control(self) -&gt; Qubit:\n        return self.qubit_pair.qubit_control\n\n    @property\n    def qubit_target(self) -&gt; Qubit:\n        return self.qubit_pair.qubit_target\n</code></pre>"},{"location":"API_references/components/octave/","title":"Octave","text":""},{"location":"API_references/components/octave/#quam.components.octave.Octave","title":"<code>Octave</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for the QM Octave.</p> <p>The QM Octave is a device that can be used to upconvert and downconvert signals. It has 5 RF outputs and 2 RF inputs. Each RF_output has an associated <code>OctaveUpConverter</code>, and similarly each RF_input has an <code>OctaveDownConverter</code>.</p> <p>In many cases the Octave is connected to a single OPX in the default configuration, i.e. OPX outputs are connected to the corresponding Octave I/Q input, and Octave IF outputs are connected to the corresponding OPX input. In this case you can configure the Octave with the correct <code>FrequencyConverter</code>s using <code>Octave.initialize_default_connectivity()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The name of the Octave. Must be unique</p> required <code>calibration_db_path</code> <p>The path to the calibration database. If not specified, the current working directory is used.</p> required <code>RF_outputs</code> <p>A dictionary of <code>OctaveUpConverter</code> objects. The keys are the output numbers (1-5).</p> required <code>RF_inputs</code> <p>A dictionary of <code>OctaveDownConverter</code> objects. The keys are the input numbers (1-2).</p> required <code>loopbacks</code> <p>A list of loopback connections, for example to connect a local oscillator. See the QUA Octave documentation for details.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass Octave(QuamComponent):\n    \"\"\"QUAM component for the QM Octave.\n\n    The QM Octave is a device that can be used to upconvert and downconvert signals. It\n    has 5 RF outputs and 2 RF inputs. Each RF_output has an associated\n    `OctaveUpConverter`, and similarly each RF_input has an `OctaveDownConverter`.\n\n    In many cases the Octave is connected to a single OPX in the default configuration,\n    i.e. OPX outputs are connected to the corresponding Octave I/Q input, and Octave IF\n    outputs are connected to the corresponding OPX input. In this case you can configure\n    the Octave with the correct `FrequencyConverter`s using\n    `Octave.initialize_default_connectivity()`.\n\n    Args:\n        name: The name of the Octave. Must be unique\n        calibration_db_path: The path to the calibration database. If not specified, the\n            current working directory is used.\n        RF_outputs: A dictionary of `OctaveUpConverter` objects. The keys are the\n            output numbers (1-5).\n        RF_inputs: A dictionary of `OctaveDownConverter` objects. The keys are the\n            input numbers (1-2).\n        loopbacks: A list of loopback connections, for example to connect a local\n            oscillator. See the QUA Octave documentation for details.\n    \"\"\"\n\n    name: str\n    calibration_db_path: str = None\n\n    RF_outputs: Dict[int, \"OctaveUpConverter\"] = field(default_factory=dict)\n    RF_inputs: Dict[int, \"OctaveDownConverter\"] = field(default_factory=dict)\n    loopbacks: List[Tuple[Tuple[str, str], str]] = field(default_factory=list)\n\n    def initialize_frequency_converters(self):\n        \"\"\"Initialize the Octave frequency converterswith default connectivity.\n\n        This method initializes the Octave with default connectivity, i.e. it connects\n        the Octave to a single OPX. It creates an `OctaveUpConverter` for each RF output\n        and an `OctaveDownConverter` for each RF input. The `OctaveUpConverter` objects\n        are added to `Octave.RF_outputs` and the `OctaveDownConverter` objects are added\n        to `Octave.RF_inputs`.\n\n        Raises:\n            ValueError: If the Octave already has RF_outputs or RF_inputs.\n\n        \"\"\"\n        if self.RF_outputs:\n            raise ValueError(\n                \"Error initializing Octave with default connectivity. \"\n                \"octave.RF_outputs is not empty\"\n            )\n        if self.RF_inputs:\n            raise ValueError(\n                \"Error initializing Octave with default connectivity. \"\n                \"octave.IF_outputs is not empty\"\n            )\n\n        for idx in range(1, 6):\n            self.RF_outputs[idx] = OctaveUpConverter(\n                id=idx,\n                LO_frequency=None,  # TODO What should default be?\n            )\n\n        for idx in range(1, 3):\n            LO_source = \"internal\" if idx == 1 else \"external\"\n            self.RF_inputs[idx] = OctaveDownConverter(\n                id=idx, LO_frequency=None, LO_source=LO_source\n            )\n\n    def get_octave_config(self) -&gt; QmOctaveConfig:\n        \"\"\"Return a QmOctaveConfig object with the current Octave configuration.\"\"\"\n        octave_config = QmOctaveConfig()\n\n        if self.calibration_db_path is not None:\n            octave_config.set_calibration_db(self.calibration_db_path)\n        else:\n            octave_config.set_calibration_db(os.getcwd())\n\n        return octave_config\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add the Octave configuration to a config dictionary.\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            KeyError: If the Octave is already in the config.\n        \"\"\"\n        if \"octaves\" not in config:\n            config[\"octaves\"] = {}\n        if self.name in config[\"octaves\"]:\n            raise KeyError(\n                f'Error generating config: config[\"octaves\"] already contains an entry '\n                f' for Octave \"{self.name}\"'\n            )\n\n        config[\"octaves\"][self.name] = {\n            \"RF_outputs\": {},\n            \"IF_outputs\": {},\n            \"RF_inputs\": {},\n            \"loopbacks\": list(self.loopbacks),\n        }\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.Octave.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add the Octave configuration to a config dictionary.</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the Octave is already in the config.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add the Octave configuration to a config dictionary.\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        KeyError: If the Octave is already in the config.\n    \"\"\"\n    if \"octaves\" not in config:\n        config[\"octaves\"] = {}\n    if self.name in config[\"octaves\"]:\n        raise KeyError(\n            f'Error generating config: config[\"octaves\"] already contains an entry '\n            f' for Octave \"{self.name}\"'\n        )\n\n    config[\"octaves\"][self.name] = {\n        \"RF_outputs\": {},\n        \"IF_outputs\": {},\n        \"RF_inputs\": {},\n        \"loopbacks\": list(self.loopbacks),\n    }\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.Octave.get_octave_config","title":"<code>get_octave_config()</code>","text":"<p>Return a QmOctaveConfig object with the current Octave configuration.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def get_octave_config(self) -&gt; QmOctaveConfig:\n    \"\"\"Return a QmOctaveConfig object with the current Octave configuration.\"\"\"\n    octave_config = QmOctaveConfig()\n\n    if self.calibration_db_path is not None:\n        octave_config.set_calibration_db(self.calibration_db_path)\n    else:\n        octave_config.set_calibration_db(os.getcwd())\n\n    return octave_config\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.Octave.initialize_frequency_converters","title":"<code>initialize_frequency_converters()</code>","text":"<p>Initialize the Octave frequency converterswith default connectivity.</p> <p>This method initializes the Octave with default connectivity, i.e. it connects the Octave to a single OPX. It creates an <code>OctaveUpConverter</code> for each RF output and an <code>OctaveDownConverter</code> for each RF input. The <code>OctaveUpConverter</code> objects are added to <code>Octave.RF_outputs</code> and the <code>OctaveDownConverter</code> objects are added to <code>Octave.RF_inputs</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Octave already has RF_outputs or RF_inputs.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def initialize_frequency_converters(self):\n    \"\"\"Initialize the Octave frequency converterswith default connectivity.\n\n    This method initializes the Octave with default connectivity, i.e. it connects\n    the Octave to a single OPX. It creates an `OctaveUpConverter` for each RF output\n    and an `OctaveDownConverter` for each RF input. The `OctaveUpConverter` objects\n    are added to `Octave.RF_outputs` and the `OctaveDownConverter` objects are added\n    to `Octave.RF_inputs`.\n\n    Raises:\n        ValueError: If the Octave already has RF_outputs or RF_inputs.\n\n    \"\"\"\n    if self.RF_outputs:\n        raise ValueError(\n            \"Error initializing Octave with default connectivity. \"\n            \"octave.RF_outputs is not empty\"\n        )\n    if self.RF_inputs:\n        raise ValueError(\n            \"Error initializing Octave with default connectivity. \"\n            \"octave.IF_outputs is not empty\"\n        )\n\n    for idx in range(1, 6):\n        self.RF_outputs[idx] = OctaveUpConverter(\n            id=idx,\n            LO_frequency=None,  # TODO What should default be?\n        )\n\n    for idx in range(1, 3):\n        LO_source = \"internal\" if idx == 1 else \"external\"\n        self.RF_inputs[idx] = OctaveDownConverter(\n            id=idx, LO_frequency=None, LO_source=LO_source\n        )\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveDownConverter","title":"<code>OctaveDownConverter</code>","text":"<p>               Bases: <code>OctaveFrequencyConverter</code></p> <p>A frequency downconverter for the QM Octave.</p> <p>The OctaveDownConverter represents a frequency downconverter in the QM Octave. The OctaveDownConverter is usually connected to an InOutIQChannel, in which case the two OPX inputs are connected to the IF outputs of the OctaveDownConverter. The OPX inputs are specified in the <code>OctaveDownConverter.channel</code> attribute. The channel is either an InOutIQChannel or an InOutSingleChannel.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The RF input id, must be between 1-2.</p> required <code>LO_frequency</code> <p>The local oscillator frequency in Hz, between 2 and 18 GHz.</p> required <code>LO_source</code> <p>The local oscillator source, \"internal\" or \"external. For down converter 1 \"internal\" is the default, for down converter 2 \"external\" is the default.</p> required <code>IF_mode_I</code> <p>Sets the mode of the I port of the IF Down Converter module as can be seen in the octave block diagram (see Octave page in QUA documentation). Can be \"direct\" / \"envelope\" / \"mixer\" / \"off\". The default is \"direct\". - \"direct\" - The signal bypasses the IF module. - \"envelope\" - The signal passes through an envelope detector. - \"mixer\" - The signal passes through a low-frequency mixer. - \"off\" - the signal doesn't pass to the output port.</p> required <code>IF_mode_Q</code> <p>Sets the mode of the Q port of the IF Down Converter module.</p> required <code>IF_output_I</code> <p>The output port of the IF Down Converter module for the I port. Can be 1 or 2. The default is 1. This will be 2 if the IF outputs are connected to the opposite OPX inputs</p> required <code>IF_output_Q</code> <p>The output port of the IF Down Converter module for the Q port. Can be 1 or 2. The default is 2. This will be 1 if the IF outputs are connected to the opposite OPX inputs.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass OctaveDownConverter(OctaveFrequencyConverter):\n    \"\"\"A frequency downconverter for the QM Octave.\n\n    The OctaveDownConverter represents a frequency downconverter in the QM Octave. The\n    OctaveDownConverter is usually connected to an InOutIQChannel, in which case the\n    two OPX inputs are connected to the IF outputs of the OctaveDownConverter. The\n    OPX inputs are specified in the `OctaveDownConverter.channel` attribute. The\n    channel is either an InOutIQChannel or an InOutSingleChannel.\n\n    Args:\n        id: The RF input id, must be between 1-2.\n        LO_frequency: The local oscillator frequency in Hz, between 2 and 18 GHz.\n        LO_source: The local oscillator source, \"internal\" or \"external.\n            For down converter 1 \"internal\" is the default,\n            for down converter 2 \"external\" is the default.\n        IF_mode_I: Sets the mode of the I port of the IF Down Converter module as can be\n            seen in the octave block diagram (see Octave page in QUA documentation).\n            Can be \"direct\" / \"envelope\" / \"mixer\" / \"off\". The default is \"direct\".\n            - \"direct\" - The signal bypasses the IF module.\n            - \"envelope\" - The signal passes through an envelope detector.\n            - \"mixer\" - The signal passes through a low-frequency mixer.\n            - \"off\" - the signal doesn't pass to the output port.\n        IF_mode_Q: Sets the mode of the Q port of the IF Down Converter module.\n        IF_output_I: The output port of the IF Down Converter module for the I port.\n            Can be 1 or 2. The default is 1. This will be 2 if the IF outputs\n            are connected to the opposite OPX inputs\n        IF_output_Q: The output port of the IF Down Converter module for the Q port.\n            Can be 1 or 2. The default is 2. This will be 1 if the IF outputs\n            are connected to the opposite OPX inputs.\n    \"\"\"\n\n    LO_frequency: float = None\n    LO_source: Literal[\"internal\", \"external\"] = \"internal\"\n    IF_mode_I: Literal[\"direct\", \"envelope\", \"mixer\", \"off\"] = \"direct\"\n    IF_mode_Q: Literal[\"direct\", \"envelope\", \"mixer\", \"off\"] = \"direct\"\n    IF_output_I: Literal[1, 2] = 1\n    IF_output_Q: Literal[1, 2] = 2\n\n    @property\n    def config_settings(self):\n        \"\"\"Specifies that the converter will be added to the config after the Octave.\"\"\"\n        return {\"after\": [self.octave]}\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add information about the frequency down-converter to the QUA config\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Nothing is added to the config if the `OctaveDownConverter.channel` is not\n        specified or if the `OctaveDownConverter.LO_frequency` is not specified.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            ValueError: If the LO_frequency is not specified.\n            KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n                not exist.\n            KeyError: If the Octave already has an entry for the OctaveDownConverter.\n            ValueError: If the IF_output_I and IF_output_Q are already assigned to\n                other ports.\n        \"\"\"\n        if not isinstance(self.LO_frequency, (int, float)):\n            if self.channel is None:\n                return\n            else:\n                raise ValueError(\n                    f\"Error generating config for Octave upconverter id={self.id}: \"\n                    \"LO_frequency must be specified.\"\n                )\n\n        super().apply_to_config(config)\n\n        if self.id in config[\"octaves\"][self.octave.name][\"RF_inputs\"]:\n            raise KeyError(\n                f\"Error generating config: \"\n                f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_inputs\"] '\n                f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n            )\n\n        config[\"octaves\"][self.octave.name][\"RF_inputs\"][self.id] = {\n            \"RF_source\": \"RF_in\",\n            \"LO_frequency\": self.LO_frequency,\n            \"LO_source\": self.LO_source,\n            \"IF_mode_I\": self.IF_mode_I,\n            \"IF_mode_Q\": self.IF_mode_Q,\n        }\n\n        if isinstance(self.channel, InOutIQChannel):\n            IF_channels = [self.IF_output_I, self.IF_output_Q]\n            opx_channels = [self.channel.opx_input_I, self.channel.opx_input_Q]\n        elif isinstance(self.channel, InOutSingleChannel):\n            IF_channels = [self.IF_output_I]\n            opx_channels = [self.channel.opx_input]\n        else:\n            IF_channels = []\n            opx_channels = []\n\n        opx_port_tuples = [\n            p.port_tuple if isinstance(p, BasePort) else tuple(p) for p in opx_channels\n        ]\n\n        IF_config = config[\"octaves\"][self.octave.name][\"IF_outputs\"]\n        for k, (IF_ch, opx_port_tuples) in enumerate(\n            zip(IF_channels, opx_port_tuples), start=1\n        ):\n            label = f\"IF_out{IF_ch}\"\n            IF_config.setdefault(label, {\"port\": opx_port_tuples, \"name\": f\"out{k}\"})\n            if IF_config[label][\"port\"] != opx_port_tuples:\n                raise ValueError(\n                    f\"Error generating config for Octave downconverter id={self.id}: \"\n                    f\"Unable to assign {label} to  port {opx_port_tuples} because it is already \"\n                    f\"assigned to port {IF_config[label]['port']} \"\n                )\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveDownConverter.config_settings","title":"<code>config_settings</code>  <code>property</code>","text":"<p>Specifies that the converter will be added to the config after the Octave.</p>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveDownConverter.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information about the frequency down-converter to the QUA config</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Nothing is added to the config if the <code>OctaveDownConverter.channel</code> is not specified or if the <code>OctaveDownConverter.LO_frequency</code> is not specified.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the LO_frequency is not specified.</p> <code>KeyError</code> <p>If the Octave is not in the config, or if config[\"octaves\"] does not exist.</p> <code>KeyError</code> <p>If the Octave already has an entry for the OctaveDownConverter.</p> <code>ValueError</code> <p>If the IF_output_I and IF_output_Q are already assigned to other ports.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add information about the frequency down-converter to the QUA config\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Nothing is added to the config if the `OctaveDownConverter.channel` is not\n    specified or if the `OctaveDownConverter.LO_frequency` is not specified.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        ValueError: If the LO_frequency is not specified.\n        KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n            not exist.\n        KeyError: If the Octave already has an entry for the OctaveDownConverter.\n        ValueError: If the IF_output_I and IF_output_Q are already assigned to\n            other ports.\n    \"\"\"\n    if not isinstance(self.LO_frequency, (int, float)):\n        if self.channel is None:\n            return\n        else:\n            raise ValueError(\n                f\"Error generating config for Octave upconverter id={self.id}: \"\n                \"LO_frequency must be specified.\"\n            )\n\n    super().apply_to_config(config)\n\n    if self.id in config[\"octaves\"][self.octave.name][\"RF_inputs\"]:\n        raise KeyError(\n            f\"Error generating config: \"\n            f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_inputs\"] '\n            f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n        )\n\n    config[\"octaves\"][self.octave.name][\"RF_inputs\"][self.id] = {\n        \"RF_source\": \"RF_in\",\n        \"LO_frequency\": self.LO_frequency,\n        \"LO_source\": self.LO_source,\n        \"IF_mode_I\": self.IF_mode_I,\n        \"IF_mode_Q\": self.IF_mode_Q,\n    }\n\n    if isinstance(self.channel, InOutIQChannel):\n        IF_channels = [self.IF_output_I, self.IF_output_Q]\n        opx_channels = [self.channel.opx_input_I, self.channel.opx_input_Q]\n    elif isinstance(self.channel, InOutSingleChannel):\n        IF_channels = [self.IF_output_I]\n        opx_channels = [self.channel.opx_input]\n    else:\n        IF_channels = []\n        opx_channels = []\n\n    opx_port_tuples = [\n        p.port_tuple if isinstance(p, BasePort) else tuple(p) for p in opx_channels\n    ]\n\n    IF_config = config[\"octaves\"][self.octave.name][\"IF_outputs\"]\n    for k, (IF_ch, opx_port_tuples) in enumerate(\n        zip(IF_channels, opx_port_tuples), start=1\n    ):\n        label = f\"IF_out{IF_ch}\"\n        IF_config.setdefault(label, {\"port\": opx_port_tuples, \"name\": f\"out{k}\"})\n        if IF_config[label][\"port\"] != opx_port_tuples:\n            raise ValueError(\n                f\"Error generating config for Octave downconverter id={self.id}: \"\n                f\"Unable to assign {label} to  port {opx_port_tuples} because it is already \"\n                f\"assigned to port {IF_config[label]['port']} \"\n            )\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveFrequencyConverter","title":"<code>OctaveFrequencyConverter</code>","text":"<p>               Bases: <code>BaseFrequencyConverter</code>, <code>ABC</code></p> <p>Base class for OctaveUpConverter and OctaveDownConverter.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The id of the converter. Must be unique within the Octave. For OctaveUpConverter, the id is used as the RF output number. For OctaveDownConverter, the id is used as the RF input number.</p> required <code>channel</code> <p>The channel that the converter is connected to.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass OctaveFrequencyConverter(BaseFrequencyConverter, ABC):\n    \"\"\"Base class for OctaveUpConverter and OctaveDownConverter.\n\n    Args:\n        id: The id of the converter. Must be unique within the Octave.\n            For OctaveUpConverter, the id is used as the RF output number.\n            For OctaveDownConverter, the id is used as the RF input number.\n        channel: The channel that the converter is connected to.\n    \"\"\"\n\n    id: int\n    channel: Channel = None\n\n    @property\n    def octave(self) -&gt; Optional[Octave]:\n        if self.parent is None:\n            return None\n        parent_parent = getattr(self.parent, \"parent\")\n        if not isinstance(parent_parent, Octave):\n            return None\n        return parent_parent\n\n    @property\n    def config_settings(self) -&gt; Dict[str, Any]:\n        \"\"\"Specifies that the converter will be added to the config after the Octave.\"\"\"\n        return {\"after\": [self.octave]}\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add information about the frequency converter to the QUA config\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n                not exist.\n        \"\"\"\n        super().apply_to_config(config)\n\n        if \"octaves\" not in config:\n            raise KeyError('Error generating config: \"octaves\" entry not found')\n\n        if self.octave is None:\n            raise KeyError(\n                f\"Error generating config: OctaveConverter with id {self.id} does not \"\n                \"have an Octave parent\"\n            )\n\n        if self.octave.name not in config[\"octaves\"]:\n            raise KeyError(\n                'Error generating config: config[\"octaves\"] does not have Octave'\n                f' entry config[\"octaves\"][\"{self.octave.name}\"]'\n            )\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveFrequencyConverter.config_settings","title":"<code>config_settings</code>  <code>property</code>","text":"<p>Specifies that the converter will be added to the config after the Octave.</p>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveFrequencyConverter.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information about the frequency converter to the QUA config</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the Octave is not in the config, or if config[\"octaves\"] does not exist.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add information about the frequency converter to the QUA config\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n            not exist.\n    \"\"\"\n    super().apply_to_config(config)\n\n    if \"octaves\" not in config:\n        raise KeyError('Error generating config: \"octaves\" entry not found')\n\n    if self.octave is None:\n        raise KeyError(\n            f\"Error generating config: OctaveConverter with id {self.id} does not \"\n            \"have an Octave parent\"\n        )\n\n    if self.octave.name not in config[\"octaves\"]:\n        raise KeyError(\n            'Error generating config: config[\"octaves\"] does not have Octave'\n            f' entry config[\"octaves\"][\"{self.octave.name}\"]'\n        )\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveUpConverter","title":"<code>OctaveUpConverter</code>","text":"<p>               Bases: <code>OctaveFrequencyConverter</code></p> <p>A frequency upconverter for the QM Octave.</p> <p>The OctaveUpConverter represents a frequency upconverter in the QM Octave. Usually an IQChannel is connected <code>OctaveUpconverter.channel</code>, in which case the two OPX outputs are connected to the I and Q inputs of the OctaveUpConverter. The OPX outputs are specified in the <code>OctaveUpConverter.channel</code> attribute. The channel is either an IQChannel or a SingleChannel.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The RF output id, must be between 1-5.</p> required <code>LO_frequency</code> <p>The local oscillator frequency in Hz, between 2 and 18 GHz.</p> required <code>LO_source</code> <p>The local oscillator source, \"internal\" (default) or \"external\".</p> required <code>gain</code> <p>The gain of the output, between -20 and 20 dB in steps of 0.5. Default is 0 dB.</p> required <code>output_mode</code> <p>Sets the fast switch's mode of the up converter module. Can be \"always_on\" / \"always_off\" / \"triggered\" / \"triggered_reversed\". The default is \"always_off\". - \"always_on\" - Output is always on - \"always_off\" - Output is always off - \"triggered\" - The output will play when rising edge is detected in the   octave's digital port. - \"triggered_reversed\" - The output will play when falling edge is detected   in the octave's digital port.</p> required <code>input_attenuators</code> <p>Whether the I and Q ports have a 10 dB attenuator before entering the mixer. Off by default.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass OctaveUpConverter(OctaveFrequencyConverter):\n    \"\"\"A frequency upconverter for the QM Octave.\n\n    The OctaveUpConverter represents a frequency upconverter in the QM Octave. Usually\n    an IQChannel is connected `OctaveUpconverter.channel`, in which case the two OPX\n    outputs are connected to the I and Q inputs of the OctaveUpConverter.\n    The OPX outputs are specified in the `OctaveUpConverter.channel` attribute.\n    The channel is either an IQChannel or a SingleChannel.\n\n    Args:\n        id: The RF output id, must be between 1-5.\n        LO_frequency: The local oscillator frequency in Hz, between 2 and 18 GHz.\n        LO_source: The local oscillator source, \"internal\" (default) or \"external\".\n        gain: The gain of the output, between -20 and 20 dB in steps of 0.5.\n            Default is 0 dB.\n        output_mode: Sets the fast switch's mode of the up converter module.\n            Can be \"always_on\" / \"always_off\" / \"triggered\" / \"triggered_reversed\".\n            The default is \"always_off\".\n            - \"always_on\" - Output is always on\n            - \"always_off\" - Output is always off\n            - \"triggered\" - The output will play when rising edge is detected in the\n              octave's digital port.\n            - \"triggered_reversed\" - The output will play when falling edge is detected\n              in the octave's digital port.\n        input_attenuators: Whether the I and Q ports have a 10 dB attenuator before\n            entering the mixer. Off by default.\n    \"\"\"\n\n    LO_frequency: float = None\n    LO_source: Literal[\"internal\", \"external\"] = \"internal\"\n    gain: float = 0\n    output_mode: Literal[\n        \"always_on\", \"always_off\", \"triggered\", \"triggered_reversed\"\n    ] = \"always_off\"\n    input_attenuators: Literal[\"off\", \"on\"] = \"off\"\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add information about the frequency up-converter to the QUA config\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Nothing is added to the config if the `OctaveUpConverter.channel` is not\n        specified or if the `OctaveUpConverter.LO_frequency` is not specified.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            ValueError: If the LO_frequency is not specified.\n            KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n                not exist.\n            KeyError: If the Octave already has an entry for the OctaveUpConverter.\n        \"\"\"\n        if not isinstance(self.LO_frequency, (int, float)):\n            if self.channel is None:\n                return\n            else:\n                raise ValueError(\n                    f\"Error generating config for Octave upconverter id={self.id}: \"\n                    \"LO_frequency must be specified.\"\n                )\n\n        super().apply_to_config(config)\n\n        if self.id in config[\"octaves\"][self.octave.name][\"RF_outputs\"]:\n            raise KeyError(\n                f\"Error generating config: \"\n                f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_outputs\"] '\n                f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n            )\n\n        output_config = config[\"octaves\"][self.octave.name][\"RF_outputs\"][self.id] = {\n            \"LO_frequency\": self.LO_frequency,\n            \"LO_source\": self.LO_source,\n            \"gain\": self.gain,\n            \"output_mode\": self.output_mode,\n            \"input_attenuators\": self.input_attenuators,\n        }\n        if isinstance(self.channel, SingleChannel):\n            if isinstance(self.channel.opx_output, LFAnalogOutputPort):\n                output_config[\"I_connection\"] = self.channel.opx_output.port_tuple\n            else:\n                output_config[\"I_connection\"] = self.channel.opx_output\n        elif isinstance(self.channel, IQChannel):\n            if isinstance(self.channel.opx_output_I, LFAnalogOutputPort):\n                output_config[\"I_connection\"] = self.channel.opx_output_I.port_tuple\n            else:\n                output_config[\"I_connection\"] = tuple(self.channel.opx_output_I)\n            if isinstance(self.channel.opx_output_Q, LFAnalogOutputPort):\n                output_config[\"Q_connection\"] = self.channel.opx_output_Q.port_tuple\n            else:\n                output_config[\"Q_connection\"] = tuple(self.channel.opx_output_Q)\n</code></pre>"},{"location":"API_references/components/octave/#quam.components.octave.OctaveUpConverter.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information about the frequency up-converter to the QUA config</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Nothing is added to the config if the <code>OctaveUpConverter.channel</code> is not specified or if the <code>OctaveUpConverter.LO_frequency</code> is not specified.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the LO_frequency is not specified.</p> <code>KeyError</code> <p>If the Octave is not in the config, or if config[\"octaves\"] does not exist.</p> <code>KeyError</code> <p>If the Octave already has an entry for the OctaveUpConverter.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add information about the frequency up-converter to the QUA config\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Nothing is added to the config if the `OctaveUpConverter.channel` is not\n    specified or if the `OctaveUpConverter.LO_frequency` is not specified.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        ValueError: If the LO_frequency is not specified.\n        KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n            not exist.\n        KeyError: If the Octave already has an entry for the OctaveUpConverter.\n    \"\"\"\n    if not isinstance(self.LO_frequency, (int, float)):\n        if self.channel is None:\n            return\n        else:\n            raise ValueError(\n                f\"Error generating config for Octave upconverter id={self.id}: \"\n                \"LO_frequency must be specified.\"\n            )\n\n    super().apply_to_config(config)\n\n    if self.id in config[\"octaves\"][self.octave.name][\"RF_outputs\"]:\n        raise KeyError(\n            f\"Error generating config: \"\n            f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_outputs\"] '\n            f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n        )\n\n    output_config = config[\"octaves\"][self.octave.name][\"RF_outputs\"][self.id] = {\n        \"LO_frequency\": self.LO_frequency,\n        \"LO_source\": self.LO_source,\n        \"gain\": self.gain,\n        \"output_mode\": self.output_mode,\n        \"input_attenuators\": self.input_attenuators,\n    }\n    if isinstance(self.channel, SingleChannel):\n        if isinstance(self.channel.opx_output, LFAnalogOutputPort):\n            output_config[\"I_connection\"] = self.channel.opx_output.port_tuple\n        else:\n            output_config[\"I_connection\"] = self.channel.opx_output\n    elif isinstance(self.channel, IQChannel):\n        if isinstance(self.channel.opx_output_I, LFAnalogOutputPort):\n            output_config[\"I_connection\"] = self.channel.opx_output_I.port_tuple\n        else:\n            output_config[\"I_connection\"] = tuple(self.channel.opx_output_I)\n        if isinstance(self.channel.opx_output_Q, LFAnalogOutputPort):\n            output_config[\"Q_connection\"] = self.channel.opx_output_Q.port_tuple\n        else:\n            output_config[\"Q_connection\"] = tuple(self.channel.opx_output_Q)\n</code></pre>"},{"location":"API_references/components/octave_API/","title":"Welcome to the QUAM Octave API Documentation","text":"<p>The Octave component in the Quantum Abstract Machine (QUAM) manages signal upconversion and downconversion through its frequency converters. This section provides an API guide for setting up and customizing the Octave, detailing its integration with quantum processors for efficient signal processing. Explore the capabilities, configuration options, and practical examples to enhance your quantum operations with Octave's advanced functionalities.</p>"},{"location":"API_references/components/octave_API/#quam.components.octave.Octave","title":"<code>Octave</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM component for the QM Octave.</p> <p>The QM Octave is a device that can be used to upconvert and downconvert signals. It has 5 RF outputs and 2 RF inputs. Each RF_output has an associated <code>OctaveUpConverter</code>, and similarly each RF_input has an <code>OctaveDownConverter</code>.</p> <p>In many cases the Octave is connected to a single OPX in the default configuration, i.e. OPX outputs are connected to the corresponding Octave I/Q input, and Octave IF outputs are connected to the corresponding OPX input. In this case you can configure the Octave with the correct <code>FrequencyConverter</code>s using <code>Octave.initialize_default_connectivity()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The name of the Octave. Must be unique</p> required <code>calibration_db_path</code> <p>The path to the calibration database. If not specified, the current working directory is used.</p> required <code>RF_outputs</code> <p>A dictionary of <code>OctaveUpConverter</code> objects. The keys are the output numbers (1-5).</p> required <code>RF_inputs</code> <p>A dictionary of <code>OctaveDownConverter</code> objects. The keys are the input numbers (1-2).</p> required <code>loopbacks</code> <p>A list of loopback connections, for example to connect a local oscillator. See the QUA Octave documentation for details.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass Octave(QuamComponent):\n    \"\"\"QUAM component for the QM Octave.\n\n    The QM Octave is a device that can be used to upconvert and downconvert signals. It\n    has 5 RF outputs and 2 RF inputs. Each RF_output has an associated\n    `OctaveUpConverter`, and similarly each RF_input has an `OctaveDownConverter`.\n\n    In many cases the Octave is connected to a single OPX in the default configuration,\n    i.e. OPX outputs are connected to the corresponding Octave I/Q input, and Octave IF\n    outputs are connected to the corresponding OPX input. In this case you can configure\n    the Octave with the correct `FrequencyConverter`s using\n    `Octave.initialize_default_connectivity()`.\n\n    Args:\n        name: The name of the Octave. Must be unique\n        calibration_db_path: The path to the calibration database. If not specified, the\n            current working directory is used.\n        RF_outputs: A dictionary of `OctaveUpConverter` objects. The keys are the\n            output numbers (1-5).\n        RF_inputs: A dictionary of `OctaveDownConverter` objects. The keys are the\n            input numbers (1-2).\n        loopbacks: A list of loopback connections, for example to connect a local\n            oscillator. See the QUA Octave documentation for details.\n    \"\"\"\n\n    name: str\n    calibration_db_path: str = None\n\n    RF_outputs: Dict[int, \"OctaveUpConverter\"] = field(default_factory=dict)\n    RF_inputs: Dict[int, \"OctaveDownConverter\"] = field(default_factory=dict)\n    loopbacks: List[Tuple[Tuple[str, str], str]] = field(default_factory=list)\n\n    def initialize_frequency_converters(self):\n        \"\"\"Initialize the Octave frequency converterswith default connectivity.\n\n        This method initializes the Octave with default connectivity, i.e. it connects\n        the Octave to a single OPX. It creates an `OctaveUpConverter` for each RF output\n        and an `OctaveDownConverter` for each RF input. The `OctaveUpConverter` objects\n        are added to `Octave.RF_outputs` and the `OctaveDownConverter` objects are added\n        to `Octave.RF_inputs`.\n\n        Raises:\n            ValueError: If the Octave already has RF_outputs or RF_inputs.\n\n        \"\"\"\n        if self.RF_outputs:\n            raise ValueError(\n                \"Error initializing Octave with default connectivity. \"\n                \"octave.RF_outputs is not empty\"\n            )\n        if self.RF_inputs:\n            raise ValueError(\n                \"Error initializing Octave with default connectivity. \"\n                \"octave.IF_outputs is not empty\"\n            )\n\n        for idx in range(1, 6):\n            self.RF_outputs[idx] = OctaveUpConverter(\n                id=idx,\n                LO_frequency=None,  # TODO What should default be?\n            )\n\n        for idx in range(1, 3):\n            LO_source = \"internal\" if idx == 1 else \"external\"\n            self.RF_inputs[idx] = OctaveDownConverter(\n                id=idx, LO_frequency=None, LO_source=LO_source\n            )\n\n    def get_octave_config(self) -&gt; QmOctaveConfig:\n        \"\"\"Return a QmOctaveConfig object with the current Octave configuration.\"\"\"\n        octave_config = QmOctaveConfig()\n\n        if self.calibration_db_path is not None:\n            octave_config.set_calibration_db(self.calibration_db_path)\n        else:\n            octave_config.set_calibration_db(os.getcwd())\n\n        return octave_config\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add the Octave configuration to a config dictionary.\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            KeyError: If the Octave is already in the config.\n        \"\"\"\n        if \"octaves\" not in config:\n            config[\"octaves\"] = {}\n        if self.name in config[\"octaves\"]:\n            raise KeyError(\n                f'Error generating config: config[\"octaves\"] already contains an entry '\n                f' for Octave \"{self.name}\"'\n            )\n\n        config[\"octaves\"][self.name] = {\n            \"RF_outputs\": {},\n            \"IF_outputs\": {},\n            \"RF_inputs\": {},\n            \"loopbacks\": list(self.loopbacks),\n        }\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.Octave.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add the Octave configuration to a config dictionary.</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the Octave is already in the config.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add the Octave configuration to a config dictionary.\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        KeyError: If the Octave is already in the config.\n    \"\"\"\n    if \"octaves\" not in config:\n        config[\"octaves\"] = {}\n    if self.name in config[\"octaves\"]:\n        raise KeyError(\n            f'Error generating config: config[\"octaves\"] already contains an entry '\n            f' for Octave \"{self.name}\"'\n        )\n\n    config[\"octaves\"][self.name] = {\n        \"RF_outputs\": {},\n        \"IF_outputs\": {},\n        \"RF_inputs\": {},\n        \"loopbacks\": list(self.loopbacks),\n    }\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.Octave.get_octave_config","title":"<code>get_octave_config()</code>","text":"<p>Return a QmOctaveConfig object with the current Octave configuration.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def get_octave_config(self) -&gt; QmOctaveConfig:\n    \"\"\"Return a QmOctaveConfig object with the current Octave configuration.\"\"\"\n    octave_config = QmOctaveConfig()\n\n    if self.calibration_db_path is not None:\n        octave_config.set_calibration_db(self.calibration_db_path)\n    else:\n        octave_config.set_calibration_db(os.getcwd())\n\n    return octave_config\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.Octave.initialize_frequency_converters","title":"<code>initialize_frequency_converters()</code>","text":"<p>Initialize the Octave frequency converterswith default connectivity.</p> <p>This method initializes the Octave with default connectivity, i.e. it connects the Octave to a single OPX. It creates an <code>OctaveUpConverter</code> for each RF output and an <code>OctaveDownConverter</code> for each RF input. The <code>OctaveUpConverter</code> objects are added to <code>Octave.RF_outputs</code> and the <code>OctaveDownConverter</code> objects are added to <code>Octave.RF_inputs</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Octave already has RF_outputs or RF_inputs.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def initialize_frequency_converters(self):\n    \"\"\"Initialize the Octave frequency converterswith default connectivity.\n\n    This method initializes the Octave with default connectivity, i.e. it connects\n    the Octave to a single OPX. It creates an `OctaveUpConverter` for each RF output\n    and an `OctaveDownConverter` for each RF input. The `OctaveUpConverter` objects\n    are added to `Octave.RF_outputs` and the `OctaveDownConverter` objects are added\n    to `Octave.RF_inputs`.\n\n    Raises:\n        ValueError: If the Octave already has RF_outputs or RF_inputs.\n\n    \"\"\"\n    if self.RF_outputs:\n        raise ValueError(\n            \"Error initializing Octave with default connectivity. \"\n            \"octave.RF_outputs is not empty\"\n        )\n    if self.RF_inputs:\n        raise ValueError(\n            \"Error initializing Octave with default connectivity. \"\n            \"octave.IF_outputs is not empty\"\n        )\n\n    for idx in range(1, 6):\n        self.RF_outputs[idx] = OctaveUpConverter(\n            id=idx,\n            LO_frequency=None,  # TODO What should default be?\n        )\n\n    for idx in range(1, 3):\n        LO_source = \"internal\" if idx == 1 else \"external\"\n        self.RF_inputs[idx] = OctaveDownConverter(\n            id=idx, LO_frequency=None, LO_source=LO_source\n        )\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveFrequencyConverter","title":"<code>OctaveFrequencyConverter</code>","text":"<p>               Bases: <code>BaseFrequencyConverter</code>, <code>ABC</code></p> <p>Base class for OctaveUpConverter and OctaveDownConverter.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The id of the converter. Must be unique within the Octave. For OctaveUpConverter, the id is used as the RF output number. For OctaveDownConverter, the id is used as the RF input number.</p> required <code>channel</code> <p>The channel that the converter is connected to.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass OctaveFrequencyConverter(BaseFrequencyConverter, ABC):\n    \"\"\"Base class for OctaveUpConverter and OctaveDownConverter.\n\n    Args:\n        id: The id of the converter. Must be unique within the Octave.\n            For OctaveUpConverter, the id is used as the RF output number.\n            For OctaveDownConverter, the id is used as the RF input number.\n        channel: The channel that the converter is connected to.\n    \"\"\"\n\n    id: int\n    channel: Channel = None\n\n    @property\n    def octave(self) -&gt; Optional[Octave]:\n        if self.parent is None:\n            return None\n        parent_parent = getattr(self.parent, \"parent\")\n        if not isinstance(parent_parent, Octave):\n            return None\n        return parent_parent\n\n    @property\n    def config_settings(self) -&gt; Dict[str, Any]:\n        \"\"\"Specifies that the converter will be added to the config after the Octave.\"\"\"\n        return {\"after\": [self.octave]}\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add information about the frequency converter to the QUA config\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n                not exist.\n        \"\"\"\n        super().apply_to_config(config)\n\n        if \"octaves\" not in config:\n            raise KeyError('Error generating config: \"octaves\" entry not found')\n\n        if self.octave is None:\n            raise KeyError(\n                f\"Error generating config: OctaveConverter with id {self.id} does not \"\n                \"have an Octave parent\"\n            )\n\n        if self.octave.name not in config[\"octaves\"]:\n            raise KeyError(\n                'Error generating config: config[\"octaves\"] does not have Octave'\n                f' entry config[\"octaves\"][\"{self.octave.name}\"]'\n            )\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveFrequencyConverter.config_settings","title":"<code>config_settings</code>  <code>property</code>","text":"<p>Specifies that the converter will be added to the config after the Octave.</p>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveFrequencyConverter.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information about the frequency converter to the QUA config</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the Octave is not in the config, or if config[\"octaves\"] does not exist.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add information about the frequency converter to the QUA config\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n            not exist.\n    \"\"\"\n    super().apply_to_config(config)\n\n    if \"octaves\" not in config:\n        raise KeyError('Error generating config: \"octaves\" entry not found')\n\n    if self.octave is None:\n        raise KeyError(\n            f\"Error generating config: OctaveConverter with id {self.id} does not \"\n            \"have an Octave parent\"\n        )\n\n    if self.octave.name not in config[\"octaves\"]:\n        raise KeyError(\n            'Error generating config: config[\"octaves\"] does not have Octave'\n            f' entry config[\"octaves\"][\"{self.octave.name}\"]'\n        )\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveUpConverter","title":"<code>OctaveUpConverter</code>","text":"<p>               Bases: <code>OctaveFrequencyConverter</code></p> <p>A frequency upconverter for the QM Octave.</p> <p>The OctaveUpConverter represents a frequency upconverter in the QM Octave. Usually an IQChannel is connected <code>OctaveUpconverter.channel</code>, in which case the two OPX outputs are connected to the I and Q inputs of the OctaveUpConverter. The OPX outputs are specified in the <code>OctaveUpConverter.channel</code> attribute. The channel is either an IQChannel or a SingleChannel.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The RF output id, must be between 1-5.</p> required <code>LO_frequency</code> <p>The local oscillator frequency in Hz, between 2 and 18 GHz.</p> required <code>LO_source</code> <p>The local oscillator source, \"internal\" (default) or \"external\".</p> required <code>gain</code> <p>The gain of the output, between -20 and 20 dB in steps of 0.5. Default is 0 dB.</p> required <code>output_mode</code> <p>Sets the fast switch's mode of the up converter module. Can be \"always_on\" / \"always_off\" / \"triggered\" / \"triggered_reversed\". The default is \"always_off\". - \"always_on\" - Output is always on - \"always_off\" - Output is always off - \"triggered\" - The output will play when rising edge is detected in the   octave's digital port. - \"triggered_reversed\" - The output will play when falling edge is detected   in the octave's digital port.</p> required <code>input_attenuators</code> <p>Whether the I and Q ports have a 10 dB attenuator before entering the mixer. Off by default.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass OctaveUpConverter(OctaveFrequencyConverter):\n    \"\"\"A frequency upconverter for the QM Octave.\n\n    The OctaveUpConverter represents a frequency upconverter in the QM Octave. Usually\n    an IQChannel is connected `OctaveUpconverter.channel`, in which case the two OPX\n    outputs are connected to the I and Q inputs of the OctaveUpConverter.\n    The OPX outputs are specified in the `OctaveUpConverter.channel` attribute.\n    The channel is either an IQChannel or a SingleChannel.\n\n    Args:\n        id: The RF output id, must be between 1-5.\n        LO_frequency: The local oscillator frequency in Hz, between 2 and 18 GHz.\n        LO_source: The local oscillator source, \"internal\" (default) or \"external\".\n        gain: The gain of the output, between -20 and 20 dB in steps of 0.5.\n            Default is 0 dB.\n        output_mode: Sets the fast switch's mode of the up converter module.\n            Can be \"always_on\" / \"always_off\" / \"triggered\" / \"triggered_reversed\".\n            The default is \"always_off\".\n            - \"always_on\" - Output is always on\n            - \"always_off\" - Output is always off\n            - \"triggered\" - The output will play when rising edge is detected in the\n              octave's digital port.\n            - \"triggered_reversed\" - The output will play when falling edge is detected\n              in the octave's digital port.\n        input_attenuators: Whether the I and Q ports have a 10 dB attenuator before\n            entering the mixer. Off by default.\n    \"\"\"\n\n    LO_frequency: float = None\n    LO_source: Literal[\"internal\", \"external\"] = \"internal\"\n    gain: float = 0\n    output_mode: Literal[\n        \"always_on\", \"always_off\", \"triggered\", \"triggered_reversed\"\n    ] = \"always_off\"\n    input_attenuators: Literal[\"off\", \"on\"] = \"off\"\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add information about the frequency up-converter to the QUA config\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Nothing is added to the config if the `OctaveUpConverter.channel` is not\n        specified or if the `OctaveUpConverter.LO_frequency` is not specified.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            ValueError: If the LO_frequency is not specified.\n            KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n                not exist.\n            KeyError: If the Octave already has an entry for the OctaveUpConverter.\n        \"\"\"\n        if not isinstance(self.LO_frequency, (int, float)):\n            if self.channel is None:\n                return\n            else:\n                raise ValueError(\n                    f\"Error generating config for Octave upconverter id={self.id}: \"\n                    \"LO_frequency must be specified.\"\n                )\n\n        super().apply_to_config(config)\n\n        if self.id in config[\"octaves\"][self.octave.name][\"RF_outputs\"]:\n            raise KeyError(\n                f\"Error generating config: \"\n                f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_outputs\"] '\n                f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n            )\n\n        output_config = config[\"octaves\"][self.octave.name][\"RF_outputs\"][self.id] = {\n            \"LO_frequency\": self.LO_frequency,\n            \"LO_source\": self.LO_source,\n            \"gain\": self.gain,\n            \"output_mode\": self.output_mode,\n            \"input_attenuators\": self.input_attenuators,\n        }\n        if isinstance(self.channel, SingleChannel):\n            if isinstance(self.channel.opx_output, LFAnalogOutputPort):\n                output_config[\"I_connection\"] = self.channel.opx_output.port_tuple\n            else:\n                output_config[\"I_connection\"] = self.channel.opx_output\n        elif isinstance(self.channel, IQChannel):\n            if isinstance(self.channel.opx_output_I, LFAnalogOutputPort):\n                output_config[\"I_connection\"] = self.channel.opx_output_I.port_tuple\n            else:\n                output_config[\"I_connection\"] = tuple(self.channel.opx_output_I)\n            if isinstance(self.channel.opx_output_Q, LFAnalogOutputPort):\n                output_config[\"Q_connection\"] = self.channel.opx_output_Q.port_tuple\n            else:\n                output_config[\"Q_connection\"] = tuple(self.channel.opx_output_Q)\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveUpConverter.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information about the frequency up-converter to the QUA config</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Nothing is added to the config if the <code>OctaveUpConverter.channel</code> is not specified or if the <code>OctaveUpConverter.LO_frequency</code> is not specified.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the LO_frequency is not specified.</p> <code>KeyError</code> <p>If the Octave is not in the config, or if config[\"octaves\"] does not exist.</p> <code>KeyError</code> <p>If the Octave already has an entry for the OctaveUpConverter.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add information about the frequency up-converter to the QUA config\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Nothing is added to the config if the `OctaveUpConverter.channel` is not\n    specified or if the `OctaveUpConverter.LO_frequency` is not specified.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        ValueError: If the LO_frequency is not specified.\n        KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n            not exist.\n        KeyError: If the Octave already has an entry for the OctaveUpConverter.\n    \"\"\"\n    if not isinstance(self.LO_frequency, (int, float)):\n        if self.channel is None:\n            return\n        else:\n            raise ValueError(\n                f\"Error generating config for Octave upconverter id={self.id}: \"\n                \"LO_frequency must be specified.\"\n            )\n\n    super().apply_to_config(config)\n\n    if self.id in config[\"octaves\"][self.octave.name][\"RF_outputs\"]:\n        raise KeyError(\n            f\"Error generating config: \"\n            f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_outputs\"] '\n            f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n        )\n\n    output_config = config[\"octaves\"][self.octave.name][\"RF_outputs\"][self.id] = {\n        \"LO_frequency\": self.LO_frequency,\n        \"LO_source\": self.LO_source,\n        \"gain\": self.gain,\n        \"output_mode\": self.output_mode,\n        \"input_attenuators\": self.input_attenuators,\n    }\n    if isinstance(self.channel, SingleChannel):\n        if isinstance(self.channel.opx_output, LFAnalogOutputPort):\n            output_config[\"I_connection\"] = self.channel.opx_output.port_tuple\n        else:\n            output_config[\"I_connection\"] = self.channel.opx_output\n    elif isinstance(self.channel, IQChannel):\n        if isinstance(self.channel.opx_output_I, LFAnalogOutputPort):\n            output_config[\"I_connection\"] = self.channel.opx_output_I.port_tuple\n        else:\n            output_config[\"I_connection\"] = tuple(self.channel.opx_output_I)\n        if isinstance(self.channel.opx_output_Q, LFAnalogOutputPort):\n            output_config[\"Q_connection\"] = self.channel.opx_output_Q.port_tuple\n        else:\n            output_config[\"Q_connection\"] = tuple(self.channel.opx_output_Q)\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveDownConverter","title":"<code>OctaveDownConverter</code>","text":"<p>               Bases: <code>OctaveFrequencyConverter</code></p> <p>A frequency downconverter for the QM Octave.</p> <p>The OctaveDownConverter represents a frequency downconverter in the QM Octave. The OctaveDownConverter is usually connected to an InOutIQChannel, in which case the two OPX inputs are connected to the IF outputs of the OctaveDownConverter. The OPX inputs are specified in the <code>OctaveDownConverter.channel</code> attribute. The channel is either an InOutIQChannel or an InOutSingleChannel.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>The RF input id, must be between 1-2.</p> required <code>LO_frequency</code> <p>The local oscillator frequency in Hz, between 2 and 18 GHz.</p> required <code>LO_source</code> <p>The local oscillator source, \"internal\" or \"external. For down converter 1 \"internal\" is the default, for down converter 2 \"external\" is the default.</p> required <code>IF_mode_I</code> <p>Sets the mode of the I port of the IF Down Converter module as can be seen in the octave block diagram (see Octave page in QUA documentation). Can be \"direct\" / \"envelope\" / \"mixer\" / \"off\". The default is \"direct\". - \"direct\" - The signal bypasses the IF module. - \"envelope\" - The signal passes through an envelope detector. - \"mixer\" - The signal passes through a low-frequency mixer. - \"off\" - the signal doesn't pass to the output port.</p> required <code>IF_mode_Q</code> <p>Sets the mode of the Q port of the IF Down Converter module.</p> required <code>IF_output_I</code> <p>The output port of the IF Down Converter module for the I port. Can be 1 or 2. The default is 1. This will be 2 if the IF outputs are connected to the opposite OPX inputs</p> required <code>IF_output_Q</code> <p>The output port of the IF Down Converter module for the Q port. Can be 1 or 2. The default is 2. This will be 1 if the IF outputs are connected to the opposite OPX inputs.</p> required Source code in <code>quam/components/octave.py</code> <pre><code>@quam_dataclass\nclass OctaveDownConverter(OctaveFrequencyConverter):\n    \"\"\"A frequency downconverter for the QM Octave.\n\n    The OctaveDownConverter represents a frequency downconverter in the QM Octave. The\n    OctaveDownConverter is usually connected to an InOutIQChannel, in which case the\n    two OPX inputs are connected to the IF outputs of the OctaveDownConverter. The\n    OPX inputs are specified in the `OctaveDownConverter.channel` attribute. The\n    channel is either an InOutIQChannel or an InOutSingleChannel.\n\n    Args:\n        id: The RF input id, must be between 1-2.\n        LO_frequency: The local oscillator frequency in Hz, between 2 and 18 GHz.\n        LO_source: The local oscillator source, \"internal\" or \"external.\n            For down converter 1 \"internal\" is the default,\n            for down converter 2 \"external\" is the default.\n        IF_mode_I: Sets the mode of the I port of the IF Down Converter module as can be\n            seen in the octave block diagram (see Octave page in QUA documentation).\n            Can be \"direct\" / \"envelope\" / \"mixer\" / \"off\". The default is \"direct\".\n            - \"direct\" - The signal bypasses the IF module.\n            - \"envelope\" - The signal passes through an envelope detector.\n            - \"mixer\" - The signal passes through a low-frequency mixer.\n            - \"off\" - the signal doesn't pass to the output port.\n        IF_mode_Q: Sets the mode of the Q port of the IF Down Converter module.\n        IF_output_I: The output port of the IF Down Converter module for the I port.\n            Can be 1 or 2. The default is 1. This will be 2 if the IF outputs\n            are connected to the opposite OPX inputs\n        IF_output_Q: The output port of the IF Down Converter module for the Q port.\n            Can be 1 or 2. The default is 2. This will be 1 if the IF outputs\n            are connected to the opposite OPX inputs.\n    \"\"\"\n\n    LO_frequency: float = None\n    LO_source: Literal[\"internal\", \"external\"] = \"internal\"\n    IF_mode_I: Literal[\"direct\", \"envelope\", \"mixer\", \"off\"] = \"direct\"\n    IF_mode_Q: Literal[\"direct\", \"envelope\", \"mixer\", \"off\"] = \"direct\"\n    IF_output_I: Literal[1, 2] = 1\n    IF_output_Q: Literal[1, 2] = 2\n\n    @property\n    def config_settings(self):\n        \"\"\"Specifies that the converter will be added to the config after the Octave.\"\"\"\n        return {\"after\": [self.octave]}\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        \"\"\"Add information about the frequency down-converter to the QUA config\n\n        This method is called by the `QuamComponent.generate_config` method.\n\n        Nothing is added to the config if the `OctaveDownConverter.channel` is not\n        specified or if the `OctaveDownConverter.LO_frequency` is not specified.\n\n        Args:\n            config: A dictionary representing a QUA config file.\n\n        Raises:\n            ValueError: If the LO_frequency is not specified.\n            KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n                not exist.\n            KeyError: If the Octave already has an entry for the OctaveDownConverter.\n            ValueError: If the IF_output_I and IF_output_Q are already assigned to\n                other ports.\n        \"\"\"\n        if not isinstance(self.LO_frequency, (int, float)):\n            if self.channel is None:\n                return\n            else:\n                raise ValueError(\n                    f\"Error generating config for Octave upconverter id={self.id}: \"\n                    \"LO_frequency must be specified.\"\n                )\n\n        super().apply_to_config(config)\n\n        if self.id in config[\"octaves\"][self.octave.name][\"RF_inputs\"]:\n            raise KeyError(\n                f\"Error generating config: \"\n                f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_inputs\"] '\n                f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n            )\n\n        config[\"octaves\"][self.octave.name][\"RF_inputs\"][self.id] = {\n            \"RF_source\": \"RF_in\",\n            \"LO_frequency\": self.LO_frequency,\n            \"LO_source\": self.LO_source,\n            \"IF_mode_I\": self.IF_mode_I,\n            \"IF_mode_Q\": self.IF_mode_Q,\n        }\n\n        if isinstance(self.channel, InOutIQChannel):\n            IF_channels = [self.IF_output_I, self.IF_output_Q]\n            opx_channels = [self.channel.opx_input_I, self.channel.opx_input_Q]\n        elif isinstance(self.channel, InOutSingleChannel):\n            IF_channels = [self.IF_output_I]\n            opx_channels = [self.channel.opx_input]\n        else:\n            IF_channels = []\n            opx_channels = []\n\n        opx_port_tuples = [\n            p.port_tuple if isinstance(p, BasePort) else tuple(p) for p in opx_channels\n        ]\n\n        IF_config = config[\"octaves\"][self.octave.name][\"IF_outputs\"]\n        for k, (IF_ch, opx_port_tuples) in enumerate(\n            zip(IF_channels, opx_port_tuples), start=1\n        ):\n            label = f\"IF_out{IF_ch}\"\n            IF_config.setdefault(label, {\"port\": opx_port_tuples, \"name\": f\"out{k}\"})\n            if IF_config[label][\"port\"] != opx_port_tuples:\n                raise ValueError(\n                    f\"Error generating config for Octave downconverter id={self.id}: \"\n                    f\"Unable to assign {label} to  port {opx_port_tuples} because it is already \"\n                    f\"assigned to port {IF_config[label]['port']} \"\n                )\n</code></pre>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveDownConverter.config_settings","title":"<code>config_settings</code>  <code>property</code>","text":"<p>Specifies that the converter will be added to the config after the Octave.</p>"},{"location":"API_references/components/octave_API/#quam.components.octave.OctaveDownConverter.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information about the frequency down-converter to the QUA config</p> <p>This method is called by the <code>QuamComponent.generate_config</code> method.</p> <p>Nothing is added to the config if the <code>OctaveDownConverter.channel</code> is not specified or if the <code>OctaveDownConverter.LO_frequency</code> is not specified.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>A dictionary representing a QUA config file.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the LO_frequency is not specified.</p> <code>KeyError</code> <p>If the Octave is not in the config, or if config[\"octaves\"] does not exist.</p> <code>KeyError</code> <p>If the Octave already has an entry for the OctaveDownConverter.</p> <code>ValueError</code> <p>If the IF_output_I and IF_output_Q are already assigned to other ports.</p> Source code in <code>quam/components/octave.py</code> <pre><code>def apply_to_config(self, config: Dict) -&gt; None:\n    \"\"\"Add information about the frequency down-converter to the QUA config\n\n    This method is called by the `QuamComponent.generate_config` method.\n\n    Nothing is added to the config if the `OctaveDownConverter.channel` is not\n    specified or if the `OctaveDownConverter.LO_frequency` is not specified.\n\n    Args:\n        config: A dictionary representing a QUA config file.\n\n    Raises:\n        ValueError: If the LO_frequency is not specified.\n        KeyError: If the Octave is not in the config, or if config[\"octaves\"] does\n            not exist.\n        KeyError: If the Octave already has an entry for the OctaveDownConverter.\n        ValueError: If the IF_output_I and IF_output_Q are already assigned to\n            other ports.\n    \"\"\"\n    if not isinstance(self.LO_frequency, (int, float)):\n        if self.channel is None:\n            return\n        else:\n            raise ValueError(\n                f\"Error generating config for Octave upconverter id={self.id}: \"\n                \"LO_frequency must be specified.\"\n            )\n\n    super().apply_to_config(config)\n\n    if self.id in config[\"octaves\"][self.octave.name][\"RF_inputs\"]:\n        raise KeyError(\n            f\"Error generating config: \"\n            f'config[\"octaves\"][\"{self.octave.name}\"][\"RF_inputs\"] '\n            f'already has an entry for OctaveDownConverter with id \"{self.id}\"'\n        )\n\n    config[\"octaves\"][self.octave.name][\"RF_inputs\"][self.id] = {\n        \"RF_source\": \"RF_in\",\n        \"LO_frequency\": self.LO_frequency,\n        \"LO_source\": self.LO_source,\n        \"IF_mode_I\": self.IF_mode_I,\n        \"IF_mode_Q\": self.IF_mode_Q,\n    }\n\n    if isinstance(self.channel, InOutIQChannel):\n        IF_channels = [self.IF_output_I, self.IF_output_Q]\n        opx_channels = [self.channel.opx_input_I, self.channel.opx_input_Q]\n    elif isinstance(self.channel, InOutSingleChannel):\n        IF_channels = [self.IF_output_I]\n        opx_channels = [self.channel.opx_input]\n    else:\n        IF_channels = []\n        opx_channels = []\n\n    opx_port_tuples = [\n        p.port_tuple if isinstance(p, BasePort) else tuple(p) for p in opx_channels\n    ]\n\n    IF_config = config[\"octaves\"][self.octave.name][\"IF_outputs\"]\n    for k, (IF_ch, opx_port_tuples) in enumerate(\n        zip(IF_channels, opx_port_tuples), start=1\n    ):\n        label = f\"IF_out{IF_ch}\"\n        IF_config.setdefault(label, {\"port\": opx_port_tuples, \"name\": f\"out{k}\"})\n        if IF_config[label][\"port\"] != opx_port_tuples:\n            raise ValueError(\n                f\"Error generating config for Octave downconverter id={self.id}: \"\n                f\"Unable to assign {label} to  port {opx_port_tuples} because it is already \"\n                f\"assigned to port {IF_config[label]['port']} \"\n            )\n</code></pre>"},{"location":"API_references/components/ports_API/","title":"QUAM Ports API","text":"<p>Welcome to the QUAM Ports API Documentation. The QUAM Ports module provides abstractions for hardware connection points including analog and digital inputs/outputs. Information can be found in QUAM Ports Documentation in the User Guide.</p> <p>This section provides detailed API references for port types\u2014from base ports to specific analog and digital implementations\u2014that represent physical connections between the quantum control hardware and quantum devices.</p>"},{"location":"API_references/components/ports_API/#quam.components.ports.BasePort","title":"<code>BasePort</code>","text":"<p>               Bases: <code>QuamComponent</code>, <code>ABC</code></p> Source code in <code>quam/components/ports/base_ports.py</code> <pre><code>@quam_dataclass\nclass BasePort(QuamComponent, ABC):\n    port_type: ClassVar[str]\n\n    @abstractmethod\n    def get_port_config(\n        self, config: Dict[str, Any], create: bool = True\n    ) -&gt; Dict[str, Any]:\n        pass\n\n    @abstractmethod\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        pass\n\n    @property\n    @abstractmethod\n    def port_tuple(self) -&gt; Union[Tuple[str, int], Tuple[str, int, int]]:\n        pass\n\n    def _update_port_config(self, port_config, port_properties):\n        for key, value in port_properties.items():\n            try:\n                if key in port_config and value != port_config[key]:\n                    warnings.warn(\n                        f\"Error generating QUA config: Controller {self.port_type} \"\n                        f\"port {self.port_tuple} already has entry for {key}. This \"\n                        f\"likely means that the port is being configured multiple \"\n                        f\"times. Overwriting {port_config[key]} \u2192 {value}.\"\n                    )\n            except Exception:\n                pass\n            port_config[key] = value\n\n    def apply_to_config(self, config: Dict) -&gt; None:\n        super().apply_to_config(config)\n\n        port_cfg = self.get_port_config(config)\n        port_properties = self.get_port_properties()\n        self._update_port_config(port_cfg, port_properties)\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.OPXPlusPort","title":"<code>OPXPlusPort</code>","text":"<p>               Bases: <code>BasePort</code>, <code>ABC</code></p> Source code in <code>quam/components/ports/base_ports.py</code> <pre><code>@quam_dataclass(kw_only=False)\nclass OPXPlusPort(BasePort, ABC):\n    controller_id: Union[str, int]\n    port_id: int\n\n    @property\n    def port_tuple(self) -&gt; Tuple[Union[str, int], int]:\n        return self.controller_id, self.port_id\n\n    def get_port_config(\n        self, config: Dict[str, Any], create: bool = True\n    ) -&gt; Dict[str, Any]:\n\n        if not create:\n            try:\n                controller_cfg = config[\"controllers\"][self.controller_id]\n                return controller_cfg[f\"{self.port_type}\"][self.port_id]\n            except KeyError:\n                raise KeyError(\n                    f\"Error generating config: controller {self.controller_id} does \"\n                    f\"not have entry {self.port_type}s for port {self.port_tuple}\"\n                )\n\n        controller_cfg = config[\"controllers\"].setdefault(self.controller_id, {})\n        ports_cfg = controller_cfg.setdefault(f\"{self.port_type}s\", {})\n        port_cfg = ports_cfg.setdefault(self.port_id, {})\n        return port_cfg\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.FEMPort","title":"<code>FEMPort</code>","text":"<p>               Bases: <code>BasePort</code>, <code>ABC</code></p> Source code in <code>quam/components/ports/base_ports.py</code> <pre><code>@quam_dataclass(kw_only=False)\nclass FEMPort(BasePort, ABC):\n    fem_type: ClassVar[str]\n    controller_id: Union[str, int]\n    fem_id: int\n    port_id: int\n\n    @property\n    def port_tuple(self) -&gt; Tuple[Union[str, int], int, int]:\n        return self.controller_id, self.fem_id, self.port_id\n\n    def get_port_config(\n        self, config: Dict[str, Any], create: bool = True\n    ) -&gt; Dict[str, Any]:\n\n        if not create:\n            try:\n                controller_cfg = config[\"controllers\"][self.controller_id]\n                fem_cfg = controller_cfg[\"fems\"][self.fem_id]\n            except KeyError:\n                raise KeyError(\n                    f\"Error generating config: controller {self.controller_id} does \"\n                    f\"not have entry for FEM {self.fem_id} for \"\n                    f\"port {self.port_id}\"\n                )\n            try:\n                return fem_cfg[f\"{self.port_type}s\"][self.port_id]\n            except KeyError:\n                raise KeyError(\n                    f\"Error generating config: controller {self.controller_id} does \"\n                    f\"not have entry {self.port_type}s for port {self.port_tuple}\"\n                )\n\n        controller_cfg = config[\"controllers\"].setdefault(self.controller_id, {})\n        fems_cfg = controller_cfg.setdefault(\"fems\", {})\n        fem_cfg = fems_cfg.setdefault(self.fem_id, {})\n        if hasattr(self, \"fem_type\"):\n            if fem_cfg.get(\"type\", self.fem_type) != self.fem_type:\n                raise ValueError(\n                    f\"Error generating config: FEM {self.fem_id} is not of type \"\n                    f\"{self.fem_type}\"\n                )\n            fem_cfg[\"type\"] = self.fem_type\n\n        ports_cfg = fem_cfg.setdefault(f\"{self.port_type}s\", {})\n        port_cfg = ports_cfg.setdefault(self.port_id, {})\n        return port_cfg\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.OPXPlusAnalogOutputPort","title":"<code>OPXPlusAnalogOutputPort</code>","text":"<p>               Bases: <code>LFAnalogOutputPort</code>, <code>OPXPlusPort</code></p> Source code in <code>quam/components/ports/analog_outputs.py</code> <pre><code>@quam_dataclass\nclass OPXPlusAnalogOutputPort(LFAnalogOutputPort, OPXPlusPort):\n    pass\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.OPXPlusAnalogInputPort","title":"<code>OPXPlusAnalogInputPort</code>","text":"<p>               Bases: <code>LFAnalogInputPort</code>, <code>OPXPlusPort</code></p> Source code in <code>quam/components/ports/analog_inputs.py</code> <pre><code>@quam_dataclass\nclass OPXPlusAnalogInputPort(LFAnalogInputPort, OPXPlusPort):\n    pass\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.LFAnalogOutputPort","title":"<code>LFAnalogOutputPort</code>","text":"<p>               Bases: <code>BasePort</code>, <code>ABC</code></p> Source code in <code>quam/components/ports/analog_outputs.py</code> <pre><code>@quam_dataclass\nclass LFAnalogOutputPort(BasePort, ABC):\n    fem_type: ClassVar[str] = \"LF\"\n    port_type: ClassVar[str] = \"analog_output\"\n\n    offset: Optional[float] = None\n    delay: int = 0\n    crosstalk: Optional[Dict[int, float]] = None\n    feedforward_filter: Optional[List[float]] = None\n    feedback_filter: Optional[List[float]] = None\n    shareable: bool = False\n\n    def get_port_properties(self):\n        port_properties = {\n            \"delay\": self.delay,\n            \"shareable\": self.shareable,\n        }\n        if self.crosstalk is not None:\n            port_properties[\"crosstalk\"] = dict(self.crosstalk)\n        if self.feedforward_filter is not None:\n            port_properties.setdefault(\"filter\", {})[\"feedforward\"] = list(\n                self.feedforward_filter\n            )\n        if self.feedback_filter is not None:\n            port_properties.setdefault(\"filter\", {})[\"feedback\"] = list(\n                self.feedback_filter\n            )\n        if self.offset is not None:\n            port_properties[\"offset\"] = self.offset\n        return port_properties\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.LFAnalogInputPort","title":"<code>LFAnalogInputPort</code>","text":"<p>               Bases: <code>BasePort</code>, <code>ABC</code></p> Source code in <code>quam/components/ports/analog_inputs.py</code> <pre><code>@quam_dataclass\nclass LFAnalogInputPort(BasePort, ABC):\n    fem_type: ClassVar[str] = \"LF\"\n    port_type: ClassVar[str] = \"analog_input\"\n\n    offset: Optional[float] = None\n    gain_db: int = 0\n    shareable: bool = False\n\n    def get_port_properties(self):\n        port_cfg = {\n            \"gain_db\": self.gain_db,\n            \"shareable\": self.shareable,\n        }\n        if self.offset is not None:\n            port_cfg[\"offset\"] = self.offset\n        return port_cfg\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.LFFEMAnalogOutputPort","title":"<code>LFFEMAnalogOutputPort</code>","text":"<p>               Bases: <code>LFAnalogOutputPort</code>, <code>FEMPort</code></p> Source code in <code>quam/components/ports/analog_outputs.py</code> <pre><code>@quam_dataclass\nclass LFFEMAnalogOutputPort(LFAnalogOutputPort, FEMPort):\n    fem_type: ClassVar[str] = \"LF\"\n    sampling_rate: float = 1e9  # Either 1e9 or 2e9\n    upsampling_mode: Literal[\"mw\", \"pulse\"] = \"mw\"\n    exponential_filter: Optional[List[Tuple[float, float]]] = None\n    # high_pass_filter: Optional[float] = None  # Not yet supported\n    output_mode: Literal[\"direct\", \"amplified\"] = \"direct\"\n\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        port_properties = super().get_port_properties()\n        if self.exponential_filter is not None:\n            filter_properties = port_properties.setdefault(\"filter\", {})\n            filter_properties[\"exponential\"] = list(self.exponential_filter)\n            if \"feedback\" in filter_properties:\n                raise ValueError(\n                    \"LFFEMAnalogOutputPort: Please only specify 'exponential_filter' \"\n                    \"if QOP &gt;=3.3.0, or 'feedback_filter' if QOP &lt; 3.3.0, not both\"\n                )\n\n        port_properties[\"sampling_rate\"] = self.sampling_rate\n        if self.sampling_rate == 1e9:\n            port_properties[\"upsampling_mode\"] = self.upsampling_mode\n        port_properties[\"output_mode\"] = self.output_mode\n        return port_properties\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.LFFEMAnalogInputPort","title":"<code>LFFEMAnalogInputPort</code>","text":"<p>               Bases: <code>LFAnalogInputPort</code>, <code>FEMPort</code></p> Source code in <code>quam/components/ports/analog_inputs.py</code> <pre><code>@quam_dataclass\nclass LFFEMAnalogInputPort(LFAnalogInputPort, FEMPort):\n    sampling_rate: float = 1e9  # Either 1e9 or 2e9\n\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        port_properties = super().get_port_properties()\n        port_properties[\"sampling_rate\"] = self.sampling_rate\n        return port_properties\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.MWFEMAnalogOutputPort","title":"<code>MWFEMAnalogOutputPort</code>","text":"<p>               Bases: <code>FEMPort</code></p> Source code in <code>quam/components/ports/analog_outputs.py</code> <pre><code>@quam_dataclass\nclass MWFEMAnalogOutputPort(FEMPort):\n    fem_type: ClassVar[str] = \"MW\"\n    port_type: ClassVar[str] = \"analog_output\"\n\n    band: int\n    upconverter_frequency: Optional[float] = None\n    upconverters: Optional[Dict[int, Dict[str, float]]] = None\n    delay: int = 0\n    shareable: bool = False\n    sampling_rate: float = 1e9  # Either 1e9 or 2e9\n    full_scale_power_dbm: int = -11\n\n    def __post_init__(self) -&gt; None:\n        super().__post_init__()\n        if self.upconverter_frequency is None and self.upconverters is None:\n            raise ValueError(\n                \"MWAnalogOutputPort: Either upconverter_frequency or upconverters must \"\n                \"be provided\"\n            )\n\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        port_cfg = {\n            \"band\": self.band,\n            \"delay\": self.delay,\n            \"shareable\": self.shareable,\n            \"sampling_rate\": self.sampling_rate,\n            \"full_scale_power_dbm\": self.full_scale_power_dbm,\n        }\n        if self.upconverter_frequency is not None:\n            port_cfg[\"upconverter_frequency\"] = self.upconverter_frequency\n        if self.upconverters is not None:\n            port_cfg[\"upconverters\"] = {\n                key: dict(val) for key, val in self.upconverters.items()\n            }\n        return port_cfg\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.MWFEMAnalogInputPort","title":"<code>MWFEMAnalogInputPort</code>","text":"<p>               Bases: <code>FEMPort</code></p> Source code in <code>quam/components/ports/analog_inputs.py</code> <pre><code>@quam_dataclass\nclass MWFEMAnalogInputPort(FEMPort):\n    fem_type: ClassVar[str] = \"MW\"\n    port_type: ClassVar[str] = \"analog_input\"\n\n    band: int\n    downconverter_frequency: float\n    gain_db: Optional[int] = None\n    sampling_rate: float = 1e9  # Either 1e9 or 2e9\n    shareable: bool = False\n\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        port_properties = {\n            \"band\": self.band,\n            \"downconverter_frequency\": self.downconverter_frequency,\n            \"sampling_rate\": self.sampling_rate,\n            \"shareable\": self.shareable,\n        }\n        if self.gain_db is not None:\n            port_properties[\"gain_db\"] = self.gain_db\n        return port_properties\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.OPXPlusDigitalOutputPort","title":"<code>OPXPlusDigitalOutputPort</code>","text":"<p>               Bases: <code>DigitalOutputPort</code>, <code>OPXPlusPort</code></p> Source code in <code>quam/components/ports/digital_outputs.py</code> <pre><code>@quam_dataclass\nclass OPXPlusDigitalOutputPort(DigitalOutputPort, OPXPlusPort):\n    pass\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.OPXPlusDigitalInputPort","title":"<code>OPXPlusDigitalInputPort</code>","text":"<p>               Bases: <code>OPXPlusPort</code></p> Source code in <code>quam/components/ports/digital_inputs.py</code> <pre><code>@quam_dataclass\nclass OPXPlusDigitalInputPort(OPXPlusPort):\n    port_type: ClassVar[str] = \"digital_input\"\n\n    deadtime: int = 4\n    polarity: Literal[\"rising\", \"falling\"] = \"rising\"\n    threshold: float = 2.0\n    shareable: bool = False\n\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        return {\n            \"deadtime\": self.deadtime,\n            \"polarity\": self.polarity,\n            \"threshold\": self.threshold,\n            \"shareable\": self.shareable,\n        }\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.DigitalOutputPort","title":"<code>DigitalOutputPort</code>","text":"<p>               Bases: <code>BasePort</code>, <code>ABC</code></p> Source code in <code>quam/components/ports/digital_outputs.py</code> <pre><code>@quam_dataclass\nclass DigitalOutputPort(BasePort, ABC):\n    port_type: ClassVar[str] = \"digital_output\"\n\n    inverted: bool = False\n    shareable: bool = False\n\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        return {\"inverted\": self.inverted, \"shareable\": self.shareable}\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.FEMDigitalOutputPort","title":"<code>FEMDigitalOutputPort</code>","text":"<p>               Bases: <code>DigitalOutputPort</code>, <code>FEMPort</code></p> Source code in <code>quam/components/ports/digital_outputs.py</code> <pre><code>@quam_dataclass\nclass FEMDigitalOutputPort(DigitalOutputPort, FEMPort):\n    level: Literal[\"TTL\", \"LVTTL\"] = \"LVTTL\"\n\n    def get_port_properties(self) -&gt; Dict[str, Any]:\n        port_properties = super().get_port_properties()\n        port_properties[\"level\"] = self.level\n        return port_properties\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.OPXPlusPortsContainer","title":"<code>OPXPlusPortsContainer</code>","text":"<p>               Bases: <code>QuamComponent</code></p> Source code in <code>quam/components/ports/ports_containers.py</code> <pre><code>@quam_dataclass\nclass OPXPlusPortsContainer(QuamComponent):\n    analog_outputs: Dict[Union[str, int], Dict[int, OPXPlusAnalogOutputPort]] = field(\n        default_factory=dict\n    )\n    analog_inputs: Dict[Union[str, int], Dict[int, OPXPlusAnalogInputPort]] = field(\n        default_factory=dict\n    )\n    digital_outputs: Dict[Union[str, int], Dict[int, OPXPlusDigitalOutputPort]] = field(\n        default_factory=dict\n    )\n    digital_inputs: Dict[Union[str, int], Dict[int, OPXPlusDigitalInputPort]] = field(\n        default_factory=dict\n    )\n\n    def _get_port(\n        self,\n        controller_id: Union[str, int],\n        port_id: int,\n        port_type: str,\n        create: bool = False,\n        **kwargs,\n    ):\n        controllers = getattr(self, f\"{port_type}s\")\n\n        try:\n            return controllers[controller_id][port_id]\n        except KeyError:\n            if not create:\n                raise KeyError(\n                    f\"Could not find existing {port_type} port: \"\n                    f\"{port_type} ({controller_id}, {port_id}\"\n                )\n\n        controllers.setdefault(controller_id, {})\n        ports = controllers[controller_id]\n\n        if port_type == \"analog_output\":\n            ports[port_id] = OPXPlusAnalogOutputPort(controller_id, port_id, **kwargs)\n        elif port_type == \"analog_input\":\n            ports[port_id] = OPXPlusAnalogInputPort(controller_id, port_id, **kwargs)\n        elif port_type == \"digital_output\":\n            ports[port_id] = OPXPlusDigitalOutputPort(controller_id, port_id, **kwargs)\n        elif port_type == \"digital_input\":\n            ports[port_id] = OPXPlusDigitalInputPort(controller_id, port_id, **kwargs)\n        else:\n            raise ValueError(f\"Invalid port type: {port_type}\")\n\n        return ports[port_id]\n\n    def reference_to_port(\n        self,\n        port_reference: Union[QuamComponent, str],\n        attr: Optional[str] = None,\n        create=False,\n    ) -&gt; OPXPlusPortTypes:\n        if isinstance(port_reference, QuamComponent):\n            reference = port_reference.get_reference(attr=attr)\n            if reference is None:\n                raise ValueError(\"Cannot get port from reference {port_reference}\")\n            port_reference = reference\n        elems = port_reference.split(\"/\")\n        port_type, controller_id, port_id = elems[-3:]\n\n        port_type = port_type[:-1]\n        if controller_id.isdigit():\n            controller_id = int(controller_id)\n        port_id = int(port_id)\n\n        return self._get_port(controller_id, port_id, port_type, create=create)\n\n    def get_analog_output(\n        self,\n        controller_id: Union[str, int],\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; OPXPlusAnalogOutputPort:\n        return self._get_port(\n            controller_id, port_id, port_type=\"analog_output\", create=create, **kwargs\n        )\n\n    def get_analog_input(\n        self,\n        controller_id: Union[str, int],\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; OPXPlusAnalogInputPort:\n        return self._get_port(\n            controller_id, port_id, port_type=\"analog_input\", create=create, **kwargs\n        )\n\n    def get_digital_output(\n        self,\n        controller_id: Union[str, int],\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; OPXPlusDigitalOutputPort:\n        return self._get_port(\n            controller_id, port_id, port_type=\"digital_output\", create=create, **kwargs\n        )\n\n    def get_digital_input(\n        self,\n        controller_id: Union[str, int],\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; OPXPlusDigitalInputPort:\n        return self._get_port(\n            controller_id, port_id, port_type=\"digital_input\", create=create, **kwargs\n        )\n</code></pre>"},{"location":"API_references/components/ports_API/#quam.components.ports.FEMPortsContainer","title":"<code>FEMPortsContainer</code>","text":"<p>               Bases: <code>QuamComponent</code></p> Source code in <code>quam/components/ports/ports_containers.py</code> <pre><code>@quam_dataclass\nclass FEMPortsContainer(QuamComponent):\n    num_port_elems: ClassVar[int] = 3\n    analog_outputs: Dict[\n        Union[str, int], Dict[int, Dict[int, LFFEMAnalogOutputPort]]\n    ] = field(default_factory=dict)\n    analog_inputs: Dict[Union[str, int], Dict[int, Dict[int, LFFEMAnalogInputPort]]] = (\n        field(default_factory=dict)\n    )\n    mw_outputs: Dict[Union[str, int], Dict[int, Dict[int, MWFEMAnalogOutputPort]]] = (\n        field(default_factory=dict)\n    )\n    mw_inputs: Dict[Union[str, int], Dict[int, Dict[int, MWFEMAnalogInputPort]]] = (\n        field(default_factory=dict)\n    )\n    digital_outputs: Dict[\n        Union[str, int], Dict[int, Dict[int, FEMDigitalOutputPort]]\n    ] = field(default_factory=dict)\n\n    def _get_port(\n        self,\n        controller_id: Union[str, int],\n        fem_id: int,\n        port_id: int,\n        port_type: str,\n        create: bool = False,\n        **kwargs,\n    ):\n        controllers = getattr(self, f\"{port_type}s\")\n\n        try:\n            return controllers[controller_id][fem_id][port_id]\n        except KeyError:\n            if not create:\n                raise KeyError(\n                    f\"Could not find existing {port_type} port: \"\n                    f\"{port_type} ({controller_id}, {fem_id}, {port_id}\"\n                )\n\n        controllers.setdefault(controller_id, {})\n        fems = controllers[controller_id]\n        fems.setdefault(fem_id, {})\n        ports = fems[fem_id]\n\n        if port_type == \"analog_output\":\n            ports[port_id] = LFFEMAnalogOutputPort(\n                controller_id, fem_id, port_id, **kwargs\n            )\n        elif port_type == \"analog_input\":\n            ports[port_id] = LFFEMAnalogInputPort(\n                controller_id, fem_id, port_id, **kwargs\n            )\n        elif port_type == \"mw_output\":\n            # Set default values in kwargs before passing to constructor\n            # Safe to mutate since kwargs is used only once per port creation\n            if \"upconverter_frequency\" not in kwargs and \"upconverters\" not in kwargs:\n                kwargs[\"upconverter_frequency\"] = 5e9\n            if \"band\" not in kwargs:\n                kwargs[\"band\"] = 1\n            ports[port_id] = MWFEMAnalogOutputPort(\n                controller_id, fem_id, port_id, **kwargs\n            )\n        elif port_type == \"mw_input\":\n            # Set default values in kwargs before passing to constructor\n            # Safe to mutate since kwargs is used only once per port creation\n            if \"band\" not in kwargs:\n                kwargs[\"band\"] = 1\n            if \"downconverter_frequency\" not in kwargs:\n                kwargs[\"downconverter_frequency\"] = 5e9\n            ports[port_id] = MWFEMAnalogInputPort(\n                controller_id,\n                fem_id,\n                port_id,\n                **kwargs,\n            )\n        elif port_type == \"digital_output\":\n            ports[port_id] = FEMDigitalOutputPort(\n                controller_id, fem_id, port_id, **kwargs\n            )\n        else:\n            raise ValueError(f\"Invalid port type: {port_type}\")\n\n        return ports[port_id]\n\n    def reference_to_port(\n        self,\n        port_reference: Union[QuamComponent, str],\n        attr: Optional[str] = None,\n        create=False,\n    ) -&gt; FEMPortTypes:\n        if isinstance(port_reference, QuamBase):\n            reference = port_reference.get_reference(attr=attr)\n            if reference is None:\n                raise ValueError(\"Cannot get port from reference {port_reference}\")\n            port_reference = reference\n\n        elems = port_reference.split(\"/\")\n        port_type, controller_id, fem_id, port_id = elems[-4:]\n\n        port_type = port_type[:-1]\n        if controller_id.isdigit():\n            controller_id = int(controller_id)\n        fem_id = int(fem_id)\n        port_id = int(port_id)\n\n        return self._get_port(controller_id, fem_id, port_id, port_type, create=create)\n\n    def get_analog_output(\n        self,\n        controller_id: Union[str, int],\n        fem_id: int,\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; LFFEMAnalogOutputPort:\n        return self._get_port(\n            controller_id,\n            fem_id,\n            port_id,\n            port_type=\"analog_output\",\n            create=create,\n            **kwargs,\n        )\n\n    def get_analog_input(\n        self,\n        controller_id: Union[str, int],\n        fem_id: int,\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; LFFEMAnalogInputPort:\n        return self._get_port(\n            controller_id,\n            fem_id,\n            port_id,\n            port_type=\"analog_input\",\n            create=create,\n            **kwargs,\n        )\n\n    def get_mw_output(\n        self,\n        controller_id: Union[str, int],\n        fem_id: int,\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; MWFEMAnalogOutputPort:\n        return self._get_port(\n            controller_id,\n            fem_id,\n            port_id,\n            port_type=\"mw_output\",\n            create=create,\n            **kwargs,\n        )\n\n    def get_mw_input(\n        self,\n        controller_id: Union[str, int],\n        fem_id: int,\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; MWFEMAnalogInputPort:\n        return self._get_port(\n            controller_id,\n            fem_id,\n            port_id,\n            port_type=\"mw_input\",\n            create=create,\n            **kwargs,\n        )\n\n    def get_digital_output(\n        self,\n        controller_id: Union[str, int],\n        fem_id: int,\n        port_id: int,\n        create: bool = False,\n        **kwargs,\n    ) -&gt; FEMDigitalOutputPort:\n        return self._get_port(\n            controller_id,\n            fem_id,\n            port_id,\n            port_type=\"digital_output\",\n            create=create,\n            **kwargs,\n        )\n</code></pre>"},{"location":"API_references/components/pulses/","title":"Pulses","text":""},{"location":"API_references/components/pulses/#quam.components.pulses.BaseReadoutPulse","title":"<code>BaseReadoutPulse</code>","text":"<p>               Bases: <code>Pulse</code>, <code>ABC</code></p> <p>QUAM abstract base component for a general  readout pulse.</p> <p>Readout pulse classes should usually inherit from <code>ReadoutPulse</code>, the exception being when a custom integration weights function is required.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Default is \"ON\".</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass BaseReadoutPulse(Pulse, ABC):\n    \"\"\"QUAM abstract base component for a general  readout pulse.\n\n    Readout pulse classes should usually inherit from `ReadoutPulse`, the\n    exception being when a custom integration weights function is required.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Default is \"ON\".\n    \"\"\"\n\n    operation: ClassVar[str] = \"measurement\"\n    digital_marker: str = \"ON\"\n\n    # TODO Understand why the thresholds were added.\n    threshold: float = None\n    rus_exit_threshold: float = None\n\n    _weight_labels: ClassVar[List[str]] = [\"iw1\", \"iw2\", \"iw3\"]\n\n    @property\n    def integration_weights_names(self):\n        return [f\"{self.name}{str_ref.DELIMITER}{name}\" for name in self._weight_labels]\n\n    @property\n    def integration_weights_mapping(self):\n        return dict(zip(self._weight_labels, self.integration_weights_names))\n\n    @abstractmethod\n    def integration_weights_function(self) -&gt; Dict[str, List[Tuple[float, int]]]:\n        \"\"\"Abstract method to calculate the integration weights.\n\n        Returns:\n            Dict containing keys \"real\", \"imag\", \"minus_real\", \"minus_imag\".\n            Values are lists of tuples of (weight, length) pairs.\n        \"\"\"\n        ...\n\n    def _config_add_integration_weights(self, config: dict):\n        \"\"\"Add the integration weights to the config\"\"\"\n        integration_weights = self.integration_weights_function()\n\n        config[\"integration_weights\"][self.integration_weights_names[0]] = {\n            \"cosine\": integration_weights[\"real\"],\n            \"sine\": integration_weights[\"minus_imag\"],\n        }\n        config[\"integration_weights\"][self.integration_weights_names[1]] = {\n            \"cosine\": integration_weights[\"imag\"],\n            \"sine\": integration_weights[\"real\"],\n        }\n        config[\"integration_weights\"][self.integration_weights_names[2]] = {\n            \"cosine\": integration_weights[\"minus_imag\"],\n            \"sine\": integration_weights[\"minus_real\"],\n        }\n\n        pulse_config = config[\"pulses\"][self.pulse_name]\n        pulse_config[\"integration_weights\"] = self.integration_weights_mapping\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Adds this readout pulse to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        super().apply_to_config(config)\n        self._config_add_integration_weights(config)\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.BaseReadoutPulse.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this readout pulse to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Adds this readout pulse to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    super().apply_to_config(config)\n    self._config_add_integration_weights(config)\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.BaseReadoutPulse.integration_weights_function","title":"<code>integration_weights_function()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to calculate the integration weights.</p> <p>Returns:</p> Type Description <code>Dict[str, List[Tuple[float, int]]]</code> <p>Dict containing keys \"real\", \"imag\", \"minus_real\", \"minus_imag\".</p> <code>Dict[str, List[Tuple[float, int]]]</code> <p>Values are lists of tuples of (weight, length) pairs.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>@abstractmethod\ndef integration_weights_function(self) -&gt; Dict[str, List[Tuple[float, int]]]:\n    \"\"\"Abstract method to calculate the integration weights.\n\n    Returns:\n        Dict containing keys \"real\", \"imag\", \"minus_real\", \"minus_imag\".\n        Values are lists of tuples of (weight, length) pairs.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.BlackmanIntegralPulse","title":"<code>BlackmanIntegralPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Adiabatic Blackman-integral ramp from v_start to v_end.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Pulse length (samples).</p> required <code>v_start</code> <code>float</code> <p>Starting amplitude (V).</p> required <code>v_end</code> <code>float</code> <p>Ending amplitude (V).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass BlackmanIntegralPulse(Pulse):\n    \"\"\"Adiabatic Blackman-integral ramp from v_start to v_end.\n\n    Args:\n        length (int): Pulse length (samples).\n        v_start (float): Starting amplitude (V).\n        v_end (float): Ending amplitude (V).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    # amplitude: float\n    v_start: float\n    v_end: float\n    axis_angle: float = None\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import blackman_integral_waveform\n\n        wf = blackman_integral_waveform(\n            pulse_length=self.length,\n            v_start=self.v_start,\n            v_end=self.v_end,\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.DragCosinePulse","title":"<code>DragCosinePulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Cosine based DRAG pulse that compensate for the leakage and AC stark shift.</p> <p>These DRAG waveforms has been implemented following the next Refs.: Chen et al. PRL, 116, 020501 (2016) https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501 and Chen's thesis https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The pulse length in ns.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>amplitude</code> <code>float</code> <p>The amplitude in volts.</p> required <code>alpha</code> <code>float</code> <p>The DRAG coefficient.</p> required <code>anharmonicity</code> <code>float</code> <p>f_21 - f_10 - The differences in energy between the 2-1 and the 1-0 energy levels, in Hz.</p> required <code>detuning</code> <code>float</code> <p>The frequency shift to correct for AC stark shift, in Hz.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass DragCosinePulse(Pulse):\n    \"\"\"Cosine based DRAG pulse that compensate for the leakage and AC stark shift.\n\n    These DRAG waveforms has been implemented following the next Refs.:\n    Chen et al. PRL, 116, 020501 (2016)\n    https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501\n    and Chen's thesis\n    https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf\n\n    Args:\n        length (int): The pulse length in ns.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        amplitude (float): The amplitude in volts.\n        alpha (float): The DRAG coefficient.\n        anharmonicity (float): f_21 - f_10 - The differences in energy between the 2-1\n            and the 1-0 energy levels, in Hz.\n        detuning (float): The frequency shift to correct for AC stark shift, in Hz.\n    \"\"\"\n\n    axis_angle: float\n    amplitude: float\n    alpha: float\n    anharmonicity: float\n    detuning: float = 0.0\n\n    def __post_init__(self) -&gt; None:\n        return super().__post_init__()\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import drag_cosine_pulse_waveforms\n\n        I, Q = drag_cosine_pulse_waveforms(\n            amplitude=self.amplitude,\n            length=self.length,\n            alpha=self.alpha,\n            anharmonicity=self.anharmonicity,\n            detuning=self.detuning,\n        )\n        I, Q = np.array(I), np.array(Q)\n\n        I_rot = I * np.cos(self.axis_angle) - Q * np.sin(self.axis_angle)\n        Q_rot = I * np.sin(self.axis_angle) + Q * np.cos(self.axis_angle)\n\n        return I_rot + 1.0j * Q_rot\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.DragGaussianPulse","title":"<code>DragGaussianPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Gaussian-based DRAG pulse that compensate for the leakage and AC stark shift.</p> <p>These DRAG waveforms has been implemented following the next Refs.: Chen et al. PRL, 116, 020501 (2016) https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501 and Chen's thesis https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The pulse length in ns.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>amplitude</code> <code>float</code> <p>The amplitude in volts.</p> required <code>sigma</code> <code>float</code> <p>The gaussian standard deviation.</p> required <code>alpha</code> <code>float</code> <p>The DRAG coefficient.</p> required <code>anharmonicity</code> <code>float</code> <p>f_21 - f_10 - The differences in energy between the 2-1 and the 1-0 energy levels, in Hz.</p> required <code>detuning</code> <code>float</code> <p>The frequency shift to correct for AC stark shift, in Hz.</p> required <code>subtracted</code> <code>bool</code> <p>If true, returns a subtracted Gaussian, such that the first and last points will be at 0 volts. This reduces high-frequency components due to the initial and final points offset. Default is true.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass DragGaussianPulse(Pulse):\n    \"\"\"Gaussian-based DRAG pulse that compensate for the leakage and AC stark shift.\n\n    These DRAG waveforms has been implemented following the next Refs.:\n    Chen et al. PRL, 116, 020501 (2016)\n    https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501\n    and Chen's thesis\n    https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf\n\n    Args:\n        length (int): The pulse length in ns.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        amplitude (float): The amplitude in volts.\n        sigma (float): The gaussian standard deviation.\n        alpha (float): The DRAG coefficient.\n        anharmonicity (float): f_21 - f_10 - The differences in energy between the 2-1\n            and the 1-0 energy levels, in Hz.\n        detuning (float): The frequency shift to correct for AC stark shift, in Hz.\n        subtracted (bool): If true, returns a subtracted Gaussian, such that the first\n            and last points will be at 0 volts. This reduces high-frequency components\n            due to the initial and final points offset. Default is true.\n\n    \"\"\"\n\n    axis_angle: float\n    amplitude: float\n    sigma: float\n    alpha: float\n    anharmonicity: float\n    detuning: float = 0.0\n    subtracted: bool = True\n\n    def __post_init__(self) -&gt; None:\n        return super().__post_init__()\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import drag_gaussian_pulse_waveforms\n\n        I, Q = drag_gaussian_pulse_waveforms(\n            amplitude=self.amplitude,\n            length=self.length,\n            sigma=self.sigma,\n            alpha=self.alpha,\n            anharmonicity=self.anharmonicity,\n            detuning=self.detuning,\n            subtracted=self.subtracted,\n        )\n        I, Q = np.array(I), np.array(Q)\n\n        I_rot = I * np.cos(self.axis_angle) - Q * np.sin(self.axis_angle)\n        Q_rot = I * np.sin(self.axis_angle) + Q * np.cos(self.axis_angle)\n\n        return I_rot + 1.0j * Q_rot\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.FlatTopBlackmanPulse","title":"<code>FlatTopBlackmanPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Blackman rise/fall, flat-top pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Total pulse length (samples).</p> required <code>amplitude</code> <code>float</code> <p>Peak amplitude (V).</p> required <code>flat_length</code> <code>int</code> <p>Flat-top length (samples).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopBlackmanPulse(Pulse):\n    \"\"\"Blackman rise/fall, flat-top pulse.\n\n    Args:\n        length (int): Total pulse length (samples).\n        amplitude (float): Peak amplitude (V).\n        flat_length (int): Flat-top length (samples).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_blackman_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if self.flat_length + 2 * rise_fall_length != self.length:\n            raise ValueError(\n                \"FlatTopBlackmanPulse requires (length - flat_length) to be even \"\n                f\"({self.length=} {self.flat_length=})\"\n            )\n\n        wf = flattop_blackman_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.FlatTopCosinePulse","title":"<code>FlatTopCosinePulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Cosine rise/fall, flat-top pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Total pulse length (samples).</p> required <code>amplitude</code> <code>float</code> <p>Peak amplitude (V).</p> required <code>flat_length</code> <code>int</code> <p>Flat-top length (samples).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopCosinePulse(Pulse):\n    \"\"\"Cosine rise/fall, flat-top pulse.\n\n    Args:\n        length (int): Total pulse length (samples).\n        amplitude (float): Peak amplitude (V).\n        flat_length (int): Flat-top length (samples).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int = 0\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_cosine_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if self.flat_length + 2 * rise_fall_length != self.length:\n            raise ValueError(\n                \"FlatTopCosinePulse requires (length - flat_length) to be even \"\n                f\"({self.length=} {self.flat_length=})\"\n            )\n\n        wf = flattop_cosine_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.FlatTopGaussianPulse","title":"<code>FlatTopGaussianPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Gaussian pulse with flat top QUAM component.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The total length of the pulse in samples.</p> required <code>amplitude</code> <code>float</code> <p>The amplitude of the pulse in volts.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>flat_length</code> <code>int</code> <p>The length of the pulse's flat top in samples. The rise and fall lengths are calculated from the total length and the flat length.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopGaussianPulse(Pulse):\n    \"\"\"Gaussian pulse with flat top QUAM component.\n\n    Args:\n        length (int): The total length of the pulse in samples.\n        amplitude (float): The amplitude of the pulse in volts.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        flat_length (int): The length of the pulse's flat top in samples.\n            The rise and fall lengths are calculated from the total length and the\n            flat length.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_gaussian_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if not self.flat_length + 2 * rise_fall_length == self.length:\n            raise ValueError(\n                \"FlatTopGaussianPulse rise_fall_length (=length-flat_length) must be\"\n                f\" a multiple of 2 ({self.length} - {self.flat_length} =\"\n                f\" {self.length - self.flat_length})\"\n            )\n\n        waveform = flattop_gaussian_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        waveform = np.array(waveform)\n\n        if self.axis_angle is not None:\n            waveform = waveform * np.exp(1j * self.axis_angle)\n\n        return waveform\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.FlatTopTanhPulse","title":"<code>FlatTopTanhPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>tanh rise/fall, flat-top pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Total pulse length (samples).</p> required <code>amplitude</code> <code>float</code> <p>Peak amplitude (V).</p> required <code>flat_length</code> <code>int</code> <p>Flat-top length (samples).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopTanhPulse(Pulse):\n    \"\"\"tanh rise/fall, flat-top pulse.\n\n    Args:\n        length (int): Total pulse length (samples).\n        amplitude (float): Peak amplitude (V).\n        flat_length (int): Flat-top length (samples).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int = 0\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_tanh_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if self.flat_length + 2 * rise_fall_length != self.length:\n            raise ValueError(\n                \"FlatTopTanhPulse requires (length - flat_length) to be even \"\n                f\"({self.length=} {self.flat_length=})\"\n            )\n\n        wf = flattop_tanh_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.GaussianPulse","title":"<code>GaussianPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Gaussian pulse QUAM component.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>float</code> <p>The amplitude of the pulse in volts.</p> required <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation of the gaussian pulse. Should generally be less than half the length of the pulse.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>subtracted</code> <code>bool</code> <p>If true, returns a subtracted Gaussian, such that the first and last points will be at 0 volts. This reduces high-frequency components due to the initial and final points offset. Default is true.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass GaussianPulse(Pulse):\n    \"\"\"Gaussian pulse QUAM component.\n\n    Args:\n        amplitude (float): The amplitude of the pulse in volts.\n        length (int): The length of the pulse in samples.\n        sigma (float): The standard deviation of the gaussian pulse.\n            Should generally be less than half the length of the pulse.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        subtracted (bool): If true, returns a subtracted Gaussian, such that the first\n            and last points will be at 0 volts. This reduces high-frequency components\n            due to the initial and final points offset. Default is true.\n    \"\"\"\n\n    amplitude: float\n    length: int\n    sigma: float\n    axis_angle: float = None\n    subtracted: bool = True\n\n    def waveform_function(self):\n        t = np.arange(self.length, dtype=int)\n        center = (self.length - 1) / 2\n        waveform = self.amplitude * np.exp(-((t - center) ** 2) / (2 * self.sigma**2))\n\n        if self.subtracted:\n            waveform = waveform - waveform[-1]\n\n        if self.axis_angle is not None:\n            waveform = waveform * np.exp(1j * self.axis_angle)\n\n        return waveform\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.Pulse","title":"<code>Pulse</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM base component for a pulse.</p> <p>Pulses are added to a channel using <pre><code>channel.operations[\"pulse_name\"] = pulse\n</code></pre></p> <p>The <code>Pulse</code> class is an abstract base class, and should not be instantiated directly. Instead, use one of the subclasses such as: - <code>ConstantReadoutPulse</code> - <code>DragPulse</code> - <code>SquarePulse</code> - <code>GaussianPulse</code> or create a custom subclass. In this case, the method <code>waveform_function</code> should be implemented.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The operation of the pulse, either \"control\" or \"measurement\". Default is \"control\".</p> required <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Can be a string, in which case it is a reference to a digital marker in the config, or a list of tuples of (sample, length) pairs. Default is None.</p> required Note <p>The unique pulse label is automatically generated from the channel name and the pulse name, the same for the waveform and digital marker names. The pulse label is defined as <code>\"{channel_name}.{pulse_name}.pulse\"</code>. The waveform label is defined as <code>\"{channel_name}.{pulse_name}.wf\"</code>. The digital marker label is defined as <code>\"{channel_name}.{pulse_name}.dm\"</code>.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass Pulse(QuamComponent):\n    \"\"\"QUAM base component for a pulse.\n\n    Pulses are added to a channel using\n    ```\n    channel.operations[\"pulse_name\"] = pulse\n    ```\n\n    The `Pulse` class is an abstract base class, and should not be instantiated\n    directly. Instead, use one of the subclasses such as:\n    - `ConstantReadoutPulse`\n    - `DragPulse`\n    - `SquarePulse`\n    - `GaussianPulse`\n    or create a custom subclass. In this case, the method `waveform_function` should\n    be implemented.\n\n    Args:\n        operation (str): The operation of the pulse, either \"control\" or \"measurement\".\n            Default is \"control\".\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Can be a string, in which case it is a reference to a digital marker in the\n            config, or a list of tuples of (sample, length) pairs. Default is None.\n\n    Note:\n        The unique pulse label is automatically generated from the channel name and\n        the pulse name, the same for the waveform and digital marker names.\n        The pulse label is defined as `\"{channel_name}.{pulse_name}.pulse\"`.\n        The waveform label is defined as `\"{channel_name}.{pulse_name}.wf\"`.\n        The digital marker label is defined as `\"{channel_name}.{pulse_name}.dm\"`.\n\n    \"\"\"\n\n    operation: ClassVar[str] = \"control\"\n    length: int\n    id: str = None\n\n    digital_marker: Union[str, List[Tuple[int, int]]] = None\n\n    @property\n    def channel(self):\n        \"\"\"The channel to which the pulse is attached, None if no channel is attached\"\"\"\n        from quam.components.channels import Channel\n\n        if isinstance(self.parent, Channel):\n            return self.parent\n        elif hasattr(self.parent, \"parent\") and isinstance(self.parent.parent, Channel):\n            return self.parent.parent\n        else:\n            return None\n\n    @property\n    def name(self):\n        if self.channel is None:\n            raise AttributeError(\n                f\"Cannot get full name of pulse '{self}' because it is not\"\n                \" attached to a channel\"\n            )\n\n        if self.id is not None:\n            name = self.id\n        else:\n            name = self.parent.get_attr_name(self)\n\n        return f\"{self.channel.name}{str_ref.DELIMITER}{name}\"\n\n    @property\n    def pulse_name(self):\n        return f\"{self.name}{str_ref.DELIMITER}pulse\"\n\n    @property\n    def waveform_name(self):\n        return f\"{self.name}{str_ref.DELIMITER}wf\"\n\n    @property\n    def digital_marker_name(self):\n        return f\"{self.name}{str_ref.DELIMITER}dm\"\n\n    def calculate_waveform(\n        self,\n    ) -&gt; Union[float, complex, Sequence[float], Sequence[complex]]:\n        \"\"\"Calculate the waveform of the pulse.\n\n        This function calls `Pulse.waveform_function`, which should generally be\n        subclassed, to generate the waveform.\n\n        This function then processes the results such that IQ waveforms are cast\n        into complex values.\n\n        Returns:\n            The processed waveform, which can be either\n            - a single float for a constant single-channel waveform,\n            - a single complex number for a constant IQ waveform,\n            - a sequence of floats for an arbitrary single-channel waveform,\n            - a sequence of complex numbers for an arbitrary IQ waveform,\n        \"\"\"\n        waveform = self.waveform_function()\n\n        # Optionally convert IQ waveforms to complex waveform\n        if isinstance(waveform, tuple) and len(waveform) == 2:\n            if isinstance(waveform[0], (list, np.ndarray)):\n                waveform = np.array(waveform[0]) + 1.0j * np.array(waveform[1])\n            else:\n                waveform = waveform[0] + 1.0j * waveform[1]\n\n        return waveform\n\n    def waveform_function(\n        self,\n    ) -&gt; Union[\n        float,\n        complex,\n        Sequence[float],\n        Sequence[complex],\n        Tuple[float, float],\n        Tuple[Sequence[float], Sequence[float]],\n    ]:\n        \"\"\"Function that returns the waveform of the pulse.\n\n        The waveform function should use the relevant parameters from the pulse, which\n        is passed as the only argument.\n\n        This function is called from `Pulse.calculate_waveform`\n\n        Returns:\n            The waveform of the pulse. Can be one of the following:\n            - a single float for a constant single-channel waveform,\n            - a single complex number for a constant IQ waveform,\n            - a sequence of floats for an arbitrary single-channel waveform,\n            - a sequence of complex numbers for an arbitrary IQ waveform,\n            - a tuple of floats for a constant IQ waveform,\n            - a tuple of sequences for an arbitrary IQ waveform\n        \"\"\"\n        ...\n\n    def play(\n        self,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        duration: ScalarInt = None,\n        condition: ScalarBool = None,\n        chirp: ChirpType = None,\n        truncate: ScalarInt = None,\n        timestamp_stream: StreamType = None,\n        continue_chirp: bool = False,\n        target: str = \"\",\n        validate: bool = True,\n    ) -&gt; None:\n        \"\"\"Play the pulse on the channel.\n\n        The corresponding channel to play the pulse on is determined from the\n        parent of the pulse.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            duration (int): Duration of the pulse in units of the clock cycle (4ns).\n                If not provided, the default pulse duration will be used. It is possible\n                to dynamically change the duration of both constant and arbitrary\n                pulses. Arbitrary pulses can only be stretched, not compressed.\n            chirp (Union[(list[int], str), (int, str)]): Allows to perform\n                piecewise linear sweep of the element's intermediate\n                frequency in time. Input should be a tuple, with the 1st\n                element being a list of rates and the second should be a\n                string with the units. The units can be either: 'Hz/nsec',\n                'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n                'KHz/sec', 'Hz/sec', 'mHz/sec'.\n            truncate (Scalar[int]): Allows playing\n                only part of the pulse, truncating the end. If provided,\n                will play only up to the given time in units of the clock\n                cycle (4ns).\n            condition (Scalar[bool]): Will play analog\n                pulse only if the condition's value is true. Any digital\n                pulses associated with the operation will always play.\n            timestamp_stream (Union[str, _ResultSource]): (Supported from\n                QOP 2.2) Adding a `timestamp_stream` argument will save the\n                time at which the operation occurred to a stream. If the\n                `timestamp_stream` is a string ``label``, then the timestamp\n                handle can be retrieved with\n                `qm._results.JobResults.get` with the same ``label``.\n            validate (bool): If True (default), validate that the pulse is registered\n                in Channel.operations\n\n        Raises:\n            ValueError: If the pulse is not attached to a channel.\n            KeyError: If the pulse is not registered in the channel's operations.\n        \"\"\"\n        if self.id is not None:\n            name = self.id\n        elif self.parent is not None:\n            name = self.parent.get_attr_name(self)\n        else:\n            raise ValueError(f\"Cannot determine name of pulse '{self}'\")\n\n        if self.channel is None:\n            raise ValueError(f\"Pulse '{name}' is not attached to a channel\")\n\n        self.channel.play(\n            pulse_name=name,\n            amplitude_scale=amplitude_scale,\n            duration=duration,\n            condition=condition,\n            chirp=chirp,\n            truncate=truncate,\n            timestamp_stream=timestamp_stream,\n            continue_chirp=continue_chirp,\n            target=target,\n            validate=validate,\n        )\n\n    def _config_add_pulse(self, config: Dict[str, Any]):\n        \"\"\"Add the pulse to the config\n\n        The config entry is added to `config[\"pulses\"][self.pulse_name]`\n        \"\"\"\n        assert self.operation in [\"control\", \"measurement\"]\n        assert isinstance(self.length, int)\n\n        pulse_config = config[\"pulses\"][self.pulse_name] = {\n            \"operation\": self.operation,\n            \"length\": self.length,\n        }\n\n    def _config_add_waveforms(self, config):\n        \"\"\"Add the waveform to the config\n\n        For a single waveform, the config entry is added to\n        `config[\"waveforms\"][\"{channel_name}.{pulse_name}.wf\"]`.\n        For an IQ waveform, two config entries are added to\n        `config[\"waveforms\"][\"{channel_name}.{pulse_name}.wf.I\"]` and with suffix `Q`.\n\n        Raises:\n            ValueError: If the waveform type (single or IQ) does not match the parent\n                channel type (SingleChannel, IQChannel, InOutIQChannel, MWChannel,\n                InOutMWChannel).\n        \"\"\"\n\n        from quam.components.channels import IQChannel, MWChannel, SingleChannel\n\n        pulse_config = config[\"pulses\"][self.pulse_name]\n\n        waveform = self.calculate_waveform()\n        if waveform is None:\n            return\n\n        pulse_config[\"waveforms\"] = {}\n\n        if isinstance(waveform, numbers.Number):\n            wf_type = \"constant\"\n            if isinstance(waveform, complex):\n                waveforms = {\"I\": waveform.real, \"Q\": waveform.imag}\n            elif isinstance(self.channel, (IQChannel, MWChannel)):\n                waveforms = {\"I\": waveform, \"Q\": 0.0}\n            else:\n                waveforms = {\"single\": waveform}\n\n        elif isinstance(waveform, (list, np.ndarray)):\n            wf_type = \"arbitrary\"\n            if np.iscomplexobj(waveform):\n                waveforms = {\"I\": list(waveform.real), \"Q\": list(waveform.imag)}\n            elif isinstance(self.channel, (IQChannel, MWChannel)):\n                waveforms = {\"I\": list(waveform), \"Q\": list(np.zeros_like(waveform))}\n            else:\n                waveforms = {\"single\": list(waveform)}\n        else:\n            raise ValueError(\"unsupported return type\")\n\n        # Add check that waveform type (single or IQ) matches parent\n        if \"single\" in waveforms and not isinstance(self.channel, SingleChannel):\n            raise ValueError(\n                \"Waveform type 'single' not allowed for (IQChannel, MWChannel)\"\n                f\" '{self.channel.name}'\"\n            )\n        elif \"I\" in waveforms and not isinstance(self.channel, (IQChannel, MWChannel)):\n            raise ValueError(\n                \"Waveform type 'IQ' not allowed for SingleChannel\"\n                f\" '{self.channel.name}'\"\n            )\n\n        for suffix, waveform in waveforms.items():\n            waveform_name = self.waveform_name\n            if suffix != \"single\":\n                waveform_name += f\"{str_ref.DELIMITER}{suffix}\"\n\n            sample_label = \"sample\" if wf_type == \"constant\" else \"samples\"\n\n            config[\"waveforms\"][waveform_name] = {\n                \"type\": wf_type,\n                sample_label: waveform,\n            }\n            pulse_config[\"waveforms\"][suffix] = waveform_name\n\n    def _config_add_digital_markers(self, config):\n        \"\"\"Add the digital marker to the config\n\n        The config entry is added to\n        `config[\"digital_waveforms\"][\"{channel_name}.{pulse_name}.dm\"]` and also\n        registered in\n        `config[\"pulses\"][\"{channel_name}.{pulse_name}.pulse\"][\"digital_marker\"]`.\n\n        If the digital marker is a string, it is assumed to be a reference to a\n        digital marker already defined in the config.\n        \"\"\"\n        if isinstance(self.digital_marker, str):\n            # Use a common config digital marker\n            if self.digital_marker not in config[\"digital_waveforms\"]:\n                raise KeyError(\n                    \"{self.name}.digital_marker={self.digital_marker} not in\"\n                    \" config['digital_waveforms']\"\n                )\n            digital_marker_name = self.digital_marker\n        else:\n            digital_marker_list = [tuple(t) for t in self.digital_marker]\n            config[\"digital_waveforms\"][self.digital_marker_name] = {\n                \"samples\": digital_marker_list\n            }\n            digital_marker_name = self.digital_marker_name\n\n        config[\"pulses\"][self.pulse_name][\"digital_marker\"] = digital_marker_name\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Adds this pulse, waveform, and digital marker to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        if self.channel is None:\n            return\n\n        self._config_add_pulse(config)\n        self._config_add_waveforms(config)\n\n        if self.digital_marker:\n            self._config_add_digital_markers(config)\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.Pulse.channel","title":"<code>channel</code>  <code>property</code>","text":"<p>The channel to which the pulse is attached, None if no channel is attached</p>"},{"location":"API_references/components/pulses/#quam.components.pulses.Pulse.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this pulse, waveform, and digital marker to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Adds this pulse, waveform, and digital marker to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    if self.channel is None:\n        return\n\n    self._config_add_pulse(config)\n    self._config_add_waveforms(config)\n\n    if self.digital_marker:\n        self._config_add_digital_markers(config)\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.Pulse.calculate_waveform","title":"<code>calculate_waveform()</code>","text":"<p>Calculate the waveform of the pulse.</p> <p>This function calls <code>Pulse.waveform_function</code>, which should generally be subclassed, to generate the waveform.</p> <p>This function then processes the results such that IQ waveforms are cast into complex values.</p> <p>Returns:</p> Type Description <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <p>The processed waveform, which can be either</p> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a single float for a constant single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a single complex number for a constant IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a sequence of floats for an arbitrary single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a sequence of complex numbers for an arbitrary IQ waveform,</li> </ul> Source code in <code>quam/components/pulses.py</code> <pre><code>def calculate_waveform(\n    self,\n) -&gt; Union[float, complex, Sequence[float], Sequence[complex]]:\n    \"\"\"Calculate the waveform of the pulse.\n\n    This function calls `Pulse.waveform_function`, which should generally be\n    subclassed, to generate the waveform.\n\n    This function then processes the results such that IQ waveforms are cast\n    into complex values.\n\n    Returns:\n        The processed waveform, which can be either\n        - a single float for a constant single-channel waveform,\n        - a single complex number for a constant IQ waveform,\n        - a sequence of floats for an arbitrary single-channel waveform,\n        - a sequence of complex numbers for an arbitrary IQ waveform,\n    \"\"\"\n    waveform = self.waveform_function()\n\n    # Optionally convert IQ waveforms to complex waveform\n    if isinstance(waveform, tuple) and len(waveform) == 2:\n        if isinstance(waveform[0], (list, np.ndarray)):\n            waveform = np.array(waveform[0]) + 1.0j * np.array(waveform[1])\n        else:\n            waveform = waveform[0] + 1.0j * waveform[1]\n\n    return waveform\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.Pulse.play","title":"<code>play(amplitude_scale=None, duration=None, condition=None, chirp=None, truncate=None, timestamp_stream=None, continue_chirp=False, target='', validate=True)</code>","text":"<p>Play the pulse on the channel.</p> <p>The corresponding channel to play the pulse on is determined from the parent of the pulse.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>duration</code> <code>int</code> <p>Duration of the pulse in units of the clock cycle (4ns). If not provided, the default pulse duration will be used. It is possible to dynamically change the duration of both constant and arbitrary pulses. Arbitrary pulses can only be stretched, not compressed.</p> <code>None</code> <code>chirp</code> <code>Union[(list[int], str), (int, str)]</code> <p>Allows to perform piecewise linear sweep of the element's intermediate frequency in time. Input should be a tuple, with the 1st element being a list of rates and the second should be a string with the units. The units can be either: 'Hz/nsec', 'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec', 'KHz/sec', 'Hz/sec', 'mHz/sec'.</p> <code>None</code> <code>truncate</code> <code>Scalar[int]</code> <p>Allows playing only part of the pulse, truncating the end. If provided, will play only up to the given time in units of the clock cycle (4ns).</p> <code>None</code> <code>condition</code> <code>Scalar[bool]</code> <p>Will play analog pulse only if the condition's value is true. Any digital pulses associated with the operation will always play.</p> <code>None</code> <code>timestamp_stream</code> <code>Union[str, _ResultSource]</code> <p>(Supported from QOP 2.2) Adding a <code>timestamp_stream</code> argument will save the time at which the operation occurred to a stream. If the <code>timestamp_stream</code> is a string <code>label</code>, then the timestamp handle can be retrieved with <code>qm._results.JobResults.get</code> with the same <code>label</code>.</p> <code>None</code> <code>validate</code> <code>bool</code> <p>If True (default), validate that the pulse is registered in Channel.operations</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the pulse is not attached to a channel.</p> <code>KeyError</code> <p>If the pulse is not registered in the channel's operations.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>def play(\n    self,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    duration: ScalarInt = None,\n    condition: ScalarBool = None,\n    chirp: ChirpType = None,\n    truncate: ScalarInt = None,\n    timestamp_stream: StreamType = None,\n    continue_chirp: bool = False,\n    target: str = \"\",\n    validate: bool = True,\n) -&gt; None:\n    \"\"\"Play the pulse on the channel.\n\n    The corresponding channel to play the pulse on is determined from the\n    parent of the pulse.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        duration (int): Duration of the pulse in units of the clock cycle (4ns).\n            If not provided, the default pulse duration will be used. It is possible\n            to dynamically change the duration of both constant and arbitrary\n            pulses. Arbitrary pulses can only be stretched, not compressed.\n        chirp (Union[(list[int], str), (int, str)]): Allows to perform\n            piecewise linear sweep of the element's intermediate\n            frequency in time. Input should be a tuple, with the 1st\n            element being a list of rates and the second should be a\n            string with the units. The units can be either: 'Hz/nsec',\n            'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n            'KHz/sec', 'Hz/sec', 'mHz/sec'.\n        truncate (Scalar[int]): Allows playing\n            only part of the pulse, truncating the end. If provided,\n            will play only up to the given time in units of the clock\n            cycle (4ns).\n        condition (Scalar[bool]): Will play analog\n            pulse only if the condition's value is true. Any digital\n            pulses associated with the operation will always play.\n        timestamp_stream (Union[str, _ResultSource]): (Supported from\n            QOP 2.2) Adding a `timestamp_stream` argument will save the\n            time at which the operation occurred to a stream. If the\n            `timestamp_stream` is a string ``label``, then the timestamp\n            handle can be retrieved with\n            `qm._results.JobResults.get` with the same ``label``.\n        validate (bool): If True (default), validate that the pulse is registered\n            in Channel.operations\n\n    Raises:\n        ValueError: If the pulse is not attached to a channel.\n        KeyError: If the pulse is not registered in the channel's operations.\n    \"\"\"\n    if self.id is not None:\n        name = self.id\n    elif self.parent is not None:\n        name = self.parent.get_attr_name(self)\n    else:\n        raise ValueError(f\"Cannot determine name of pulse '{self}'\")\n\n    if self.channel is None:\n        raise ValueError(f\"Pulse '{name}' is not attached to a channel\")\n\n    self.channel.play(\n        pulse_name=name,\n        amplitude_scale=amplitude_scale,\n        duration=duration,\n        condition=condition,\n        chirp=chirp,\n        truncate=truncate,\n        timestamp_stream=timestamp_stream,\n        continue_chirp=continue_chirp,\n        target=target,\n        validate=validate,\n    )\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.Pulse.waveform_function","title":"<code>waveform_function()</code>","text":"<p>Function that returns the waveform of the pulse.</p> <p>The waveform function should use the relevant parameters from the pulse, which is passed as the only argument.</p> <p>This function is called from <code>Pulse.calculate_waveform</code></p> <p>Returns:</p> Type Description <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <p>The waveform of the pulse. Can be one of the following:</p> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a single float for a constant single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a single complex number for a constant IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a sequence of floats for an arbitrary single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a sequence of complex numbers for an arbitrary IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a tuple of floats for a constant IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a tuple of sequences for an arbitrary IQ waveform</li> </ul> Source code in <code>quam/components/pulses.py</code> <pre><code>def waveform_function(\n    self,\n) -&gt; Union[\n    float,\n    complex,\n    Sequence[float],\n    Sequence[complex],\n    Tuple[float, float],\n    Tuple[Sequence[float], Sequence[float]],\n]:\n    \"\"\"Function that returns the waveform of the pulse.\n\n    The waveform function should use the relevant parameters from the pulse, which\n    is passed as the only argument.\n\n    This function is called from `Pulse.calculate_waveform`\n\n    Returns:\n        The waveform of the pulse. Can be one of the following:\n        - a single float for a constant single-channel waveform,\n        - a single complex number for a constant IQ waveform,\n        - a sequence of floats for an arbitrary single-channel waveform,\n        - a sequence of complex numbers for an arbitrary IQ waveform,\n        - a tuple of floats for a constant IQ waveform,\n        - a tuple of sequences for an arbitrary IQ waveform\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.ReadoutPulse","title":"<code>ReadoutPulse</code>","text":"<p>               Bases: <code>BaseReadoutPulse</code>, <code>ABC</code></p> <p>QUAM abstract base component for most readout pulses.</p> <p>This class is a subclass of <code>ReadoutPulse</code> and should be used for most readout pulses. It provides a default implementation of the <code>integration_weights_function</code> method, which is suitable for most cases.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Default is \"ON\".</p> required <code>integration_weights</code> <code>(list[float], list[tuple[float, int]])</code> <p>The integration weights, can be either - a list of floats (one per sample), the length must match the pulse length - a list of tuples of (weight, length) pairs, the sum of the lengths must   match the pulse length</p> required <code>integration_weights_angle</code> <code>float</code> <p>The rotation angle for the integration weights in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass ReadoutPulse(BaseReadoutPulse, ABC):\n    \"\"\"QUAM abstract base component for most readout pulses.\n\n    This class is a subclass of `ReadoutPulse` and should be used for most readout\n    pulses. It provides a default implementation of the `integration_weights_function`\n    method, which is suitable for most cases.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Default is \"ON\".\n        integration_weights (list[float], list[tuple[float, int]], optional): The\n            integration weights, can be either\n            - a list of floats (one per sample), the length must match the pulse length\n            - a list of tuples of (weight, length) pairs, the sum of the lengths must\n              match the pulse length\n        integration_weights_angle (float, optional): The rotation angle for the\n            integration weights in radians.\n    \"\"\"\n\n    integration_weights: Union[List[float], List[Tuple[float, int]]] = (\n        \"#./default_integration_weights\"\n    )\n    integration_weights_angle: float = 0\n\n    @property\n    def default_integration_weights(self) -&gt; List[Tuple[float, int]]:\n        return [(1, self.length)]\n\n    def integration_weights_function(self) -&gt; List[Tuple[Union[complex, float], int]]:\n        from qualang_tools.config import convert_integration_weights\n\n        phase = np.exp(1j * self.integration_weights_angle)\n\n        if isinstance(self.integration_weights[0], float):\n            integration_weights = convert_integration_weights(self.integration_weights)\n        else:\n            integration_weights = self.integration_weights\n\n        return {\n            \"real\": [(phase.real * w, l) for w, l in integration_weights],\n            \"imag\": [(phase.imag * w, l) for w, l in integration_weights],\n            \"minus_real\": [(-phase.real * w, l) for w, l in integration_weights],\n            \"minus_imag\": [(-phase.imag * w, l) for w, l in integration_weights],\n        }\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.SquarePulse","title":"<code>SquarePulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Square pulse QUAM component.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse.</p> required <code>amplitude</code> <code>float</code> <p>The amplitude of the pulse in volts.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass SquarePulse(Pulse):\n    \"\"\"Square pulse QUAM component.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n        amplitude (float): The amplitude of the pulse in volts.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n\n    def waveform_function(self):\n        waveform = self.amplitude\n\n        if self.axis_angle is not None:\n            waveform = waveform * np.exp(1j * self.axis_angle)\n        return waveform\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.SquareReadoutPulse","title":"<code>SquareReadoutPulse</code>","text":"<p>               Bases: <code>ReadoutPulse</code>, <code>SquarePulse</code></p> <p>QUAM component for a square readout pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Default is \"ON\".</p> required <code>amplitude</code> <code>float</code> <p>The constant amplitude of the pulse.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>integration_weights</code> <code>(list[float], list[tuple[float, int]])</code> <p>The integration weights, can be either - a list of floats (one per sample), the length must match the pulse length - a list of tuples of (weight, length) pairs, the sum of the lengths must   match the pulse length</p> required <code>integration_weights_angle</code> <code>float</code> <p>The rotation angle for the integration weights in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass SquareReadoutPulse(ReadoutPulse, SquarePulse):\n    \"\"\"QUAM component for a square readout pulse.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Default is \"ON\".\n        amplitude (float): The constant amplitude of the pulse.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        integration_weights (list[float], list[tuple[float, int]], optional): The\n            integration weights, can be either\n            - a list of floats (one per sample), the length must match the pulse length\n            - a list of tuples of (weight, length) pairs, the sum of the lengths must\n              match the pulse length\n        integration_weights_angle (float, optional): The rotation angle for the\n            integration weights in radians.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"API_references/components/pulses/#quam.components.pulses.WaveformPulse","title":"<code>WaveformPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Pulse that uses a pre-defined waveform, as opposed to a function.</p> <p>For a single channel, only <code>waveform_I</code> is required. For an IQ channel, both <code>waveform_I</code> and <code>waveform_Q</code> are required.</p> <p>The length of the pulse is derived from the length of <code>waveform_I</code>.</p> <p>Parameters:</p> Name Type Description Default <code>waveform_I</code> <code>list[float]</code> <p>The in-phase waveform.</p> required <code>waveform_Q</code> <code>list[float]</code> <p>The quadrature waveform.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass WaveformPulse(Pulse):\n    \"\"\"Pulse that uses a pre-defined waveform, as opposed to a function.\n\n    For a single channel, only `waveform_I` is required.\n    For an IQ channel, both `waveform_I` and `waveform_Q` are required.\n\n    The length of the pulse is derived from the length of `waveform_I`.\n\n    Args:\n        waveform_I (list[float]): The in-phase waveform.\n        waveform_Q (list[float], optional): The quadrature waveform.\n    \"\"\"\n\n    waveform_I: List[float]  # pyright: ignore\n    waveform_Q: Optional[List[float]] = None\n    # Length is derived from the waveform_I length, but still needs to be declared\n    # to satisfy the dataclass, but we'll override its behavior\n    length: Optional[int] = None  # pyright: ignore\n\n    @property\n    def length(self):  # noqa: 811\n        if not isinstance(self.waveform_I, Iterable):\n            return None\n        return len(self.waveform_I)\n\n    @length.setter\n    def length(self, length: Optional[int]):\n        if length is not None and not isinstance(length, property):\n            raise AttributeError(f\"length is not writable with value {length}\")\n\n    def waveform_function(self):\n        if self.waveform_Q is None:\n            return np.array(self.waveform_I)\n        return np.array(self.waveform_I) + 1.0j * np.array(self.waveform_Q)\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        d = super().to_dict(follow_references, include_defaults)\n        d.pop(\"length\")\n        return d\n</code></pre>"},{"location":"API_references/components/pulses_API/","title":"QUAM Pulses API","text":"<p>Welcome to the QUAM Pulses API Documentation. The QUAM Pulses module offers a versatile framework for creating and controlling pulse schemes essential for quantum operations.  Information can be found in QUAM Pulses Documentation in the User Guide.</p> <p>This section provides detailed API references for various pulse types\u2014ranging from simple waveforms to complex modulated pulses\u2014tailored for precise quantum state manipulation and measurement. Explore the properties, methods, and examples to effectively integrate these pulse components into your quantum experiments.</p>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.BaseReadoutPulse","title":"<code>BaseReadoutPulse</code>","text":"<p>               Bases: <code>Pulse</code>, <code>ABC</code></p> <p>QUAM abstract base component for a general  readout pulse.</p> <p>Readout pulse classes should usually inherit from <code>ReadoutPulse</code>, the exception being when a custom integration weights function is required.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Default is \"ON\".</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass BaseReadoutPulse(Pulse, ABC):\n    \"\"\"QUAM abstract base component for a general  readout pulse.\n\n    Readout pulse classes should usually inherit from `ReadoutPulse`, the\n    exception being when a custom integration weights function is required.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Default is \"ON\".\n    \"\"\"\n\n    operation: ClassVar[str] = \"measurement\"\n    digital_marker: str = \"ON\"\n\n    # TODO Understand why the thresholds were added.\n    threshold: float = None\n    rus_exit_threshold: float = None\n\n    _weight_labels: ClassVar[List[str]] = [\"iw1\", \"iw2\", \"iw3\"]\n\n    @property\n    def integration_weights_names(self):\n        return [f\"{self.name}{str_ref.DELIMITER}{name}\" for name in self._weight_labels]\n\n    @property\n    def integration_weights_mapping(self):\n        return dict(zip(self._weight_labels, self.integration_weights_names))\n\n    @abstractmethod\n    def integration_weights_function(self) -&gt; Dict[str, List[Tuple[float, int]]]:\n        \"\"\"Abstract method to calculate the integration weights.\n\n        Returns:\n            Dict containing keys \"real\", \"imag\", \"minus_real\", \"minus_imag\".\n            Values are lists of tuples of (weight, length) pairs.\n        \"\"\"\n        ...\n\n    def _config_add_integration_weights(self, config: dict):\n        \"\"\"Add the integration weights to the config\"\"\"\n        integration_weights = self.integration_weights_function()\n\n        config[\"integration_weights\"][self.integration_weights_names[0]] = {\n            \"cosine\": integration_weights[\"real\"],\n            \"sine\": integration_weights[\"minus_imag\"],\n        }\n        config[\"integration_weights\"][self.integration_weights_names[1]] = {\n            \"cosine\": integration_weights[\"imag\"],\n            \"sine\": integration_weights[\"real\"],\n        }\n        config[\"integration_weights\"][self.integration_weights_names[2]] = {\n            \"cosine\": integration_weights[\"minus_imag\"],\n            \"sine\": integration_weights[\"minus_real\"],\n        }\n\n        pulse_config = config[\"pulses\"][self.pulse_name]\n        pulse_config[\"integration_weights\"] = self.integration_weights_mapping\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Adds this readout pulse to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        super().apply_to_config(config)\n        self._config_add_integration_weights(config)\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.BaseReadoutPulse.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this readout pulse to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Adds this readout pulse to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    super().apply_to_config(config)\n    self._config_add_integration_weights(config)\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.BaseReadoutPulse.integration_weights_function","title":"<code>integration_weights_function()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to calculate the integration weights.</p> <p>Returns:</p> Type Description <code>Dict[str, List[Tuple[float, int]]]</code> <p>Dict containing keys \"real\", \"imag\", \"minus_real\", \"minus_imag\".</p> <code>Dict[str, List[Tuple[float, int]]]</code> <p>Values are lists of tuples of (weight, length) pairs.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>@abstractmethod\ndef integration_weights_function(self) -&gt; Dict[str, List[Tuple[float, int]]]:\n    \"\"\"Abstract method to calculate the integration weights.\n\n    Returns:\n        Dict containing keys \"real\", \"imag\", \"minus_real\", \"minus_imag\".\n        Values are lists of tuples of (weight, length) pairs.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.BlackmanIntegralPulse","title":"<code>BlackmanIntegralPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Adiabatic Blackman-integral ramp from v_start to v_end.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Pulse length (samples).</p> required <code>v_start</code> <code>float</code> <p>Starting amplitude (V).</p> required <code>v_end</code> <code>float</code> <p>Ending amplitude (V).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass BlackmanIntegralPulse(Pulse):\n    \"\"\"Adiabatic Blackman-integral ramp from v_start to v_end.\n\n    Args:\n        length (int): Pulse length (samples).\n        v_start (float): Starting amplitude (V).\n        v_end (float): Ending amplitude (V).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    # amplitude: float\n    v_start: float\n    v_end: float\n    axis_angle: float = None\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import blackman_integral_waveform\n\n        wf = blackman_integral_waveform(\n            pulse_length=self.length,\n            v_start=self.v_start,\n            v_end=self.v_end,\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.DragCosinePulse","title":"<code>DragCosinePulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Cosine based DRAG pulse that compensate for the leakage and AC stark shift.</p> <p>These DRAG waveforms has been implemented following the next Refs.: Chen et al. PRL, 116, 020501 (2016) https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501 and Chen's thesis https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The pulse length in ns.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>amplitude</code> <code>float</code> <p>The amplitude in volts.</p> required <code>alpha</code> <code>float</code> <p>The DRAG coefficient.</p> required <code>anharmonicity</code> <code>float</code> <p>f_21 - f_10 - The differences in energy between the 2-1 and the 1-0 energy levels, in Hz.</p> required <code>detuning</code> <code>float</code> <p>The frequency shift to correct for AC stark shift, in Hz.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass DragCosinePulse(Pulse):\n    \"\"\"Cosine based DRAG pulse that compensate for the leakage and AC stark shift.\n\n    These DRAG waveforms has been implemented following the next Refs.:\n    Chen et al. PRL, 116, 020501 (2016)\n    https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501\n    and Chen's thesis\n    https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf\n\n    Args:\n        length (int): The pulse length in ns.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        amplitude (float): The amplitude in volts.\n        alpha (float): The DRAG coefficient.\n        anharmonicity (float): f_21 - f_10 - The differences in energy between the 2-1\n            and the 1-0 energy levels, in Hz.\n        detuning (float): The frequency shift to correct for AC stark shift, in Hz.\n    \"\"\"\n\n    axis_angle: float\n    amplitude: float\n    alpha: float\n    anharmonicity: float\n    detuning: float = 0.0\n\n    def __post_init__(self) -&gt; None:\n        return super().__post_init__()\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import drag_cosine_pulse_waveforms\n\n        I, Q = drag_cosine_pulse_waveforms(\n            amplitude=self.amplitude,\n            length=self.length,\n            alpha=self.alpha,\n            anharmonicity=self.anharmonicity,\n            detuning=self.detuning,\n        )\n        I, Q = np.array(I), np.array(Q)\n\n        I_rot = I * np.cos(self.axis_angle) - Q * np.sin(self.axis_angle)\n        Q_rot = I * np.sin(self.axis_angle) + Q * np.cos(self.axis_angle)\n\n        return I_rot + 1.0j * Q_rot\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.DragGaussianPulse","title":"<code>DragGaussianPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Gaussian-based DRAG pulse that compensate for the leakage and AC stark shift.</p> <p>These DRAG waveforms has been implemented following the next Refs.: Chen et al. PRL, 116, 020501 (2016) https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501 and Chen's thesis https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The pulse length in ns.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>amplitude</code> <code>float</code> <p>The amplitude in volts.</p> required <code>sigma</code> <code>float</code> <p>The gaussian standard deviation.</p> required <code>alpha</code> <code>float</code> <p>The DRAG coefficient.</p> required <code>anharmonicity</code> <code>float</code> <p>f_21 - f_10 - The differences in energy between the 2-1 and the 1-0 energy levels, in Hz.</p> required <code>detuning</code> <code>float</code> <p>The frequency shift to correct for AC stark shift, in Hz.</p> required <code>subtracted</code> <code>bool</code> <p>If true, returns a subtracted Gaussian, such that the first and last points will be at 0 volts. This reduces high-frequency components due to the initial and final points offset. Default is true.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass DragGaussianPulse(Pulse):\n    \"\"\"Gaussian-based DRAG pulse that compensate for the leakage and AC stark shift.\n\n    These DRAG waveforms has been implemented following the next Refs.:\n    Chen et al. PRL, 116, 020501 (2016)\n    https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.116.020501\n    and Chen's thesis\n    https://web.physics.ucsb.edu/~martinisgroup/theses/Chen2018.pdf\n\n    Args:\n        length (int): The pulse length in ns.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        amplitude (float): The amplitude in volts.\n        sigma (float): The gaussian standard deviation.\n        alpha (float): The DRAG coefficient.\n        anharmonicity (float): f_21 - f_10 - The differences in energy between the 2-1\n            and the 1-0 energy levels, in Hz.\n        detuning (float): The frequency shift to correct for AC stark shift, in Hz.\n        subtracted (bool): If true, returns a subtracted Gaussian, such that the first\n            and last points will be at 0 volts. This reduces high-frequency components\n            due to the initial and final points offset. Default is true.\n\n    \"\"\"\n\n    axis_angle: float\n    amplitude: float\n    sigma: float\n    alpha: float\n    anharmonicity: float\n    detuning: float = 0.0\n    subtracted: bool = True\n\n    def __post_init__(self) -&gt; None:\n        return super().__post_init__()\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import drag_gaussian_pulse_waveforms\n\n        I, Q = drag_gaussian_pulse_waveforms(\n            amplitude=self.amplitude,\n            length=self.length,\n            sigma=self.sigma,\n            alpha=self.alpha,\n            anharmonicity=self.anharmonicity,\n            detuning=self.detuning,\n            subtracted=self.subtracted,\n        )\n        I, Q = np.array(I), np.array(Q)\n\n        I_rot = I * np.cos(self.axis_angle) - Q * np.sin(self.axis_angle)\n        Q_rot = I * np.sin(self.axis_angle) + Q * np.cos(self.axis_angle)\n\n        return I_rot + 1.0j * Q_rot\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.FlatTopBlackmanPulse","title":"<code>FlatTopBlackmanPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Blackman rise/fall, flat-top pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Total pulse length (samples).</p> required <code>amplitude</code> <code>float</code> <p>Peak amplitude (V).</p> required <code>flat_length</code> <code>int</code> <p>Flat-top length (samples).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopBlackmanPulse(Pulse):\n    \"\"\"Blackman rise/fall, flat-top pulse.\n\n    Args:\n        length (int): Total pulse length (samples).\n        amplitude (float): Peak amplitude (V).\n        flat_length (int): Flat-top length (samples).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_blackman_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if self.flat_length + 2 * rise_fall_length != self.length:\n            raise ValueError(\n                \"FlatTopBlackmanPulse requires (length - flat_length) to be even \"\n                f\"({self.length=} {self.flat_length=})\"\n            )\n\n        wf = flattop_blackman_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.FlatTopCosinePulse","title":"<code>FlatTopCosinePulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Cosine rise/fall, flat-top pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Total pulse length (samples).</p> required <code>amplitude</code> <code>float</code> <p>Peak amplitude (V).</p> required <code>flat_length</code> <code>int</code> <p>Flat-top length (samples).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopCosinePulse(Pulse):\n    \"\"\"Cosine rise/fall, flat-top pulse.\n\n    Args:\n        length (int): Total pulse length (samples).\n        amplitude (float): Peak amplitude (V).\n        flat_length (int): Flat-top length (samples).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int = 0\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_cosine_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if self.flat_length + 2 * rise_fall_length != self.length:\n            raise ValueError(\n                \"FlatTopCosinePulse requires (length - flat_length) to be even \"\n                f\"({self.length=} {self.flat_length=})\"\n            )\n\n        wf = flattop_cosine_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.FlatTopGaussianPulse","title":"<code>FlatTopGaussianPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Gaussian pulse with flat top QUAM component.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The total length of the pulse in samples.</p> required <code>amplitude</code> <code>float</code> <p>The amplitude of the pulse in volts.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>flat_length</code> <code>int</code> <p>The length of the pulse's flat top in samples. The rise and fall lengths are calculated from the total length and the flat length.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopGaussianPulse(Pulse):\n    \"\"\"Gaussian pulse with flat top QUAM component.\n\n    Args:\n        length (int): The total length of the pulse in samples.\n        amplitude (float): The amplitude of the pulse in volts.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        flat_length (int): The length of the pulse's flat top in samples.\n            The rise and fall lengths are calculated from the total length and the\n            flat length.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_gaussian_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if not self.flat_length + 2 * rise_fall_length == self.length:\n            raise ValueError(\n                \"FlatTopGaussianPulse rise_fall_length (=length-flat_length) must be\"\n                f\" a multiple of 2 ({self.length} - {self.flat_length} =\"\n                f\" {self.length - self.flat_length})\"\n            )\n\n        waveform = flattop_gaussian_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        waveform = np.array(waveform)\n\n        if self.axis_angle is not None:\n            waveform = waveform * np.exp(1j * self.axis_angle)\n\n        return waveform\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.FlatTopTanhPulse","title":"<code>FlatTopTanhPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>tanh rise/fall, flat-top pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Total pulse length (samples).</p> required <code>amplitude</code> <code>float</code> <p>Peak amplitude (V).</p> required <code>flat_length</code> <code>int</code> <p>Flat-top length (samples).</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass FlatTopTanhPulse(Pulse):\n    \"\"\"tanh rise/fall, flat-top pulse.\n\n    Args:\n        length (int): Total pulse length (samples).\n        amplitude (float): Peak amplitude (V).\n        flat_length (int): Flat-top length (samples).\n        axis_angle (float, optional): IQ axis angle in radians.\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n    flat_length: int = 0\n\n    def waveform_function(self):\n        from qualang_tools.config.waveform_tools import flattop_tanh_waveform\n\n        rise_fall_length = (self.length - self.flat_length) // 2\n        if self.flat_length + 2 * rise_fall_length != self.length:\n            raise ValueError(\n                \"FlatTopTanhPulse requires (length - flat_length) to be even \"\n                f\"({self.length=} {self.flat_length=})\"\n            )\n\n        wf = flattop_tanh_waveform(\n            amplitude=self.amplitude,\n            flat_length=self.flat_length,\n            rise_fall_length=rise_fall_length,\n            return_part=\"all\",\n        )\n        wf = np.array(wf)\n        if self.axis_angle is not None:\n            wf = wf * np.exp(1j * self.axis_angle)\n        return wf\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.GaussianPulse","title":"<code>GaussianPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Gaussian pulse QUAM component.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>float</code> <p>The amplitude of the pulse in volts.</p> required <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation of the gaussian pulse. Should generally be less than half the length of the pulse.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>subtracted</code> <code>bool</code> <p>If true, returns a subtracted Gaussian, such that the first and last points will be at 0 volts. This reduces high-frequency components due to the initial and final points offset. Default is true.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass GaussianPulse(Pulse):\n    \"\"\"Gaussian pulse QUAM component.\n\n    Args:\n        amplitude (float): The amplitude of the pulse in volts.\n        length (int): The length of the pulse in samples.\n        sigma (float): The standard deviation of the gaussian pulse.\n            Should generally be less than half the length of the pulse.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        subtracted (bool): If true, returns a subtracted Gaussian, such that the first\n            and last points will be at 0 volts. This reduces high-frequency components\n            due to the initial and final points offset. Default is true.\n    \"\"\"\n\n    amplitude: float\n    length: int\n    sigma: float\n    axis_angle: float = None\n    subtracted: bool = True\n\n    def waveform_function(self):\n        t = np.arange(self.length, dtype=int)\n        center = (self.length - 1) / 2\n        waveform = self.amplitude * np.exp(-((t - center) ** 2) / (2 * self.sigma**2))\n\n        if self.subtracted:\n            waveform = waveform - waveform[-1]\n\n        if self.axis_angle is not None:\n            waveform = waveform * np.exp(1j * self.axis_angle)\n\n        return waveform\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.Pulse","title":"<code>Pulse</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>QUAM base component for a pulse.</p> <p>Pulses are added to a channel using <pre><code>channel.operations[\"pulse_name\"] = pulse\n</code></pre></p> <p>The <code>Pulse</code> class is an abstract base class, and should not be instantiated directly. Instead, use one of the subclasses such as: - <code>ConstantReadoutPulse</code> - <code>DragPulse</code> - <code>SquarePulse</code> - <code>GaussianPulse</code> or create a custom subclass. In this case, the method <code>waveform_function</code> should be implemented.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The operation of the pulse, either \"control\" or \"measurement\". Default is \"control\".</p> required <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Can be a string, in which case it is a reference to a digital marker in the config, or a list of tuples of (sample, length) pairs. Default is None.</p> required Note <p>The unique pulse label is automatically generated from the channel name and the pulse name, the same for the waveform and digital marker names. The pulse label is defined as <code>\"{channel_name}.{pulse_name}.pulse\"</code>. The waveform label is defined as <code>\"{channel_name}.{pulse_name}.wf\"</code>. The digital marker label is defined as <code>\"{channel_name}.{pulse_name}.dm\"</code>.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass Pulse(QuamComponent):\n    \"\"\"QUAM base component for a pulse.\n\n    Pulses are added to a channel using\n    ```\n    channel.operations[\"pulse_name\"] = pulse\n    ```\n\n    The `Pulse` class is an abstract base class, and should not be instantiated\n    directly. Instead, use one of the subclasses such as:\n    - `ConstantReadoutPulse`\n    - `DragPulse`\n    - `SquarePulse`\n    - `GaussianPulse`\n    or create a custom subclass. In this case, the method `waveform_function` should\n    be implemented.\n\n    Args:\n        operation (str): The operation of the pulse, either \"control\" or \"measurement\".\n            Default is \"control\".\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Can be a string, in which case it is a reference to a digital marker in the\n            config, or a list of tuples of (sample, length) pairs. Default is None.\n\n    Note:\n        The unique pulse label is automatically generated from the channel name and\n        the pulse name, the same for the waveform and digital marker names.\n        The pulse label is defined as `\"{channel_name}.{pulse_name}.pulse\"`.\n        The waveform label is defined as `\"{channel_name}.{pulse_name}.wf\"`.\n        The digital marker label is defined as `\"{channel_name}.{pulse_name}.dm\"`.\n\n    \"\"\"\n\n    operation: ClassVar[str] = \"control\"\n    length: int\n    id: str = None\n\n    digital_marker: Union[str, List[Tuple[int, int]]] = None\n\n    @property\n    def channel(self):\n        \"\"\"The channel to which the pulse is attached, None if no channel is attached\"\"\"\n        from quam.components.channels import Channel\n\n        if isinstance(self.parent, Channel):\n            return self.parent\n        elif hasattr(self.parent, \"parent\") and isinstance(self.parent.parent, Channel):\n            return self.parent.parent\n        else:\n            return None\n\n    @property\n    def name(self):\n        if self.channel is None:\n            raise AttributeError(\n                f\"Cannot get full name of pulse '{self}' because it is not\"\n                \" attached to a channel\"\n            )\n\n        if self.id is not None:\n            name = self.id\n        else:\n            name = self.parent.get_attr_name(self)\n\n        return f\"{self.channel.name}{str_ref.DELIMITER}{name}\"\n\n    @property\n    def pulse_name(self):\n        return f\"{self.name}{str_ref.DELIMITER}pulse\"\n\n    @property\n    def waveform_name(self):\n        return f\"{self.name}{str_ref.DELIMITER}wf\"\n\n    @property\n    def digital_marker_name(self):\n        return f\"{self.name}{str_ref.DELIMITER}dm\"\n\n    def calculate_waveform(\n        self,\n    ) -&gt; Union[float, complex, Sequence[float], Sequence[complex]]:\n        \"\"\"Calculate the waveform of the pulse.\n\n        This function calls `Pulse.waveform_function`, which should generally be\n        subclassed, to generate the waveform.\n\n        This function then processes the results such that IQ waveforms are cast\n        into complex values.\n\n        Returns:\n            The processed waveform, which can be either\n            - a single float for a constant single-channel waveform,\n            - a single complex number for a constant IQ waveform,\n            - a sequence of floats for an arbitrary single-channel waveform,\n            - a sequence of complex numbers for an arbitrary IQ waveform,\n        \"\"\"\n        waveform = self.waveform_function()\n\n        # Optionally convert IQ waveforms to complex waveform\n        if isinstance(waveform, tuple) and len(waveform) == 2:\n            if isinstance(waveform[0], (list, np.ndarray)):\n                waveform = np.array(waveform[0]) + 1.0j * np.array(waveform[1])\n            else:\n                waveform = waveform[0] + 1.0j * waveform[1]\n\n        return waveform\n\n    def waveform_function(\n        self,\n    ) -&gt; Union[\n        float,\n        complex,\n        Sequence[float],\n        Sequence[complex],\n        Tuple[float, float],\n        Tuple[Sequence[float], Sequence[float]],\n    ]:\n        \"\"\"Function that returns the waveform of the pulse.\n\n        The waveform function should use the relevant parameters from the pulse, which\n        is passed as the only argument.\n\n        This function is called from `Pulse.calculate_waveform`\n\n        Returns:\n            The waveform of the pulse. Can be one of the following:\n            - a single float for a constant single-channel waveform,\n            - a single complex number for a constant IQ waveform,\n            - a sequence of floats for an arbitrary single-channel waveform,\n            - a sequence of complex numbers for an arbitrary IQ waveform,\n            - a tuple of floats for a constant IQ waveform,\n            - a tuple of sequences for an arbitrary IQ waveform\n        \"\"\"\n        ...\n\n    def play(\n        self,\n        amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n        duration: ScalarInt = None,\n        condition: ScalarBool = None,\n        chirp: ChirpType = None,\n        truncate: ScalarInt = None,\n        timestamp_stream: StreamType = None,\n        continue_chirp: bool = False,\n        target: str = \"\",\n        validate: bool = True,\n    ) -&gt; None:\n        \"\"\"Play the pulse on the channel.\n\n        The corresponding channel to play the pulse on is determined from the\n        parent of the pulse.\n\n        Args:\n            pulse_name (str): The name of the pulse to play. Should be registered in\n                `self.operations`.\n            amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n                Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n                (qua) floats. If None, the pulse is played without amplitude scaling.\n            duration (int): Duration of the pulse in units of the clock cycle (4ns).\n                If not provided, the default pulse duration will be used. It is possible\n                to dynamically change the duration of both constant and arbitrary\n                pulses. Arbitrary pulses can only be stretched, not compressed.\n            chirp (Union[(list[int], str), (int, str)]): Allows to perform\n                piecewise linear sweep of the element's intermediate\n                frequency in time. Input should be a tuple, with the 1st\n                element being a list of rates and the second should be a\n                string with the units. The units can be either: 'Hz/nsec',\n                'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n                'KHz/sec', 'Hz/sec', 'mHz/sec'.\n            truncate (Scalar[int]): Allows playing\n                only part of the pulse, truncating the end. If provided,\n                will play only up to the given time in units of the clock\n                cycle (4ns).\n            condition (Scalar[bool]): Will play analog\n                pulse only if the condition's value is true. Any digital\n                pulses associated with the operation will always play.\n            timestamp_stream (Union[str, _ResultSource]): (Supported from\n                QOP 2.2) Adding a `timestamp_stream` argument will save the\n                time at which the operation occurred to a stream. If the\n                `timestamp_stream` is a string ``label``, then the timestamp\n                handle can be retrieved with\n                `qm._results.JobResults.get` with the same ``label``.\n            validate (bool): If True (default), validate that the pulse is registered\n                in Channel.operations\n\n        Raises:\n            ValueError: If the pulse is not attached to a channel.\n            KeyError: If the pulse is not registered in the channel's operations.\n        \"\"\"\n        if self.id is not None:\n            name = self.id\n        elif self.parent is not None:\n            name = self.parent.get_attr_name(self)\n        else:\n            raise ValueError(f\"Cannot determine name of pulse '{self}'\")\n\n        if self.channel is None:\n            raise ValueError(f\"Pulse '{name}' is not attached to a channel\")\n\n        self.channel.play(\n            pulse_name=name,\n            amplitude_scale=amplitude_scale,\n            duration=duration,\n            condition=condition,\n            chirp=chirp,\n            truncate=truncate,\n            timestamp_stream=timestamp_stream,\n            continue_chirp=continue_chirp,\n            target=target,\n            validate=validate,\n        )\n\n    def _config_add_pulse(self, config: Dict[str, Any]):\n        \"\"\"Add the pulse to the config\n\n        The config entry is added to `config[\"pulses\"][self.pulse_name]`\n        \"\"\"\n        assert self.operation in [\"control\", \"measurement\"]\n        assert isinstance(self.length, int)\n\n        pulse_config = config[\"pulses\"][self.pulse_name] = {\n            \"operation\": self.operation,\n            \"length\": self.length,\n        }\n\n    def _config_add_waveforms(self, config):\n        \"\"\"Add the waveform to the config\n\n        For a single waveform, the config entry is added to\n        `config[\"waveforms\"][\"{channel_name}.{pulse_name}.wf\"]`.\n        For an IQ waveform, two config entries are added to\n        `config[\"waveforms\"][\"{channel_name}.{pulse_name}.wf.I\"]` and with suffix `Q`.\n\n        Raises:\n            ValueError: If the waveform type (single or IQ) does not match the parent\n                channel type (SingleChannel, IQChannel, InOutIQChannel, MWChannel,\n                InOutMWChannel).\n        \"\"\"\n\n        from quam.components.channels import IQChannel, MWChannel, SingleChannel\n\n        pulse_config = config[\"pulses\"][self.pulse_name]\n\n        waveform = self.calculate_waveform()\n        if waveform is None:\n            return\n\n        pulse_config[\"waveforms\"] = {}\n\n        if isinstance(waveform, numbers.Number):\n            wf_type = \"constant\"\n            if isinstance(waveform, complex):\n                waveforms = {\"I\": waveform.real, \"Q\": waveform.imag}\n            elif isinstance(self.channel, (IQChannel, MWChannel)):\n                waveforms = {\"I\": waveform, \"Q\": 0.0}\n            else:\n                waveforms = {\"single\": waveform}\n\n        elif isinstance(waveform, (list, np.ndarray)):\n            wf_type = \"arbitrary\"\n            if np.iscomplexobj(waveform):\n                waveforms = {\"I\": list(waveform.real), \"Q\": list(waveform.imag)}\n            elif isinstance(self.channel, (IQChannel, MWChannel)):\n                waveforms = {\"I\": list(waveform), \"Q\": list(np.zeros_like(waveform))}\n            else:\n                waveforms = {\"single\": list(waveform)}\n        else:\n            raise ValueError(\"unsupported return type\")\n\n        # Add check that waveform type (single or IQ) matches parent\n        if \"single\" in waveforms and not isinstance(self.channel, SingleChannel):\n            raise ValueError(\n                \"Waveform type 'single' not allowed for (IQChannel, MWChannel)\"\n                f\" '{self.channel.name}'\"\n            )\n        elif \"I\" in waveforms and not isinstance(self.channel, (IQChannel, MWChannel)):\n            raise ValueError(\n                \"Waveform type 'IQ' not allowed for SingleChannel\"\n                f\" '{self.channel.name}'\"\n            )\n\n        for suffix, waveform in waveforms.items():\n            waveform_name = self.waveform_name\n            if suffix != \"single\":\n                waveform_name += f\"{str_ref.DELIMITER}{suffix}\"\n\n            sample_label = \"sample\" if wf_type == \"constant\" else \"samples\"\n\n            config[\"waveforms\"][waveform_name] = {\n                \"type\": wf_type,\n                sample_label: waveform,\n            }\n            pulse_config[\"waveforms\"][suffix] = waveform_name\n\n    def _config_add_digital_markers(self, config):\n        \"\"\"Add the digital marker to the config\n\n        The config entry is added to\n        `config[\"digital_waveforms\"][\"{channel_name}.{pulse_name}.dm\"]` and also\n        registered in\n        `config[\"pulses\"][\"{channel_name}.{pulse_name}.pulse\"][\"digital_marker\"]`.\n\n        If the digital marker is a string, it is assumed to be a reference to a\n        digital marker already defined in the config.\n        \"\"\"\n        if isinstance(self.digital_marker, str):\n            # Use a common config digital marker\n            if self.digital_marker not in config[\"digital_waveforms\"]:\n                raise KeyError(\n                    \"{self.name}.digital_marker={self.digital_marker} not in\"\n                    \" config['digital_waveforms']\"\n                )\n            digital_marker_name = self.digital_marker\n        else:\n            digital_marker_list = [tuple(t) for t in self.digital_marker]\n            config[\"digital_waveforms\"][self.digital_marker_name] = {\n                \"samples\": digital_marker_list\n            }\n            digital_marker_name = self.digital_marker_name\n\n        config[\"pulses\"][self.pulse_name][\"digital_marker\"] = digital_marker_name\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Adds this pulse, waveform, and digital marker to the QUA configuration.\n\n        See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n        for details.\n        \"\"\"\n        if self.channel is None:\n            return\n\n        self._config_add_pulse(config)\n        self._config_add_waveforms(config)\n\n        if self.digital_marker:\n            self._config_add_digital_markers(config)\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.Pulse.channel","title":"<code>channel</code>  <code>property</code>","text":"<p>The channel to which the pulse is attached, None if no channel is attached</p>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.Pulse.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Adds this pulse, waveform, and digital marker to the QUA configuration.</p> <p>See <code>QuamComponent.apply_to_config</code> for details.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Adds this pulse, waveform, and digital marker to the QUA configuration.\n\n    See [`QuamComponent.apply_to_config`][quam.core.quam_classes.QuamComponent.apply_to_config]\n    for details.\n    \"\"\"\n    if self.channel is None:\n        return\n\n    self._config_add_pulse(config)\n    self._config_add_waveforms(config)\n\n    if self.digital_marker:\n        self._config_add_digital_markers(config)\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.Pulse.calculate_waveform","title":"<code>calculate_waveform()</code>","text":"<p>Calculate the waveform of the pulse.</p> <p>This function calls <code>Pulse.waveform_function</code>, which should generally be subclassed, to generate the waveform.</p> <p>This function then processes the results such that IQ waveforms are cast into complex values.</p> <p>Returns:</p> Type Description <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <p>The processed waveform, which can be either</p> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a single float for a constant single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a single complex number for a constant IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a sequence of floats for an arbitrary single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex]]</code> <ul> <li>a sequence of complex numbers for an arbitrary IQ waveform,</li> </ul> Source code in <code>quam/components/pulses.py</code> <pre><code>def calculate_waveform(\n    self,\n) -&gt; Union[float, complex, Sequence[float], Sequence[complex]]:\n    \"\"\"Calculate the waveform of the pulse.\n\n    This function calls `Pulse.waveform_function`, which should generally be\n    subclassed, to generate the waveform.\n\n    This function then processes the results such that IQ waveforms are cast\n    into complex values.\n\n    Returns:\n        The processed waveform, which can be either\n        - a single float for a constant single-channel waveform,\n        - a single complex number for a constant IQ waveform,\n        - a sequence of floats for an arbitrary single-channel waveform,\n        - a sequence of complex numbers for an arbitrary IQ waveform,\n    \"\"\"\n    waveform = self.waveform_function()\n\n    # Optionally convert IQ waveforms to complex waveform\n    if isinstance(waveform, tuple) and len(waveform) == 2:\n        if isinstance(waveform[0], (list, np.ndarray)):\n            waveform = np.array(waveform[0]) + 1.0j * np.array(waveform[1])\n        else:\n            waveform = waveform[0] + 1.0j * waveform[1]\n\n    return waveform\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.Pulse.play","title":"<code>play(amplitude_scale=None, duration=None, condition=None, chirp=None, truncate=None, timestamp_stream=None, continue_chirp=False, target='', validate=True)</code>","text":"<p>Play the pulse on the channel.</p> <p>The corresponding channel to play the pulse on is determined from the parent of the pulse.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse to play. Should be registered in <code>self.operations</code>.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>Amplitude scale of the pulse. Can be either a (qua) float, or a list of (qua) floats. If None, the pulse is played without amplitude scaling.</p> <code>None</code> <code>duration</code> <code>int</code> <p>Duration of the pulse in units of the clock cycle (4ns). If not provided, the default pulse duration will be used. It is possible to dynamically change the duration of both constant and arbitrary pulses. Arbitrary pulses can only be stretched, not compressed.</p> <code>None</code> <code>chirp</code> <code>Union[(list[int], str), (int, str)]</code> <p>Allows to perform piecewise linear sweep of the element's intermediate frequency in time. Input should be a tuple, with the 1st element being a list of rates and the second should be a string with the units. The units can be either: 'Hz/nsec', 'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec', 'KHz/sec', 'Hz/sec', 'mHz/sec'.</p> <code>None</code> <code>truncate</code> <code>Scalar[int]</code> <p>Allows playing only part of the pulse, truncating the end. If provided, will play only up to the given time in units of the clock cycle (4ns).</p> <code>None</code> <code>condition</code> <code>Scalar[bool]</code> <p>Will play analog pulse only if the condition's value is true. Any digital pulses associated with the operation will always play.</p> <code>None</code> <code>timestamp_stream</code> <code>Union[str, _ResultSource]</code> <p>(Supported from QOP 2.2) Adding a <code>timestamp_stream</code> argument will save the time at which the operation occurred to a stream. If the <code>timestamp_stream</code> is a string <code>label</code>, then the timestamp handle can be retrieved with <code>qm._results.JobResults.get</code> with the same <code>label</code>.</p> <code>None</code> <code>validate</code> <code>bool</code> <p>If True (default), validate that the pulse is registered in Channel.operations</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the pulse is not attached to a channel.</p> <code>KeyError</code> <p>If the pulse is not registered in the channel's operations.</p> Source code in <code>quam/components/pulses.py</code> <pre><code>def play(\n    self,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]] = None,\n    duration: ScalarInt = None,\n    condition: ScalarBool = None,\n    chirp: ChirpType = None,\n    truncate: ScalarInt = None,\n    timestamp_stream: StreamType = None,\n    continue_chirp: bool = False,\n    target: str = \"\",\n    validate: bool = True,\n) -&gt; None:\n    \"\"\"Play the pulse on the channel.\n\n    The corresponding channel to play the pulse on is determined from the\n    parent of the pulse.\n\n    Args:\n        pulse_name (str): The name of the pulse to play. Should be registered in\n            `self.operations`.\n        amplitude_scale (Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]):\n            Amplitude scale of the pulse. Can be either a (qua) float, or a list of\n            (qua) floats. If None, the pulse is played without amplitude scaling.\n        duration (int): Duration of the pulse in units of the clock cycle (4ns).\n            If not provided, the default pulse duration will be used. It is possible\n            to dynamically change the duration of both constant and arbitrary\n            pulses. Arbitrary pulses can only be stretched, not compressed.\n        chirp (Union[(list[int], str), (int, str)]): Allows to perform\n            piecewise linear sweep of the element's intermediate\n            frequency in time. Input should be a tuple, with the 1st\n            element being a list of rates and the second should be a\n            string with the units. The units can be either: 'Hz/nsec',\n            'mHz/nsec', 'uHz/nsec', 'pHz/nsec' or 'GHz/sec', 'MHz/sec',\n            'KHz/sec', 'Hz/sec', 'mHz/sec'.\n        truncate (Scalar[int]): Allows playing\n            only part of the pulse, truncating the end. If provided,\n            will play only up to the given time in units of the clock\n            cycle (4ns).\n        condition (Scalar[bool]): Will play analog\n            pulse only if the condition's value is true. Any digital\n            pulses associated with the operation will always play.\n        timestamp_stream (Union[str, _ResultSource]): (Supported from\n            QOP 2.2) Adding a `timestamp_stream` argument will save the\n            time at which the operation occurred to a stream. If the\n            `timestamp_stream` is a string ``label``, then the timestamp\n            handle can be retrieved with\n            `qm._results.JobResults.get` with the same ``label``.\n        validate (bool): If True (default), validate that the pulse is registered\n            in Channel.operations\n\n    Raises:\n        ValueError: If the pulse is not attached to a channel.\n        KeyError: If the pulse is not registered in the channel's operations.\n    \"\"\"\n    if self.id is not None:\n        name = self.id\n    elif self.parent is not None:\n        name = self.parent.get_attr_name(self)\n    else:\n        raise ValueError(f\"Cannot determine name of pulse '{self}'\")\n\n    if self.channel is None:\n        raise ValueError(f\"Pulse '{name}' is not attached to a channel\")\n\n    self.channel.play(\n        pulse_name=name,\n        amplitude_scale=amplitude_scale,\n        duration=duration,\n        condition=condition,\n        chirp=chirp,\n        truncate=truncate,\n        timestamp_stream=timestamp_stream,\n        continue_chirp=continue_chirp,\n        target=target,\n        validate=validate,\n    )\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.Pulse.waveform_function","title":"<code>waveform_function()</code>","text":"<p>Function that returns the waveform of the pulse.</p> <p>The waveform function should use the relevant parameters from the pulse, which is passed as the only argument.</p> <p>This function is called from <code>Pulse.calculate_waveform</code></p> <p>Returns:</p> Type Description <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <p>The waveform of the pulse. Can be one of the following:</p> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a single float for a constant single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a single complex number for a constant IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a sequence of floats for an arbitrary single-channel waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a sequence of complex numbers for an arbitrary IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a tuple of floats for a constant IQ waveform,</li> </ul> <code>Union[float, complex, Sequence[float], Sequence[complex], Tuple[float, float], Tuple[Sequence[float], Sequence[float]]]</code> <ul> <li>a tuple of sequences for an arbitrary IQ waveform</li> </ul> Source code in <code>quam/components/pulses.py</code> <pre><code>def waveform_function(\n    self,\n) -&gt; Union[\n    float,\n    complex,\n    Sequence[float],\n    Sequence[complex],\n    Tuple[float, float],\n    Tuple[Sequence[float], Sequence[float]],\n]:\n    \"\"\"Function that returns the waveform of the pulse.\n\n    The waveform function should use the relevant parameters from the pulse, which\n    is passed as the only argument.\n\n    This function is called from `Pulse.calculate_waveform`\n\n    Returns:\n        The waveform of the pulse. Can be one of the following:\n        - a single float for a constant single-channel waveform,\n        - a single complex number for a constant IQ waveform,\n        - a sequence of floats for an arbitrary single-channel waveform,\n        - a sequence of complex numbers for an arbitrary IQ waveform,\n        - a tuple of floats for a constant IQ waveform,\n        - a tuple of sequences for an arbitrary IQ waveform\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.ReadoutPulse","title":"<code>ReadoutPulse</code>","text":"<p>               Bases: <code>BaseReadoutPulse</code>, <code>ABC</code></p> <p>QUAM abstract base component for most readout pulses.</p> <p>This class is a subclass of <code>ReadoutPulse</code> and should be used for most readout pulses. It provides a default implementation of the <code>integration_weights_function</code> method, which is suitable for most cases.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Default is \"ON\".</p> required <code>integration_weights</code> <code>(list[float], list[tuple[float, int]])</code> <p>The integration weights, can be either - a list of floats (one per sample), the length must match the pulse length - a list of tuples of (weight, length) pairs, the sum of the lengths must   match the pulse length</p> required <code>integration_weights_angle</code> <code>float</code> <p>The rotation angle for the integration weights in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass ReadoutPulse(BaseReadoutPulse, ABC):\n    \"\"\"QUAM abstract base component for most readout pulses.\n\n    This class is a subclass of `ReadoutPulse` and should be used for most readout\n    pulses. It provides a default implementation of the `integration_weights_function`\n    method, which is suitable for most cases.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Default is \"ON\".\n        integration_weights (list[float], list[tuple[float, int]], optional): The\n            integration weights, can be either\n            - a list of floats (one per sample), the length must match the pulse length\n            - a list of tuples of (weight, length) pairs, the sum of the lengths must\n              match the pulse length\n        integration_weights_angle (float, optional): The rotation angle for the\n            integration weights in radians.\n    \"\"\"\n\n    integration_weights: Union[List[float], List[Tuple[float, int]]] = (\n        \"#./default_integration_weights\"\n    )\n    integration_weights_angle: float = 0\n\n    @property\n    def default_integration_weights(self) -&gt; List[Tuple[float, int]]:\n        return [(1, self.length)]\n\n    def integration_weights_function(self) -&gt; List[Tuple[Union[complex, float], int]]:\n        from qualang_tools.config import convert_integration_weights\n\n        phase = np.exp(1j * self.integration_weights_angle)\n\n        if isinstance(self.integration_weights[0], float):\n            integration_weights = convert_integration_weights(self.integration_weights)\n        else:\n            integration_weights = self.integration_weights\n\n        return {\n            \"real\": [(phase.real * w, l) for w, l in integration_weights],\n            \"imag\": [(phase.imag * w, l) for w, l in integration_weights],\n            \"minus_real\": [(-phase.real * w, l) for w, l in integration_weights],\n            \"minus_imag\": [(-phase.imag * w, l) for w, l in integration_weights],\n        }\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.SquarePulse","title":"<code>SquarePulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Square pulse QUAM component.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse.</p> required <code>amplitude</code> <code>float</code> <p>The amplitude of the pulse in volts.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass SquarePulse(Pulse):\n    \"\"\"Square pulse QUAM component.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n        amplitude (float): The amplitude of the pulse in volts.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n    \"\"\"\n\n    amplitude: float\n    axis_angle: float = None\n\n    def waveform_function(self):\n        waveform = self.amplitude\n\n        if self.axis_angle is not None:\n            waveform = waveform * np.exp(1j * self.axis_angle)\n        return waveform\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.SquareReadoutPulse","title":"<code>SquareReadoutPulse</code>","text":"<p>               Bases: <code>ReadoutPulse</code>, <code>SquarePulse</code></p> <p>QUAM component for a square readout pulse.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of the pulse in samples.</p> required <code>digital_marker</code> <code>(str, list)</code> <p>The digital marker to use for the pulse. Default is \"ON\".</p> required <code>amplitude</code> <code>float</code> <p>The constant amplitude of the pulse.</p> required <code>axis_angle</code> <code>float</code> <p>IQ axis angle of the output pulse in radians. If None (default), the pulse is meant for a single channel or the I port     of an IQ channel If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).</p> required <code>integration_weights</code> <code>(list[float], list[tuple[float, int]])</code> <p>The integration weights, can be either - a list of floats (one per sample), the length must match the pulse length - a list of tuples of (weight, length) pairs, the sum of the lengths must   match the pulse length</p> required <code>integration_weights_angle</code> <code>float</code> <p>The rotation angle for the integration weights in radians.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass SquareReadoutPulse(ReadoutPulse, SquarePulse):\n    \"\"\"QUAM component for a square readout pulse.\n\n    Args:\n        length (int): The length of the pulse in samples.\n        digital_marker (str, list, optional): The digital marker to use for the pulse.\n            Default is \"ON\".\n        amplitude (float): The constant amplitude of the pulse.\n        axis_angle (float, optional): IQ axis angle of the output pulse in radians.\n            If None (default), the pulse is meant for a single channel or the I port\n                of an IQ channel\n            If not None, the pulse is meant for an IQ channel (0 is X, pi/2 is Y).\n        integration_weights (list[float], list[tuple[float, int]], optional): The\n            integration weights, can be either\n            - a list of floats (one per sample), the length must match the pulse length\n            - a list of tuples of (weight, length) pairs, the sum of the lengths must\n              match the pulse length\n        integration_weights_angle (float, optional): The rotation angle for the\n            integration weights in radians.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"API_references/components/pulses_API/#quam.components.pulses.WaveformPulse","title":"<code>WaveformPulse</code>","text":"<p>               Bases: <code>Pulse</code></p> <p>Pulse that uses a pre-defined waveform, as opposed to a function.</p> <p>For a single channel, only <code>waveform_I</code> is required. For an IQ channel, both <code>waveform_I</code> and <code>waveform_Q</code> are required.</p> <p>The length of the pulse is derived from the length of <code>waveform_I</code>.</p> <p>Parameters:</p> Name Type Description Default <code>waveform_I</code> <code>list[float]</code> <p>The in-phase waveform.</p> required <code>waveform_Q</code> <code>list[float]</code> <p>The quadrature waveform.</p> required Source code in <code>quam/components/pulses.py</code> <pre><code>@quam_dataclass\nclass WaveformPulse(Pulse):\n    \"\"\"Pulse that uses a pre-defined waveform, as opposed to a function.\n\n    For a single channel, only `waveform_I` is required.\n    For an IQ channel, both `waveform_I` and `waveform_Q` are required.\n\n    The length of the pulse is derived from the length of `waveform_I`.\n\n    Args:\n        waveform_I (list[float]): The in-phase waveform.\n        waveform_Q (list[float], optional): The quadrature waveform.\n    \"\"\"\n\n    waveform_I: List[float]  # pyright: ignore\n    waveform_Q: Optional[List[float]] = None\n    # Length is derived from the waveform_I length, but still needs to be declared\n    # to satisfy the dataclass, but we'll override its behavior\n    length: Optional[int] = None  # pyright: ignore\n\n    @property\n    def length(self):  # noqa: 811\n        if not isinstance(self.waveform_I, Iterable):\n            return None\n        return len(self.waveform_I)\n\n    @length.setter\n    def length(self, length: Optional[int]):\n        if length is not None and not isinstance(length, property):\n            raise AttributeError(f\"length is not writable with value {length}\")\n\n    def waveform_function(self):\n        if self.waveform_Q is None:\n            return np.array(self.waveform_I)\n        return np.array(self.waveform_I) + 1.0j * np.array(self.waveform_Q)\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        d = super().to_dict(follow_references, include_defaults)\n        d.pop(\"length\")\n        return d\n</code></pre>"},{"location":"API_references/components/quantum_components_API/","title":"QUAM Quantum Components API","text":"<p>Welcome to the QUAM Quantum Components API Documentation. The QUAM Quantum Components module provides high-level abstractions for qubits and qubit pairs, enabling gate-level quantum programming. Information can be found in QUAM Gate-Level Operations Documentation in the User Guide.</p> <p>This section provides detailed API references for quantum component classes\u2014including qubits and qubit pairs\u2014that allow you to work at the gate level rather than the pulse level, bringing your quantum control code closer to quantum circuit thinking.</p>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.QuantumComponent","title":"<code>QuantumComponent</code>","text":"<p>               Bases: <code>QuamComponent</code>, <code>ABC</code></p> Source code in <code>quam/components/quantum_components/quantum_component.py</code> <pre><code>@quam_dataclass\nclass QuantumComponent(QuamComponent, ABC):\n    id: Union[str, int]\n    macros: Dict[str, BaseMacro] = field(default_factory=dict)\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        pass\n\n    def apply(self, operation: str, *args, **kwargs) -&gt; Any:\n        operation_obj = self.get_macros()[operation]\n        return operation_obj.apply(*args, **kwargs)\n\n    @staticmethod\n    def register_macro(func: T) -&gt; T:\n        \"\"\"Decorator to register a method as a macro entry point\"\"\"\n        return cast(T, method_macro(func))\n\n    def _get_method_macros(self) -&gt; Dict[str, method_macro]:\n        return dict(\n            inspect.getmembers(self, predicate=lambda x: isinstance(x, method_macro))\n        )\n\n    def get_macros(self) -&gt; Dict[str, BaseMacro]:\n        return {**self.macros, **self._get_method_macros()}\n</code></pre>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.QuantumComponent.register_macro","title":"<code>register_macro(func)</code>  <code>staticmethod</code>","text":"<p>Decorator to register a method as a macro entry point</p> Source code in <code>quam/components/quantum_components/quantum_component.py</code> <pre><code>@staticmethod\ndef register_macro(func: T) -&gt; T:\n    \"\"\"Decorator to register a method as a macro entry point\"\"\"\n    return cast(T, method_macro(func))\n</code></pre>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.Qubit","title":"<code>Qubit</code>","text":"<p>               Bases: <code>QuantumComponent</code></p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>@quam_dataclass\nclass Qubit(QuantumComponent):\n    id: Union[str, int] = \"#./inferred_id\"\n    macros: Dict[str, MacroType] = field(default_factory=dict)\n\n    @property\n    def inferred_id(self) -&gt; Union[str, int]:\n        if not str_ref.is_reference(self.get_raw_value(\"id\")):\n            return self.id\n        elif self.parent is not None:\n            name = self.parent.get_attr_name(self)\n            return name\n        else:\n            raise AttributeError(\n                f\"Cannot infer id of {self} because it is not attached to a parent\"\n            )\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the name of the qubit\"\"\"\n        return self.id if isinstance(self.id, str) else f\"q{self.id}\"\n\n    @property\n    def channels(self) -&gt; Dict[str, Channel]:\n        \"\"\"Returns a dictionary of all channels of the qubit\"\"\"\n        return {\n            key: val\n            for key, val in self.get_attrs(\n                follow_references=True, include_defaults=True\n            ).items()\n            if isinstance(val, Channel)\n        }\n\n    def get_pulse(self, pulse_name: str) -&gt; Pulse:\n        \"\"\"Returns the pulse with the given name\n\n        Goes through all channels and returns the unique pulse with the given name.\n\n        Raises a ValueError if the pulse is not found or if there are multiple pulses\n        with the same name.\n        \"\"\"\n        pulses = [\n            pulse\n            for channel in self.channels.values()\n            for key, pulse in channel.operations.items()\n            if key == pulse_name\n        ]\n        if len(pulses) == 0:\n            raise ValueError(f\"Pulse {pulse_name} not found\")\n        elif len(pulses) &gt; 1:\n            raise ValueError(f\"Pulse {pulse_name} is not unique\")\n        else:\n            return pulses[0]\n\n    @QuantumComponent.register_macro\n    def align(\n        self,\n        other_qubits: Optional[Union[\"Qubit\", Iterable[\"Qubit\"]]] = None,\n        *args: \"Qubit\",\n    ):\n        \"\"\"Aligns the execution of all channels of this qubit and all other qubits\"\"\"\n        quantum_components = [self]\n\n        if isinstance(other_qubits, Qubit):\n            quantum_components.append(other_qubits)\n        elif isinstance(other_qubits, Iterable):\n            quantum_components.extend(other_qubits)\n        elif other_qubits is not None:\n            raise ValueError(f\"Invalid type for other_qubits: {type(other_qubits)}\")\n\n        if args:\n            assert all(isinstance(arg, Qubit) for arg in args)\n            quantum_components.extend(args)\n\n        channel_names = {\n            ch.name for qubit in quantum_components for ch in qubit.channels.values()\n        }\n\n        align(*channel_names)\n\n    def __matmul__(self, other):  # TODO Add QubitPair return type\n        \"\"\"Allows access to qubit pairs using the '@' operator, e.g. (q1 @ q2)\"\"\"\n        if not isinstance(other, Qubit):\n            raise ValueError(\n                \"Cannot create a qubit pair (q1 @ q2) with a non-qubit object, \"\n                f\"where q1={self} and q2={other}\"\n            )\n\n        if self is other:\n            raise ValueError(\n                \"Cannot create a qubit pair with same qubit (q1 @ q1), where q1={self}\"\n            )\n\n        root_quam = self.get_root()\n\n        if root_quam is None:\n            raise AttributeError(\n                \"Qubit pairs not found in the root component. \"\n                \"Please add a 'qubit_pairs' attribute to the root component.\"\n            )\n\n        if not hasattr(root_quam, \"qubit_pairs\"):\n            raise AttributeError(\n                \"Qubit pairs not found in the root component. \"\n                \"Please add a 'qubit_pairs' attribute to the root component.\"\n            )\n\n        if isinstance(root_quam.qubit_pairs, UserDict):\n            qubit_pairs = root_quam.qubit_pairs.values()\n        else:\n            qubit_pairs = root_quam.qubit_pairs\n\n        for qubit_pair in qubit_pairs:\n            if qubit_pair.qubit_control is self and qubit_pair.qubit_target is other:\n                return qubit_pair\n        else:\n            raise ValueError(\n                f\"Qubit pair not found: qubit_control={self.name}, \"\n                f\"qubit_target={other.name}\"\n            )\n</code></pre>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.Qubit.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Returns a dictionary of all channels of the qubit</p>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.Qubit.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns the name of the qubit</p>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.Qubit.__matmul__","title":"<code>__matmul__(other)</code>","text":"<p>Allows access to qubit pairs using the '@' operator, e.g. (q1 @ q2)</p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>def __matmul__(self, other):  # TODO Add QubitPair return type\n    \"\"\"Allows access to qubit pairs using the '@' operator, e.g. (q1 @ q2)\"\"\"\n    if not isinstance(other, Qubit):\n        raise ValueError(\n            \"Cannot create a qubit pair (q1 @ q2) with a non-qubit object, \"\n            f\"where q1={self} and q2={other}\"\n        )\n\n    if self is other:\n        raise ValueError(\n            \"Cannot create a qubit pair with same qubit (q1 @ q1), where q1={self}\"\n        )\n\n    root_quam = self.get_root()\n\n    if root_quam is None:\n        raise AttributeError(\n            \"Qubit pairs not found in the root component. \"\n            \"Please add a 'qubit_pairs' attribute to the root component.\"\n        )\n\n    if not hasattr(root_quam, \"qubit_pairs\"):\n        raise AttributeError(\n            \"Qubit pairs not found in the root component. \"\n            \"Please add a 'qubit_pairs' attribute to the root component.\"\n        )\n\n    if isinstance(root_quam.qubit_pairs, UserDict):\n        qubit_pairs = root_quam.qubit_pairs.values()\n    else:\n        qubit_pairs = root_quam.qubit_pairs\n\n    for qubit_pair in qubit_pairs:\n        if qubit_pair.qubit_control is self and qubit_pair.qubit_target is other:\n            return qubit_pair\n    else:\n        raise ValueError(\n            f\"Qubit pair not found: qubit_control={self.name}, \"\n            f\"qubit_target={other.name}\"\n        )\n</code></pre>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.Qubit.align","title":"<code>align(other_qubits=None, *args)</code>","text":"<p>Aligns the execution of all channels of this qubit and all other qubits</p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>@QuantumComponent.register_macro\ndef align(\n    self,\n    other_qubits: Optional[Union[\"Qubit\", Iterable[\"Qubit\"]]] = None,\n    *args: \"Qubit\",\n):\n    \"\"\"Aligns the execution of all channels of this qubit and all other qubits\"\"\"\n    quantum_components = [self]\n\n    if isinstance(other_qubits, Qubit):\n        quantum_components.append(other_qubits)\n    elif isinstance(other_qubits, Iterable):\n        quantum_components.extend(other_qubits)\n    elif other_qubits is not None:\n        raise ValueError(f\"Invalid type for other_qubits: {type(other_qubits)}\")\n\n    if args:\n        assert all(isinstance(arg, Qubit) for arg in args)\n        quantum_components.extend(args)\n\n    channel_names = {\n        ch.name for qubit in quantum_components for ch in qubit.channels.values()\n    }\n\n    align(*channel_names)\n</code></pre>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.Qubit.get_pulse","title":"<code>get_pulse(pulse_name)</code>","text":"<p>Returns the pulse with the given name</p> <p>Goes through all channels and returns the unique pulse with the given name.</p> <p>Raises a ValueError if the pulse is not found or if there are multiple pulses with the same name.</p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>def get_pulse(self, pulse_name: str) -&gt; Pulse:\n    \"\"\"Returns the pulse with the given name\n\n    Goes through all channels and returns the unique pulse with the given name.\n\n    Raises a ValueError if the pulse is not found or if there are multiple pulses\n    with the same name.\n    \"\"\"\n    pulses = [\n        pulse\n        for channel in self.channels.values()\n        for key, pulse in channel.operations.items()\n        if key == pulse_name\n    ]\n    if len(pulses) == 0:\n        raise ValueError(f\"Pulse {pulse_name} not found\")\n    elif len(pulses) &gt; 1:\n        raise ValueError(f\"Pulse {pulse_name} is not unique\")\n    else:\n        return pulses[0]\n</code></pre>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.QubitPair","title":"<code>QubitPair</code>","text":"<p>               Bases: <code>QuantumComponent</code></p> Source code in <code>quam/components/quantum_components/qubit_pair.py</code> <pre><code>@quam_dataclass\nclass QubitPair(QuantumComponent):\n    id: str = \"#./name\"\n    qubit_control: Qubit\n    qubit_target: Qubit\n    macros: Dict[str, MacroType] = field(default_factory=dict)\n\n    @property\n    def name(self) -&gt; str:\n        if not str_ref.is_reference(self.get_raw_value(\"id\")):\n            return self.id\n        else:\n            return f\"{self.qubit_control.name}@{self.qubit_target.name}\"\n\n    def align(self):\n        \"\"\"Aligns the execution of all channels of both qubits\"\"\"\n        self.qubit_control.align(self.qubit_target)\n</code></pre>"},{"location":"API_references/components/quantum_components_API/#quam.components.quantum_components.QubitPair.align","title":"<code>align()</code>","text":"<p>Aligns the execution of all channels of both qubits</p> Source code in <code>quam/components/quantum_components/qubit_pair.py</code> <pre><code>def align(self):\n    \"\"\"Aligns the execution of all channels of both qubits\"\"\"\n    self.qubit_control.align(self.qubit_target)\n</code></pre>"},{"location":"API_references/components/macro/qubit_macros/","title":"Qubit macros","text":""},{"location":"API_references/components/macro/qubit_macros/#quam.components.macro.qubit_macros.PulseMacro","title":"<code>PulseMacro</code>","text":"<p>               Bases: <code>QubitMacro</code></p> <p>Single-qubit gate for a qubit consisting of a single pulse</p> <p>Parameters:</p> Name Type Description Default <code>pulse</code> <p>Name of pulse to be played on qubit. Should be a key in <code>channel.operations</code> for one of the qubit's channels</p> required Source code in <code>quam/components/macro/qubit_macros.py</code> <pre><code>@quam_dataclass\nclass PulseMacro(QubitMacro):\n    \"\"\"Single-qubit gate for a qubit consisting of a single pulse\n\n    Args:\n        pulse: Name of pulse to be played on qubit. Should be a key in\n            `channel.operations` for one of the qubit's channels\n    \"\"\"\n\n    pulse: Union[Pulse, str]  # type: ignore\n\n    def apply(self, *, amplitude_scale=None, duration=None, **kwargs):\n        if isinstance(self.pulse, Pulse):\n            pulse = self.pulse\n        else:\n            pulse = self.qubit.get_pulse(self.pulse)\n        pulse.play(\n            amplitude_scale=amplitude_scale, duration=duration, **kwargs  # type: ignore\n        )\n\n    @property\n    def inferred_duration(self) -&gt; float:\n        if isinstance(self.pulse, Pulse):\n            return self.pulse.length * 1e-9\n        else:\n            return self.qubit.get_pulse(self.pulse).length * 1e-9\n</code></pre>"},{"location":"API_references/components/macro/qubit_pair_macros/","title":"Qubit pair macros","text":""},{"location":"API_references/components/ports/analog_inputs/","title":"Analog inputs","text":""},{"location":"API_references/components/ports/analog_outputs/","title":"Analog outputs","text":""},{"location":"API_references/components/ports/base_ports/","title":"Base ports","text":""},{"location":"API_references/components/ports/digital_inputs/","title":"Digital inputs","text":""},{"location":"API_references/components/ports/digital_outputs/","title":"Digital outputs","text":""},{"location":"API_references/components/ports/ports_containers/","title":"Ports containers","text":""},{"location":"API_references/components/quantum_components/quantum_component/","title":"Quantum component","text":""},{"location":"API_references/components/quantum_components/quantum_component/#quam.components.quantum_components.quantum_component.QuantumComponent","title":"<code>QuantumComponent</code>","text":"<p>               Bases: <code>QuamComponent</code>, <code>ABC</code></p> Source code in <code>quam/components/quantum_components/quantum_component.py</code> <pre><code>@quam_dataclass\nclass QuantumComponent(QuamComponent, ABC):\n    id: Union[str, int]\n    macros: Dict[str, BaseMacro] = field(default_factory=dict)\n\n    @property\n    @abstractmethod\n    def name(self) -&gt; str:\n        pass\n\n    def apply(self, operation: str, *args, **kwargs) -&gt; Any:\n        operation_obj = self.get_macros()[operation]\n        return operation_obj.apply(*args, **kwargs)\n\n    @staticmethod\n    def register_macro(func: T) -&gt; T:\n        \"\"\"Decorator to register a method as a macro entry point\"\"\"\n        return cast(T, method_macro(func))\n\n    def _get_method_macros(self) -&gt; Dict[str, method_macro]:\n        return dict(\n            inspect.getmembers(self, predicate=lambda x: isinstance(x, method_macro))\n        )\n\n    def get_macros(self) -&gt; Dict[str, BaseMacro]:\n        return {**self.macros, **self._get_method_macros()}\n</code></pre>"},{"location":"API_references/components/quantum_components/quantum_component/#quam.components.quantum_components.quantum_component.QuantumComponent.register_macro","title":"<code>register_macro(func)</code>  <code>staticmethod</code>","text":"<p>Decorator to register a method as a macro entry point</p> Source code in <code>quam/components/quantum_components/quantum_component.py</code> <pre><code>@staticmethod\ndef register_macro(func: T) -&gt; T:\n    \"\"\"Decorator to register a method as a macro entry point\"\"\"\n    return cast(T, method_macro(func))\n</code></pre>"},{"location":"API_references/components/quantum_components/qubit/","title":"Qubit","text":""},{"location":"API_references/components/quantum_components/qubit/#quam.components.quantum_components.qubit.Qubit","title":"<code>Qubit</code>","text":"<p>               Bases: <code>QuantumComponent</code></p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>@quam_dataclass\nclass Qubit(QuantumComponent):\n    id: Union[str, int] = \"#./inferred_id\"\n    macros: Dict[str, MacroType] = field(default_factory=dict)\n\n    @property\n    def inferred_id(self) -&gt; Union[str, int]:\n        if not str_ref.is_reference(self.get_raw_value(\"id\")):\n            return self.id\n        elif self.parent is not None:\n            name = self.parent.get_attr_name(self)\n            return name\n        else:\n            raise AttributeError(\n                f\"Cannot infer id of {self} because it is not attached to a parent\"\n            )\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the name of the qubit\"\"\"\n        return self.id if isinstance(self.id, str) else f\"q{self.id}\"\n\n    @property\n    def channels(self) -&gt; Dict[str, Channel]:\n        \"\"\"Returns a dictionary of all channels of the qubit\"\"\"\n        return {\n            key: val\n            for key, val in self.get_attrs(\n                follow_references=True, include_defaults=True\n            ).items()\n            if isinstance(val, Channel)\n        }\n\n    def get_pulse(self, pulse_name: str) -&gt; Pulse:\n        \"\"\"Returns the pulse with the given name\n\n        Goes through all channels and returns the unique pulse with the given name.\n\n        Raises a ValueError if the pulse is not found or if there are multiple pulses\n        with the same name.\n        \"\"\"\n        pulses = [\n            pulse\n            for channel in self.channels.values()\n            for key, pulse in channel.operations.items()\n            if key == pulse_name\n        ]\n        if len(pulses) == 0:\n            raise ValueError(f\"Pulse {pulse_name} not found\")\n        elif len(pulses) &gt; 1:\n            raise ValueError(f\"Pulse {pulse_name} is not unique\")\n        else:\n            return pulses[0]\n\n    @QuantumComponent.register_macro\n    def align(\n        self,\n        other_qubits: Optional[Union[\"Qubit\", Iterable[\"Qubit\"]]] = None,\n        *args: \"Qubit\",\n    ):\n        \"\"\"Aligns the execution of all channels of this qubit and all other qubits\"\"\"\n        quantum_components = [self]\n\n        if isinstance(other_qubits, Qubit):\n            quantum_components.append(other_qubits)\n        elif isinstance(other_qubits, Iterable):\n            quantum_components.extend(other_qubits)\n        elif other_qubits is not None:\n            raise ValueError(f\"Invalid type for other_qubits: {type(other_qubits)}\")\n\n        if args:\n            assert all(isinstance(arg, Qubit) for arg in args)\n            quantum_components.extend(args)\n\n        channel_names = {\n            ch.name for qubit in quantum_components for ch in qubit.channels.values()\n        }\n\n        align(*channel_names)\n\n    def __matmul__(self, other):  # TODO Add QubitPair return type\n        \"\"\"Allows access to qubit pairs using the '@' operator, e.g. (q1 @ q2)\"\"\"\n        if not isinstance(other, Qubit):\n            raise ValueError(\n                \"Cannot create a qubit pair (q1 @ q2) with a non-qubit object, \"\n                f\"where q1={self} and q2={other}\"\n            )\n\n        if self is other:\n            raise ValueError(\n                \"Cannot create a qubit pair with same qubit (q1 @ q1), where q1={self}\"\n            )\n\n        root_quam = self.get_root()\n\n        if root_quam is None:\n            raise AttributeError(\n                \"Qubit pairs not found in the root component. \"\n                \"Please add a 'qubit_pairs' attribute to the root component.\"\n            )\n\n        if not hasattr(root_quam, \"qubit_pairs\"):\n            raise AttributeError(\n                \"Qubit pairs not found in the root component. \"\n                \"Please add a 'qubit_pairs' attribute to the root component.\"\n            )\n\n        if isinstance(root_quam.qubit_pairs, UserDict):\n            qubit_pairs = root_quam.qubit_pairs.values()\n        else:\n            qubit_pairs = root_quam.qubit_pairs\n\n        for qubit_pair in qubit_pairs:\n            if qubit_pair.qubit_control is self and qubit_pair.qubit_target is other:\n                return qubit_pair\n        else:\n            raise ValueError(\n                f\"Qubit pair not found: qubit_control={self.name}, \"\n                f\"qubit_target={other.name}\"\n            )\n</code></pre>"},{"location":"API_references/components/quantum_components/qubit/#quam.components.quantum_components.qubit.Qubit.channels","title":"<code>channels</code>  <code>property</code>","text":"<p>Returns a dictionary of all channels of the qubit</p>"},{"location":"API_references/components/quantum_components/qubit/#quam.components.quantum_components.qubit.Qubit.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns the name of the qubit</p>"},{"location":"API_references/components/quantum_components/qubit/#quam.components.quantum_components.qubit.Qubit.__matmul__","title":"<code>__matmul__(other)</code>","text":"<p>Allows access to qubit pairs using the '@' operator, e.g. (q1 @ q2)</p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>def __matmul__(self, other):  # TODO Add QubitPair return type\n    \"\"\"Allows access to qubit pairs using the '@' operator, e.g. (q1 @ q2)\"\"\"\n    if not isinstance(other, Qubit):\n        raise ValueError(\n            \"Cannot create a qubit pair (q1 @ q2) with a non-qubit object, \"\n            f\"where q1={self} and q2={other}\"\n        )\n\n    if self is other:\n        raise ValueError(\n            \"Cannot create a qubit pair with same qubit (q1 @ q1), where q1={self}\"\n        )\n\n    root_quam = self.get_root()\n\n    if root_quam is None:\n        raise AttributeError(\n            \"Qubit pairs not found in the root component. \"\n            \"Please add a 'qubit_pairs' attribute to the root component.\"\n        )\n\n    if not hasattr(root_quam, \"qubit_pairs\"):\n        raise AttributeError(\n            \"Qubit pairs not found in the root component. \"\n            \"Please add a 'qubit_pairs' attribute to the root component.\"\n        )\n\n    if isinstance(root_quam.qubit_pairs, UserDict):\n        qubit_pairs = root_quam.qubit_pairs.values()\n    else:\n        qubit_pairs = root_quam.qubit_pairs\n\n    for qubit_pair in qubit_pairs:\n        if qubit_pair.qubit_control is self and qubit_pair.qubit_target is other:\n            return qubit_pair\n    else:\n        raise ValueError(\n            f\"Qubit pair not found: qubit_control={self.name}, \"\n            f\"qubit_target={other.name}\"\n        )\n</code></pre>"},{"location":"API_references/components/quantum_components/qubit/#quam.components.quantum_components.qubit.Qubit.align","title":"<code>align(other_qubits=None, *args)</code>","text":"<p>Aligns the execution of all channels of this qubit and all other qubits</p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>@QuantumComponent.register_macro\ndef align(\n    self,\n    other_qubits: Optional[Union[\"Qubit\", Iterable[\"Qubit\"]]] = None,\n    *args: \"Qubit\",\n):\n    \"\"\"Aligns the execution of all channels of this qubit and all other qubits\"\"\"\n    quantum_components = [self]\n\n    if isinstance(other_qubits, Qubit):\n        quantum_components.append(other_qubits)\n    elif isinstance(other_qubits, Iterable):\n        quantum_components.extend(other_qubits)\n    elif other_qubits is not None:\n        raise ValueError(f\"Invalid type for other_qubits: {type(other_qubits)}\")\n\n    if args:\n        assert all(isinstance(arg, Qubit) for arg in args)\n        quantum_components.extend(args)\n\n    channel_names = {\n        ch.name for qubit in quantum_components for ch in qubit.channels.values()\n    }\n\n    align(*channel_names)\n</code></pre>"},{"location":"API_references/components/quantum_components/qubit/#quam.components.quantum_components.qubit.Qubit.get_pulse","title":"<code>get_pulse(pulse_name)</code>","text":"<p>Returns the pulse with the given name</p> <p>Goes through all channels and returns the unique pulse with the given name.</p> <p>Raises a ValueError if the pulse is not found or if there are multiple pulses with the same name.</p> Source code in <code>quam/components/quantum_components/qubit.py</code> <pre><code>def get_pulse(self, pulse_name: str) -&gt; Pulse:\n    \"\"\"Returns the pulse with the given name\n\n    Goes through all channels and returns the unique pulse with the given name.\n\n    Raises a ValueError if the pulse is not found or if there are multiple pulses\n    with the same name.\n    \"\"\"\n    pulses = [\n        pulse\n        for channel in self.channels.values()\n        for key, pulse in channel.operations.items()\n        if key == pulse_name\n    ]\n    if len(pulses) == 0:\n        raise ValueError(f\"Pulse {pulse_name} not found\")\n    elif len(pulses) &gt; 1:\n        raise ValueError(f\"Pulse {pulse_name} is not unique\")\n    else:\n        return pulses[0]\n</code></pre>"},{"location":"API_references/components/quantum_components/qubit_pair/","title":"Qubit pair","text":""},{"location":"API_references/components/quantum_components/qubit_pair/#quam.components.quantum_components.qubit_pair.QubitPair","title":"<code>QubitPair</code>","text":"<p>               Bases: <code>QuantumComponent</code></p> Source code in <code>quam/components/quantum_components/qubit_pair.py</code> <pre><code>@quam_dataclass\nclass QubitPair(QuantumComponent):\n    id: str = \"#./name\"\n    qubit_control: Qubit\n    qubit_target: Qubit\n    macros: Dict[str, MacroType] = field(default_factory=dict)\n\n    @property\n    def name(self) -&gt; str:\n        if not str_ref.is_reference(self.get_raw_value(\"id\")):\n            return self.id\n        else:\n            return f\"{self.qubit_control.name}@{self.qubit_target.name}\"\n\n    def align(self):\n        \"\"\"Aligns the execution of all channels of both qubits\"\"\"\n        self.qubit_control.align(self.qubit_target)\n</code></pre>"},{"location":"API_references/components/quantum_components/qubit_pair/#quam.components.quantum_components.qubit_pair.QubitPair.align","title":"<code>align()</code>","text":"<p>Aligns the execution of all channels of both qubits</p> Source code in <code>quam/components/quantum_components/qubit_pair.py</code> <pre><code>def align(self):\n    \"\"\"Aligns the execution of all channels of both qubits\"\"\"\n    self.qubit_control.align(self.qubit_target)\n</code></pre>"},{"location":"API_references/config/resolvers/","title":"Resolvers","text":""},{"location":"API_references/config/resolvers/#quam.config.resolvers.get_quam_config","title":"<code>get_quam_config(config_path=None, config=None, auto_migrate=True)</code>","text":"<p>Retrieve the Quam configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[Path]</code> <p>Path to the configuration file. If not provided, the default path will be used.</p> <code>None</code> <code>config</code> <code>Optional[RawConfigType]</code> <p>Optional pre-loaded configuration data. If not provided, it will load and resolve references from the config file.</p> <code>None</code> <code>auto_migrate</code> <code>bool</code> <p>is it needed to automatically apply migrations to config</p> <code>True</code> <p>Returns:</p> Type Description <code>QuamConfig</code> <p>An instance of QuamConfig with the loaded configuration.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the configuration file cannot be read or if the configuration state is invalid.</p> Source code in <code>quam/config/resolvers.py</code> <pre><code>def get_quam_config(\n    config_path: Optional[Path] = None,\n    config: Optional[RawConfigType] = None,\n    auto_migrate: bool = True,\n) -&gt; QuamConfig:\n    \"\"\"Retrieve the Quam configuration.\n\n    Args:\n        config_path: Path to the configuration file.\n            If not provided, the default path will be used.\n        config: Optional pre-loaded configuration data. If not provided, it\n            will load and resolve references from the config file.\n        auto_migrate: is it needed to automatically apply migrations to config\n\n    Returns:\n        An instance of QuamConfig with the loaded configuration.\n\n    Raises:\n        RuntimeError: If the configuration file cannot be read or if the\n            configuration state is invalid.\n    \"\"\"\n    if config_path is None:\n        config_path = get_quam_config_path()\n\n    get_config_model_part = partial(\n        get_config_model,\n        config_path,\n        config_key=None,\n        config_class=QuamTopLevelConfig,\n        config=config,\n    )\n    error_msg = (\n        \"Quam was unable to load the config. It is recommend to run \"\n        '\"quam config\" to fix any file issues. If this problem persists, '\n        f'please delete \"{config_path}\" and retry running '\n        '\"quam config\"'\n    )\n    try:\n        model = get_config_model_part(raw_config_validators=[quam_version_validator])\n    except GreaterThanSupportedQuamConfigVersionError:\n        # Package is too old, config is too new - don't attempt migration\n        raise\n    except InvalidQuamConfigVersionError:\n        if not auto_migrate:\n            raise\n        logging.info(\"Automatically migrate to new quam config\")\n        try:\n            migrate_command([\"--config-path\", str(config_path)], standalone_mode=False)\n        except Exception as migrate_error:\n            # If migration fails, provide helpful context\n            error_detail = f\"Migration failed: {migrate_error.__class__.__name__}: {migrate_error}\"\n            raise RuntimeError(\n                f\"Failed to automatically migrate config. {error_detail}\\n\"\n                f\"Please manually upgrade your configuration or run `quam migrate`.\"\n            ) from migrate_error\n    except (RuntimeError, ValueError) as ex:\n        raise RuntimeError(error_msg) from ex\n    else:\n        return model.quam\n    # migrated\n    try:\n        model = get_config_model_part()\n    except (RuntimeError, ValueError) as ex:\n        raise RuntimeError(error_msg) from ex\n    return model.quam\n</code></pre>"},{"location":"API_references/config/resolvers/#quam.config.resolvers.get_quam_config_path","title":"<code>get_quam_config_path()</code>","text":"<p>Retrieve the quam configuration file path. If an environment variable for the config path is set, it uses that; otherwise, it defaults to the standard Qualibrate path.</p> Source code in <code>quam/config/resolvers.py</code> <pre><code>def get_quam_config_path() -&gt; Path:\n    \"\"\"\n    Retrieve the quam configuration file path. If an environment variable\n    for the config path is set, it uses that; otherwise, it defaults to the\n    standard Qualibrate path.\n    \"\"\"\n    return get_config_file(\n        os.environ.get(CONFIG_PATH_ENV_NAME, QUALIBRATE_PATH),\n        DEFAULT_CONFIG_FILENAME,\n        raise_not_exists=False,\n    )\n</code></pre>"},{"location":"API_references/config/validators/","title":"Validators","text":""},{"location":"API_references/config/validators/#quam.config.validators.GreaterThanSupportedQuamConfigVersionError","title":"<code>GreaterThanSupportedQuamConfigVersionError</code>","text":"<p>               Bases: <code>InvalidQuamConfigVersion</code></p> <p>Config version newer than package supports (package too old)</p> Source code in <code>quam/config/validators.py</code> <pre><code>class GreaterThanSupportedQuamConfigVersionError(InvalidQuamConfigVersion):\n    \"\"\"Config version newer than package supports (package too old)\"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/config/validators/#quam.config.validators.InvalidQuamConfigVersion","title":"<code>InvalidQuamConfigVersion</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Base exception for QUAM config version issues</p> Source code in <code>quam/config/validators.py</code> <pre><code>class InvalidQuamConfigVersion(RuntimeError):\n    \"\"\"Base exception for QUAM config version issues\"\"\"\n    pass\n</code></pre>"},{"location":"API_references/config/validators/#quam.config.validators.InvalidQuamConfigVersionError","title":"<code>InvalidQuamConfigVersionError</code>","text":"<p>               Bases: <code>InvalidQuamConfigVersion</code></p> <p>Config version older than package supports (config too old)</p> Source code in <code>quam/config/validators.py</code> <pre><code>class InvalidQuamConfigVersionError(InvalidQuamConfigVersion):\n    \"\"\"Config version older than package supports (config too old)\"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/config/vars/","title":"Vars","text":""},{"location":"API_references/config/cli/config/","title":"Config","text":""},{"location":"API_references/config/cli/migrate/","title":"Migrate","text":""},{"location":"API_references/config/cli/migrations/v1_v2/","title":"V1 v2","text":""},{"location":"API_references/config/cli/migrations/v2_v3/","title":"V2 v3","text":""},{"location":"API_references/config/models/quam/","title":"Quam","text":""},{"location":"API_references/core/deprecations/","title":"Deprecations","text":""},{"location":"API_references/core/qua_config_template/","title":"Qua config template","text":""},{"location":"API_references/core/quam_classes/","title":"Quam classes","text":""},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.ParentDescriptor","title":"<code>ParentDescriptor</code>","text":"<p>Descriptor for the parent attribute of QuamBase.</p> <p>This descriptor is used to ensure that the parent attribute of a QuamBase object is not overwritten. This is to prevent the following situation:</p> <pre><code>parent1 = QuamBase()\nparent2 = QuamBase()\n\nchild = QuamBase()\nchild.parent = parent1  # This is fine\nchild.parent = parent2  # This raises an AttributeError\n</code></pre> Source code in <code>quam/core/quam_classes.py</code> <pre><code>class ParentDescriptor:\n    \"\"\"Descriptor for the parent attribute of QuamBase.\n\n    This descriptor is used to ensure that the parent attribute of a QuamBase\n    object is not overwritten. This is to prevent the following situation:\n\n    ```\n    parent1 = QuamBase()\n    parent2 = QuamBase()\n\n    child = QuamBase()\n    child.parent = parent1  # This is fine\n    child.parent = parent2  # This raises an AttributeError\n    ```\n    \"\"\"\n\n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n\n        if \"parent\" in instance.__dict__:\n            return instance.__dict__[\"parent\"]\n        return None\n\n    def __set__(self, instance, value):\n        if value is None:\n            instance.__dict__.pop(\"parent\", None)\n            return\n\n        if \"parent\" in instance.__dict__ and instance.__dict__[\"parent\"] is not value:\n            cls = instance.__class__.__name__\n            raise AttributeError(\n                f\"Cannot overwrite parent attribute of {cls}. \"\n                f\"To modify {cls}.parent, first set {cls}.parent = None\"\n            )\n        instance.__dict__[\"parent\"] = value\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase","title":"<code>QuamBase</code>","text":"<p>               Bases: <code>ReferenceClass</code></p> <p>Base class for any QUAM component class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <p>The parent of this object. This is automatically set when adding this object to another QuamBase object.</p> required <code>config_settings</code> <p>A dictionary of configuration settings for this object. This is used by <code>QuamRoot.generate_config</code> to determine the order in which to add the components to the QUA config. Keys are \"before\" and \"after\", and the values are a list of QuamComponents</p> required Note <p>This class should not be used directly, but should generally be subclassed. The subclasses should be dataclasses.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>class QuamBase(ReferenceClass):\n    \"\"\"Base class for any QUAM component class.\n\n    args:\n        parent: The parent of this object. This is automatically set when adding\n            this object to another QuamBase object.\n        config_settings: A dictionary of configuration settings for this object.\n            This is used by [`QuamRoot.generate_config`][quam.core.quam_classes.QuamRoot.generate_config]\n            to determine the order in which to add the components to the QUA config.\n            Keys are \"before\" and \"after\", and the values are a list of QuamComponents\n\n    Note:\n        This class should not be used directly, but should generally be subclassed.\n        The subclasses should be dataclasses.\n    \"\"\"\n\n    parent: ClassVar[\"QuamBase\"] = ParentDescriptor()\n    _last_instantiated_root: ClassVar[Optional[\"QuamRoot\"]] = None\n    config_settings: ClassVar[Dict[str, Any]] = None\n    _MAX_REFERENCE_DEPTH: ClassVar[int] = 10\n\n    def __init__(self):\n        # This prohibits instantiating without it being a dataclass\n        # This means that we have to subclass this class and make it a dataclass\n        if not is_dataclass(self):\n            if type(self) in [QuamBase, QuamComponent, QuamRoot]:\n                raise TypeError(\n                    f\"Cannot instantiate {self.__class__.__name__} directly. \"\n                    \"Please create a subclass and make it a dataclass.\"\n                )\n            else:\n                raise TypeError(\n                    f\"Cannot instantiate {self.__class__.__name__}. \"\n                    \"Please make it a dataclass.\"\n                )\n\n    def _get_attr_names(self) -&gt; List[str]:\n        \"\"\"Get names of all dataclass attributes of this object.\n\n        Returns:\n            List of attribute names.\n\n        Raises:\n            AssertionError if not a dataclass.\n        \"\"\"\n        assert is_dataclass(self)\n        return [data_field.name for data_field in fields(self)]\n\n    def get_root(self) -&gt; Optional[QuamRoot]:\n        \"\"\"Get the QuamRoot object of this object.\n\n        This function recursively searches the parent chain for a QuamRoot object.\n        If no QuamRoot object is found, it will return the last instantiated QuamRoot\n        if it exists, else None.\n\n        Returns:\n            The root of this object, or None if no root is found.\n        \"\"\"\n        if self.parent is not None:\n            return self.parent.get_root()\n\n        if self._last_instantiated_root is not None:\n            warnings.warn(\n                f\"This component is not part of any QuamRoot, using last \"\n                f\"instantiated QuamRoot. This is not recommended as it may lead to \"\n                f\"unexpected behaviour. Component: {self.__class__.__name__}\"\n            )\n            return self._last_instantiated_root\n        return None\n\n    def get_attr_name(self, attr_val: Any) -&gt; str:\n        \"\"\"Get the name of an attribute that matches the value.\n\n        Args:\n            attr_val: The value of the attribute.\n\n        Returns:\n            The name of the attribute.\n\n        Raises:\n            AttributeError if not found.\n        \"\"\"\n        for attr_name in self._get_attr_names():\n            if self.get_raw_value(attr_name) is attr_val:\n                return attr_name\n        else:\n            raise AttributeError(\n                \"Could not find name corresponding to attribute.\\n\"\n                f\"attribute: {attr_val}\\n\"\n                f\"obj: {self}\"\n            )\n\n    def _attr_val_is_default(self, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the value of an attribute is the default value.\n\n        Args:\n            attr: The name of the attribute.\n            val: The value of the attribute.\n\n        Returns:\n            True if the value is the default value, False otherwise.\n            False is also returned if the parent is not a dataclass\n        \"\"\"\n        if not is_dataclass(self):\n            return False\n\n        dataclass_fields = fields(self)\n        if not any(field.name == attr for field in dataclass_fields):\n            return False\n\n        field = next(field for field in dataclass_fields if field.name == attr)\n        if field.default is not MISSING:\n            return val == field.default\n        elif field.default_factory is not MISSING:\n            try:\n                default_val = field.default_factory()\n                return val == default_val\n            except TypeError:\n                return False\n\n        return False\n\n    @classmethod\n    def _val_matches_attr_annotation(cls, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the type of an attribute matches the annotation.\n\n        The attribute type must exactly match the annotation.\n        For dict and list, no additional type check of args is performed.\n        \"\"\"\n        annotated_attrs = get_dataclass_attr_annotations(cls)\n        if attr not in annotated_attrs[\"allowed\"]:\n            return False\n\n        required_type = annotated_attrs[\"allowed\"][attr]\n        if type_is_optional(required_type):\n            required_type = get_args(required_type)[0]\n\n        if required_type == dict or get_origin(required_type) == dict:\n            return isinstance(val, (dict, QuamDict))\n        elif required_type == list or get_origin(required_type) == list:\n            return isinstance(val, (list, QuamList))\n        return type(val) == required_type\n\n    def get_reference(\n        self,\n        attr: Optional[str] = None,\n        relative_path: Optional[str] = None,\n        follow_chain: bool = False,\n    ) -&gt; Optional[str]:\n        \"\"\"Get the reference path of this object or one of its attributes.\n\n        Args:\n            attr: The optional attribute to get the reference path for.\n                If None, the reference path of the object itself is returned.\n            relative_path: The optional relative path to join with the reference path.\n            follow_chain: If True and attr is a reference, follow the reference chain\n                to return the ultimate target reference. Default is False for backward\n                compatibility. Only applies when attr is specified.\n\n        Returns:\n            The reference path of this object or the specified attribute.\n\n        Raises:\n            ValueError: If both attr and relative_path are specified, or if follow_chain\n                is True but attr is not a reference.\n\n        Examples:\n            We assume a QuamRoot object with a component \"elem\".\n            - elem.get_reference() == \"#/elem\"\n            - elem.get_reference(attr=\"child\") == \"#/elem/child\"\n            - elem.get_reference(relative_path=\"#./child\") == \"#/elem/child\"\n            - elem.get_reference(relative_path=\"#../child\") == \"#/child\"\n            - elem.get_reference(relative_path=\"#./child/grandchild\") == \"#/elem/child/grandchild\"\n\n            With follow_chain=True (if attr contains a reference to another reference):\n            - elem.get_reference(attr=\"chain_ref\", follow_chain=True)  # returns ultimate target\n        \"\"\"\n\n        if attr is not None and relative_path is not None:\n            raise ValueError(\n                \"Cannot specify both attr and relative_path. \"\n                \"Please specify only one of them.\"\n            )\n\n        # Handle follow_chain before computing the reference path\n        if follow_chain and attr is not None:\n            raw_value = self.get_raw_value(attr)\n            if not string_reference.is_reference(raw_value):\n                raise ValueError(\n                    f\"Cannot follow reference chain for attr '{attr}': \"\n                    f\"value is not a reference (value={raw_value})\"\n                )\n            # Follow the reference chain to get the ultimate target\n            try:\n                target_obj, target_attr = self._follow_reference_chain(self, attr)\n                # Return the reference path to the ultimate target\n                return target_obj.get_reference(attr=target_attr)\n            except (AttributeError, ValueError, RecursionError) as e:\n                raise ValueError(\n                    f\"Failed to follow reference chain for attr '{attr}': {e}\"\n                ) from e\n\n        if self.parent is None:\n            raise AttributeError(\n                \"Unable to extract reference path for {self}: No parent defined\"\n            )\n\n        try:\n            base_reference = self.parent.get_reference()\n            if base_reference == \"#/\":\n                base_reference = \"#\"\n        except AttributeError:\n            raise AttributeError(\n                f\"Unable to extract reference path for {self}: Could not get \"\n                f\"reference path for parent {self.parent}\"\n            )\n\n        try:\n            attr_name = self.parent.get_attr_name(self)\n        except AttributeError:\n            raise AttributeError(\n                f\"Unable to extract reference path for {self}: Could not get \"\n                f\"attribute name from parent {self.parent}\"\n            )\n\n        reference = f\"{base_reference}/{attr_name}\"\n\n        if relative_path is not None:\n            if not string_reference.is_reference(relative_path):\n                raise ValueError(\n                    f\"Unable to extract reference path for {self}: \"\n                    f\"relative_path {relative_path} is not a reference\"\n                )\n\n            reference = string_reference.join_references(reference, relative_path)\n        elif attr is not None:\n            reference = f\"{reference}/{attr}\"\n\n        return reference\n\n    def get_attrs(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get all attributes and corresponding values of this object.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default\n                value.\n\n        Returns:\n            A dictionary of attribute names and values.\n\n        \"\"\"\n        attr_names = self._get_attr_names()\n\n        skip_attrs = getattr(self, \"_skip_attrs\", [])\n        attr_names = [attr for attr in attr_names if attr not in skip_attrs]\n\n        # Apply skip_save metadata filter\n        if is_dataclass(self):\n            skip_save_attrs = [\n                field.name\n                for field in fields(self)\n                if field.metadata.get(\"skip_save\", False)\n            ]\n            attr_names = [attr for attr in attr_names if attr not in skip_save_attrs]\n\n        if not follow_references:\n            attrs = {attr: self.get_raw_value(attr) for attr in attr_names}\n        else:\n            attrs = {attr: getattr(self, attr) for attr in attr_names}\n\n        if not include_defaults:\n            attrs = {\n                attr: val\n                for attr, val in attrs.items()\n                if not self._attr_val_is_default(attr, val)\n            }\n        return attrs\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Convert this object to a dictionary.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default value.\n\n        Returns:\n            A dictionary representation of this object.\n            Any QuamBase objects will be recursively converted to dictionaries.\n\n        Note:\n            If the value of an attribute does not match the annotation, the\n            `\"__class__\"` key will be added to the dictionary. This is to ensure\n            that the object can be reconstructed when loading from a file.\n        \"\"\"\n        attrs = self.get_attrs(\n            follow_references=follow_references, include_defaults=include_defaults\n        )\n        quam_dict = {}\n        for attr, val in attrs.items():\n            if isinstance(val, QuamBase):\n                quam_dict[attr] = val.to_dict(\n                    follow_references=follow_references,\n                    include_defaults=include_defaults,\n                )\n            else:\n                quam_dict[attr] = val\n\n        # Add __class__ to specify the class of the object\n        quam_dict[\"__class__\"] = get_full_class_path(self)\n\n        return quam_dict\n\n    def iterate_components(\n        self, skip_elems: Optional[Sequence[\"QuamBase\"]] = None\n    ) -&gt; Generator[\"QuamBase\", None, None]:\n        \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n        Args:\n            skip_elems: A sequence of QuamBase objects to skip.\n                This is used to prevent infinite loops when iterating over nested\n                objects.\n\n        Returns:\n            A generator of QuamBase objects.\n        \"\"\"\n        if skip_elems is None:\n            skip_elems = []\n\n        # We don't use \"self in skip_elems\" because we want to check for identity,\n        # not equality. The reason is that you would otherwise have to instantiate\n        # dataclasses using @dataclass(eq=False)\n        in_skip_elems = any(self is elem for elem in skip_elems)\n        if isinstance(self, QuamComponent) and not in_skip_elems:\n            skip_elems.append(self)\n            yield self\n\n        attrs = self.get_attrs(follow_references=False, include_defaults=True)\n\n        for attr_val in attrs.values():\n            if any(attr_val is elem for elem in skip_elems):\n                continue\n\n            if isinstance(attr_val, QuamBase):\n                yield from attr_val.iterate_components(skip_elems=skip_elems)\n\n    def _is_reference(self, attr: str) -&gt; bool:\n        \"\"\"Check whether an attribute is a reference.\n\n        Args:\n            attr: The name of the attribute.\n\n        Returns:\n            True if the attribute is a reference, False otherwise.\n\n        Note:\n            This function is used from the ReferenceClass class.\n        \"\"\"\n        return string_reference.is_reference(attr)\n\n    def _get_referenced_value(self, reference: str) -&gt; Any:\n        \"\"\"Get the value of an attribute by reference\n\n        Args:\n            reference: The reference to the attribute.\n\n        Returns:\n            The value of the attribute, or the reference if it is not a reference\n\n        Note:\n            This function is used from the ReferenceClass class.\n        \"\"\"\n        if not string_reference.is_reference(reference):\n            return reference\n\n        root = self.get_root()\n        if string_reference.is_absolute_reference(reference) and root is None:\n            warnings.warn(\n                f\"No QuamRoot initialized, cannot retrieve absolute reference \"\n                f\"{reference} from {self.__class__.__name__}\"\n            )\n            return reference\n\n        try:\n            return string_reference.get_referenced_value(self, reference, root=root)\n        except InvalidReferenceError as e:\n            try:\n                ref = f\"{self.__class__.__name__}: {self.get_reference()}\"\n            except Exception:\n                ref = self.__class__.__name__\n\n            # Construct message using the chained exception's message\n            base_error_msg = str(e)\n            component_ref_str = f\"component {ref}\"\n            msg = (\n                f'Could not get reference \"{reference}\" from {component_ref_str}. '\n                f\"Error: {base_error_msg}\"\n            )\n\n            try:\n                cfg = get_quam_config()\n                raise_error_missing_reference = cfg.raise_error_missing_reference\n            except FileNotFoundError:\n                # Default behavior if config file not found\n                raise_error_missing_reference = False\n\n            if not raise_error_missing_reference:\n                warnings.warn(msg)\n            else:\n                # Re-raise with context, keeping the original exception chain\n                raise InvalidReferenceError(msg) from e\n            return reference\n\n    def print_summary(self, indent: int = 0):\n        \"\"\"Print a summary of the QuamBase object.\n\n        Args:\n            indent: The number of spaces to indent the summary.\n        \"\"\"\n        if self.get_root() is self:\n            full_name = \"QUAM:\"\n        elif self.parent is None:\n            full_name = f\"{self.__class__.__name__} (parent unknown):\"\n        else:\n            try:\n                attr_name = self.parent.get_attr_name(self)\n                full_name = f\"{attr_name}: {self.__class__.__name__}\"\n            except AttributeError:\n                full_name = f\"{self.__class__.__name__}:\"\n\n        if not self.get_attrs():\n            print(\" \" * indent + f\"{full_name} Empty\")\n            return\n\n        print(\" \" * indent + f\"{full_name}\")\n        for attr, val in self.get_attrs().items():\n            if isinstance(val, str):\n                val = f'\"{val}\"'\n            if isinstance(val, QuamBase):\n                val.print_summary(indent=indent + 2)\n            else:\n                print(\" \" * (indent + 2) + f\"{attr}: {val}\")\n\n    def _follow_reference_chain(\n        self, obj: \"QuamBase\", attr: str, max_depth: Optional[int] = None\n    ) -&gt; tuple[\"QuamBase\", str]:\n        \"\"\"Recursively follow a reference chain to find the ultimate target.\n\n        This method follows reference strings through nested references until\n        reaching a non-reference value. It is used internally by\n        set_at_reference() and get_reference() to handle chained references.\n\n        Args:\n            obj: The QuamBase object containing the attribute.\n            attr: The attribute name to follow (may be a list index like \"0\").\n            max_depth: Maximum recursion depth to prevent infinite loops\n                (default: QuamBase._MAX_REFERENCE_DEPTH).\n\n        Returns:\n            A tuple of (target_object, final_attr_name) where:\n            - target_object: The QuamBase object containing the ultimate value\n            - final_attr_name: The final attribute name (after following all chains)\n\n        Raises:\n            AttributeError: If a reference in the chain cannot be resolved.\n            RecursionError: If max_depth is exceeded (indicates circular reference).\n        \"\"\"\n        # Normalize attr to string for consistent handling\n        attr = str(attr)\n\n        if max_depth is None:\n            max_depth = self._MAX_REFERENCE_DEPTH\n        if max_depth &lt;= 0:\n            raise RecursionError(\n                f\"Reference chain exceeded maximum depth of {self._MAX_REFERENCE_DEPTH}. \"\n                f\"Possible circular reference starting from {obj.get_attr_path()}\"\n            )\n\n        # Handle list/dict index access specially\n        if attr.isdigit() and isinstance(obj, (list, UserList, QuamList)):\n            # For list indices, get the raw element directly from the list\n            index = int(attr)\n            if isinstance(obj, QuamList):\n                raw_value = obj.data[index]\n            else:\n                raw_value = obj[index]\n        else:\n            raw_value = obj.get_raw_value(attr)\n\n        # Base case: value is not a reference\n        if not string_reference.is_reference(raw_value):\n            return obj, attr\n\n        # Recursive case: follow the reference chain\n        parent_reference, parent_attr = string_reference.split_reference(raw_value)\n        if not parent_attr:\n            raise ValueError(\n                f\"Invalid reference {raw_value}: must have an attribute part\"\n            )\n\n        parent_obj = obj._get_referenced_value(parent_reference)\n        if not isinstance(parent_obj, QuamBase):\n            # This can happen when:\n            # 1. Broken reference: _get_referenced_value returns the reference string\n            # 2. Reference to a non-QuamBase value (e.g., primitive)\n            # Raise AttributeError to match the expected contract for set_at_reference\n            raise AttributeError(\n                f\"Cannot follow reference chain: '{parent_reference}' resolved to \"\n                f\"{type(parent_obj).__name__}, not a QuamBase object\"\n            )\n\n        # Recursively follow the chain\n        return self._follow_reference_chain(parent_obj, parent_attr, max_depth - 1)\n\n    def set_at_reference(\n        self, attr: str, value: Any, allow_non_reference: bool = True\n    ):\n        \"\"\"Follow the reference of an attribute and set the value at the reference.\n\n        This method follows reference chains recursively. If an attribute contains\n        a reference to another reference, both references are preserved while the\n        ultimate target value is updated.\n\n        Args:\n            attr: The attribute to set the value at the reference of.\n            value: The value to set.\n            allow_non_reference: Whether to allow the attribute to be a non-reference.\n                If True (default), non-reference attributes are allowed. If False,\n                the attribute must be a reference or an error is raised.\n\n        Raises:\n            ValueError: If the attribute is not a reference and `allow_non_reference` is\n                False.\n            ValueError: If the reference is invalid, e.g. \"#./\" since it has no\n                attribute.\n        \"\"\"\n        raw_value = self.get_raw_value(attr)\n        if not string_reference.is_reference(raw_value):\n            if not allow_non_reference:\n                raise ValueError(\n                    f\"Cannot set at reference because attr '{attr}' is not a reference. \"\n                    f\"'{attr}' = {raw_value}\"\n                )\n            target_obj, target_attr = self, attr\n        else:\n            # Follow the reference chain to get the ultimate target\n            target_obj, target_attr = self._follow_reference_chain(self, attr)\n\n        # Use __setitem__ for dict/list types, otherwise use setattr\n        if isinstance(target_obj, (dict, list, UserDict, UserList, QuamDict, QuamList)):\n            # Convert string index to int for list types\n            if (\n                isinstance(target_obj, (list, UserList, QuamList))\n                and target_attr.isdigit()\n            ):\n                target_attr = int(target_attr)\n            target_obj[target_attr] = value\n        else:\n            setattr(target_obj, target_attr, value)\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.get_attr_name","title":"<code>get_attr_name(attr_val)</code>","text":"<p>Get the name of an attribute that matches the value.</p> <p>Parameters:</p> Name Type Description Default <code>attr_val</code> <code>Any</code> <p>The value of the attribute.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the attribute.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_attr_name(self, attr_val: Any) -&gt; str:\n    \"\"\"Get the name of an attribute that matches the value.\n\n    Args:\n        attr_val: The value of the attribute.\n\n    Returns:\n        The name of the attribute.\n\n    Raises:\n        AttributeError if not found.\n    \"\"\"\n    for attr_name in self._get_attr_names():\n        if self.get_raw_value(attr_name) is attr_val:\n            return attr_name\n    else:\n        raise AttributeError(\n            \"Could not find name corresponding to attribute.\\n\"\n            f\"attribute: {attr_val}\\n\"\n            f\"obj: {self}\"\n        )\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.get_attrs","title":"<code>get_attrs(follow_references=False, include_defaults=True)</code>","text":"<p>Get all attributes and corresponding values of this object.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary of attribute names and values.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_attrs(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; Dict[str, Any]:\n    \"\"\"Get all attributes and corresponding values of this object.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default\n            value.\n\n    Returns:\n        A dictionary of attribute names and values.\n\n    \"\"\"\n    attr_names = self._get_attr_names()\n\n    skip_attrs = getattr(self, \"_skip_attrs\", [])\n    attr_names = [attr for attr in attr_names if attr not in skip_attrs]\n\n    # Apply skip_save metadata filter\n    if is_dataclass(self):\n        skip_save_attrs = [\n            field.name\n            for field in fields(self)\n            if field.metadata.get(\"skip_save\", False)\n        ]\n        attr_names = [attr for attr in attr_names if attr not in skip_save_attrs]\n\n    if not follow_references:\n        attrs = {attr: self.get_raw_value(attr) for attr in attr_names}\n    else:\n        attrs = {attr: getattr(self, attr) for attr in attr_names}\n\n    if not include_defaults:\n        attrs = {\n            attr: val\n            for attr, val in attrs.items()\n            if not self._attr_val_is_default(attr, val)\n        }\n    return attrs\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.get_reference","title":"<code>get_reference(attr=None, relative_path=None, follow_chain=False)</code>","text":"<p>Get the reference path of this object or one of its attributes.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>Optional[str]</code> <p>The optional attribute to get the reference path for. If None, the reference path of the object itself is returned.</p> <code>None</code> <code>relative_path</code> <code>Optional[str]</code> <p>The optional relative path to join with the reference path.</p> <code>None</code> <code>follow_chain</code> <code>bool</code> <p>If True and attr is a reference, follow the reference chain to return the ultimate target reference. Default is False for backward compatibility. Only applies when attr is specified.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The reference path of this object or the specified attribute.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both attr and relative_path are specified, or if follow_chain is True but attr is not a reference.</p> <p>Examples:</p> <p>We assume a QuamRoot object with a component \"elem\". - elem.get_reference() == \"#/elem\" - elem.get_reference(attr=\"child\") == \"#/elem/child\" - elem.get_reference(relative_path=\"#./child\") == \"#/elem/child\" - elem.get_reference(relative_path=\"#../child\") == \"#/child\" - elem.get_reference(relative_path=\"#./child/grandchild\") == \"#/elem/child/grandchild\"</p> <p>With follow_chain=True (if attr contains a reference to another reference): - elem.get_reference(attr=\"chain_ref\", follow_chain=True)  # returns ultimate target</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_reference(\n    self,\n    attr: Optional[str] = None,\n    relative_path: Optional[str] = None,\n    follow_chain: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"Get the reference path of this object or one of its attributes.\n\n    Args:\n        attr: The optional attribute to get the reference path for.\n            If None, the reference path of the object itself is returned.\n        relative_path: The optional relative path to join with the reference path.\n        follow_chain: If True and attr is a reference, follow the reference chain\n            to return the ultimate target reference. Default is False for backward\n            compatibility. Only applies when attr is specified.\n\n    Returns:\n        The reference path of this object or the specified attribute.\n\n    Raises:\n        ValueError: If both attr and relative_path are specified, or if follow_chain\n            is True but attr is not a reference.\n\n    Examples:\n        We assume a QuamRoot object with a component \"elem\".\n        - elem.get_reference() == \"#/elem\"\n        - elem.get_reference(attr=\"child\") == \"#/elem/child\"\n        - elem.get_reference(relative_path=\"#./child\") == \"#/elem/child\"\n        - elem.get_reference(relative_path=\"#../child\") == \"#/child\"\n        - elem.get_reference(relative_path=\"#./child/grandchild\") == \"#/elem/child/grandchild\"\n\n        With follow_chain=True (if attr contains a reference to another reference):\n        - elem.get_reference(attr=\"chain_ref\", follow_chain=True)  # returns ultimate target\n    \"\"\"\n\n    if attr is not None and relative_path is not None:\n        raise ValueError(\n            \"Cannot specify both attr and relative_path. \"\n            \"Please specify only one of them.\"\n        )\n\n    # Handle follow_chain before computing the reference path\n    if follow_chain and attr is not None:\n        raw_value = self.get_raw_value(attr)\n        if not string_reference.is_reference(raw_value):\n            raise ValueError(\n                f\"Cannot follow reference chain for attr '{attr}': \"\n                f\"value is not a reference (value={raw_value})\"\n            )\n        # Follow the reference chain to get the ultimate target\n        try:\n            target_obj, target_attr = self._follow_reference_chain(self, attr)\n            # Return the reference path to the ultimate target\n            return target_obj.get_reference(attr=target_attr)\n        except (AttributeError, ValueError, RecursionError) as e:\n            raise ValueError(\n                f\"Failed to follow reference chain for attr '{attr}': {e}\"\n            ) from e\n\n    if self.parent is None:\n        raise AttributeError(\n            \"Unable to extract reference path for {self}: No parent defined\"\n        )\n\n    try:\n        base_reference = self.parent.get_reference()\n        if base_reference == \"#/\":\n            base_reference = \"#\"\n    except AttributeError:\n        raise AttributeError(\n            f\"Unable to extract reference path for {self}: Could not get \"\n            f\"reference path for parent {self.parent}\"\n        )\n\n    try:\n        attr_name = self.parent.get_attr_name(self)\n    except AttributeError:\n        raise AttributeError(\n            f\"Unable to extract reference path for {self}: Could not get \"\n            f\"attribute name from parent {self.parent}\"\n        )\n\n    reference = f\"{base_reference}/{attr_name}\"\n\n    if relative_path is not None:\n        if not string_reference.is_reference(relative_path):\n            raise ValueError(\n                f\"Unable to extract reference path for {self}: \"\n                f\"relative_path {relative_path} is not a reference\"\n            )\n\n        reference = string_reference.join_references(reference, relative_path)\n    elif attr is not None:\n        reference = f\"{reference}/{attr}\"\n\n    return reference\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.get_root","title":"<code>get_root()</code>","text":"<p>Get the QuamRoot object of this object.</p> <p>This function recursively searches the parent chain for a QuamRoot object. If no QuamRoot object is found, it will return the last instantiated QuamRoot if it exists, else None.</p> <p>Returns:</p> Type Description <code>Optional[QuamRoot]</code> <p>The root of this object, or None if no root is found.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_root(self) -&gt; Optional[QuamRoot]:\n    \"\"\"Get the QuamRoot object of this object.\n\n    This function recursively searches the parent chain for a QuamRoot object.\n    If no QuamRoot object is found, it will return the last instantiated QuamRoot\n    if it exists, else None.\n\n    Returns:\n        The root of this object, or None if no root is found.\n    \"\"\"\n    if self.parent is not None:\n        return self.parent.get_root()\n\n    if self._last_instantiated_root is not None:\n        warnings.warn(\n            f\"This component is not part of any QuamRoot, using last \"\n            f\"instantiated QuamRoot. This is not recommended as it may lead to \"\n            f\"unexpected behaviour. Component: {self.__class__.__name__}\"\n        )\n        return self._last_instantiated_root\n    return None\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.iterate_components","title":"<code>iterate_components(skip_elems=None)</code>","text":"<p>Iterate over all QuamBase objects in this object, including nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>skip_elems</code> <code>Optional[Sequence['QuamBase']]</code> <p>A sequence of QuamBase objects to skip. This is used to prevent infinite loops when iterating over nested objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A generator of QuamBase objects.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def iterate_components(\n    self, skip_elems: Optional[Sequence[\"QuamBase\"]] = None\n) -&gt; Generator[\"QuamBase\", None, None]:\n    \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n    Args:\n        skip_elems: A sequence of QuamBase objects to skip.\n            This is used to prevent infinite loops when iterating over nested\n            objects.\n\n    Returns:\n        A generator of QuamBase objects.\n    \"\"\"\n    if skip_elems is None:\n        skip_elems = []\n\n    # We don't use \"self in skip_elems\" because we want to check for identity,\n    # not equality. The reason is that you would otherwise have to instantiate\n    # dataclasses using @dataclass(eq=False)\n    in_skip_elems = any(self is elem for elem in skip_elems)\n    if isinstance(self, QuamComponent) and not in_skip_elems:\n        skip_elems.append(self)\n        yield self\n\n    attrs = self.get_attrs(follow_references=False, include_defaults=True)\n\n    for attr_val in attrs.values():\n        if any(attr_val is elem for elem in skip_elems):\n            continue\n\n        if isinstance(attr_val, QuamBase):\n            yield from attr_val.iterate_components(skip_elems=skip_elems)\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.print_summary","title":"<code>print_summary(indent=0)</code>","text":"<p>Print a summary of the QuamBase object.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The number of spaces to indent the summary.</p> <code>0</code> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def print_summary(self, indent: int = 0):\n    \"\"\"Print a summary of the QuamBase object.\n\n    Args:\n        indent: The number of spaces to indent the summary.\n    \"\"\"\n    if self.get_root() is self:\n        full_name = \"QUAM:\"\n    elif self.parent is None:\n        full_name = f\"{self.__class__.__name__} (parent unknown):\"\n    else:\n        try:\n            attr_name = self.parent.get_attr_name(self)\n            full_name = f\"{attr_name}: {self.__class__.__name__}\"\n        except AttributeError:\n            full_name = f\"{self.__class__.__name__}:\"\n\n    if not self.get_attrs():\n        print(\" \" * indent + f\"{full_name} Empty\")\n        return\n\n    print(\" \" * indent + f\"{full_name}\")\n    for attr, val in self.get_attrs().items():\n        if isinstance(val, str):\n            val = f'\"{val}\"'\n        if isinstance(val, QuamBase):\n            val.print_summary(indent=indent + 2)\n        else:\n            print(\" \" * (indent + 2) + f\"{attr}: {val}\")\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.set_at_reference","title":"<code>set_at_reference(attr, value, allow_non_reference=True)</code>","text":"<p>Follow the reference of an attribute and set the value at the reference.</p> <p>This method follows reference chains recursively. If an attribute contains a reference to another reference, both references are preserved while the ultimate target value is updated.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The attribute to set the value at the reference of.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required <code>allow_non_reference</code> <code>bool</code> <p>Whether to allow the attribute to be a non-reference. If True (default), non-reference attributes are allowed. If False, the attribute must be a reference or an error is raised.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the attribute is not a reference and <code>allow_non_reference</code> is False.</p> <code>ValueError</code> <p>If the reference is invalid, e.g. \"#./\" since it has no attribute.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def set_at_reference(\n    self, attr: str, value: Any, allow_non_reference: bool = True\n):\n    \"\"\"Follow the reference of an attribute and set the value at the reference.\n\n    This method follows reference chains recursively. If an attribute contains\n    a reference to another reference, both references are preserved while the\n    ultimate target value is updated.\n\n    Args:\n        attr: The attribute to set the value at the reference of.\n        value: The value to set.\n        allow_non_reference: Whether to allow the attribute to be a non-reference.\n            If True (default), non-reference attributes are allowed. If False,\n            the attribute must be a reference or an error is raised.\n\n    Raises:\n        ValueError: If the attribute is not a reference and `allow_non_reference` is\n            False.\n        ValueError: If the reference is invalid, e.g. \"#./\" since it has no\n            attribute.\n    \"\"\"\n    raw_value = self.get_raw_value(attr)\n    if not string_reference.is_reference(raw_value):\n        if not allow_non_reference:\n            raise ValueError(\n                f\"Cannot set at reference because attr '{attr}' is not a reference. \"\n                f\"'{attr}' = {raw_value}\"\n            )\n        target_obj, target_attr = self, attr\n    else:\n        # Follow the reference chain to get the ultimate target\n        target_obj, target_attr = self._follow_reference_chain(self, attr)\n\n    # Use __setitem__ for dict/list types, otherwise use setattr\n    if isinstance(target_obj, (dict, list, UserDict, UserList, QuamDict, QuamList)):\n        # Convert string index to int for list types\n        if (\n            isinstance(target_obj, (list, UserList, QuamList))\n            and target_attr.isdigit()\n        ):\n            target_attr = int(target_attr)\n        target_obj[target_attr] = value\n    else:\n        setattr(target_obj, target_attr, value)\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamBase.to_dict","title":"<code>to_dict(follow_references=False, include_defaults=True)</code>","text":"<p>Convert this object to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary representation of this object.</p> <code>Dict[str, Any]</code> <p>Any QuamBase objects will be recursively converted to dictionaries.</p> Note <p>If the value of an attribute does not match the annotation, the <code>\"__class__\"</code> key will be added to the dictionary. This is to ensure that the object can be reconstructed when loading from a file.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def to_dict(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert this object to a dictionary.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default value.\n\n    Returns:\n        A dictionary representation of this object.\n        Any QuamBase objects will be recursively converted to dictionaries.\n\n    Note:\n        If the value of an attribute does not match the annotation, the\n        `\"__class__\"` key will be added to the dictionary. This is to ensure\n        that the object can be reconstructed when loading from a file.\n    \"\"\"\n    attrs = self.get_attrs(\n        follow_references=follow_references, include_defaults=include_defaults\n    )\n    quam_dict = {}\n    for attr, val in attrs.items():\n        if isinstance(val, QuamBase):\n            quam_dict[attr] = val.to_dict(\n                follow_references=follow_references,\n                include_defaults=include_defaults,\n            )\n        else:\n            quam_dict[attr] = val\n\n    # Add __class__ to specify the class of the object\n    quam_dict[\"__class__\"] = get_full_class_path(self)\n\n    return quam_dict\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamComponent","title":"<code>QuamComponent</code>","text":"<p>               Bases: <code>QuamBase</code></p> <p>Base class for any QUAM component class.</p> <p>Examples of QuamComponent classes are <code>Mixer</code>, <code>LocalOscillator</code>, <code>Pulse</code>, etc.</p> Note <p>This class should be subclassed and made a dataclass.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>class QuamComponent(QuamBase):\n    \"\"\"Base class for any QUAM component class.\n\n    Examples of QuamComponent classes are [`Mixer`][quam.components.hardware.Mixer],\n    [`LocalOscillator`][quam.components.hardware.LocalOscillator],\n    [`Pulse`][quam.components.pulses.Pulse], etc.\n\n    Note:\n        This class should be subclassed and made a dataclass.\n    \"\"\"\n\n    def __setattr__(self, name, value):\n        converted_val = convert_dict_and_list(value, cls_or_obj=self, attr=name)\n        super().__setattr__(name, converted_val)\n\n        if isinstance(converted_val, QuamBase) and name != \"parent\":\n            converted_val.parent = self\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Add information to the QUA configuration, such as pulses and waveforms.\n\n        Args:\n            config: The QUA configuration dictionary. Initially this is a nearly empty\n                dictionary, but\n\n        Note:\n            This function is called by\n            [`QuamRoot.generate_config`][quam.core.quam_classes.QuamRoot.generate_config].\n\n        Note:\n            The config has a starting template, defined at [`quam.core.qua_config_template`][]\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamComponent.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information to the QUA configuration, such as pulses and waveforms.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The QUA configuration dictionary. Initially this is a nearly empty dictionary, but</p> required Note <p>This function is called by <code>QuamRoot.generate_config</code>.</p> Note <p>The config has a starting template, defined at <code>quam.core.qua_config_template</code></p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Add information to the QUA configuration, such as pulses and waveforms.\n\n    Args:\n        config: The QUA configuration dictionary. Initially this is a nearly empty\n            dictionary, but\n\n    Note:\n        This function is called by\n        [`QuamRoot.generate_config`][quam.core.quam_classes.QuamRoot.generate_config].\n\n    Note:\n        The config has a starting template, defined at [`quam.core.qua_config_template`][]\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamDict","title":"<code>QuamDict</code>","text":"<p>               Bases: <code>UserDict</code>, <code>QuamBase</code></p> <p>A QUAM dictionary class.</p> <p>Any dict added to a <code>QuamBase</code> object is automatically converted to a <code>QuamDict</code>. The <code>QuamDict</code> adds the following functionalities to a dict: - Values can be references (see below) - Keys can also be accessed through attributes (e.g. <code>d.a</code> instead of <code>d[\"a\"]</code>)</p>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamDict--quamdict-references","title":"QuamDict references","text":"<p>QuamDict values can be references, which are strings that start with <code>#</code>. See the documentation for details on references. An example is shown here: <pre><code>d = QuamDict({\"a\": 1, \"b\": \"#./a\"})\nassert d[\"b\"] == 1\n</code></pre></p> Warning <p>This class is a subclass of <code>QuamBase</code>, but also of <code>UserDict</code>. As a result, it can be used as a normal dictionary, but it is not a subclass of <code>dict</code>.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@quam_dataclass\nclass QuamDict(UserDict, QuamBase):\n    \"\"\"A QUAM dictionary class.\n\n    Any dict added to a `QuamBase` object is automatically converted to a `QuamDict`.\n    The `QuamDict` adds the following functionalities to a dict:\n    - Values can be references (see below)\n    - Keys can also be accessed through attributes (e.g. `d.a` instead of `d[\"a\"]`)\n\n    # QuamDict references\n    QuamDict values can be references, which are strings that start with `#`. See the\n    documentation for details on references. An example is shown here:\n    ```\n    d = QuamDict({\"a\": 1, \"b\": \"#./a\"})\n    assert d[\"b\"] == 1\n    ```\n\n    Warning:\n        This class is a subclass of `QuamBase`, but also of `UserDict`. As a result,\n        it can be used as a normal dictionary, but it is not a subclass of `dict`.\n    \"\"\"\n\n    _value_annotation: ClassVar[type] = None\n\n    def __init__(self, dict=None, /, value_annotation: type = None, **kwargs):\n        self.__dict__[\"data\"] = {}\n        self.__dict__[\"_value_annotation\"] = value_annotation\n        self.__dict__[\"_initialized\"] = True\n        super().__init__(dict, **kwargs)\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError as e:\n            try:\n                repr = f\"{self.__class__.__name__}: {self.get_reference()}\"\n            except Exception:\n                repr = self.__class__.__name__\n            raise AttributeError(f'{repr} has no attribute \"{key}\"') from e\n\n    def __setattr__(self, key, value):\n        if key in [\"data\", \"parent\", \"config_settings\", \"_initialized\"]:\n            super().__setattr__(key, value)\n        else:\n            self[key] = value\n\n    def __getitem__(self, i):\n        elem = super().__getitem__(i)\n\n        if not string_reference.is_reference(elem):\n            return elem\n\n        try:\n            target_obj, target_attr = self._follow_reference_chain(self, i)\n            # Handle list/dict indices that result from following the chain\n            if target_attr.isdigit() and isinstance(\n                target_obj, (list, UserList, QuamList)\n            ):\n                return target_obj[int(target_attr)]\n            elif isinstance(target_obj, (dict, UserDict, QuamDict)):\n                return target_obj[target_attr]\n            else:\n                return target_obj.get_raw_value(target_attr)\n        except (AttributeError, KeyError, ValueError):\n            # Chain couldn't be followed (broken reference, missing attribute, etc.)\n            # Return the reference string - _get_referenced_value handles warnings\n            return self._get_referenced_value(elem)\n\n    # Overriding methods from UserDict\n    def __setitem__(self, key, value):\n        value = convert_dict_and_list(value)\n        self._is_valid_setattr(key, value, error_on_False=True)\n        super().__setitem__(key, value)\n\n        if isinstance(value, QuamBase):\n            value.parent = self\n\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, dict):\n            return self.data == other\n        return super().__eq__(other)\n\n    def __repr__(self) -&gt; str:\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\",\n                message=\"^Could not get reference*\",\n                category=UserWarning,\n            )\n            return super().__repr__()\n\n    # QUAM methods\n    def _get_attr_names(self):\n        return list(self.data.keys())\n\n    def get_attrs(\n        self, follow_references=False, include_defaults=True\n    ) -&gt; Dict[str, Any]:\n        # TODO implement reference kwargs\n        return self.data\n\n    def get_attr_name(self, attr_val: Any) -&gt; Union[str, int]:\n        \"\"\"Get the name of an attribute that matches the value.\n\n        Args:\n            attr_val: The value of the attribute.\n\n        Returns:\n            The name of the attribute. This can also be an int depending on the dict key\n\n        Raises:\n            AttributeError if not found.\n        \"\"\"\n        for attr_name in self._get_attr_names():\n            if attr_name in self and self.get_raw_value(attr_name) is attr_val:\n                return attr_name\n        else:\n            raise AttributeError(\n                \"Could not find name corresponding to attribute.\\n\"\n                f\"attribute: {attr_val}\\n\"\n                f\"obj: {self}\"\n            )\n\n    def _val_matches_attr_annotation(self, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the type of an attribute matches the annotation.\n\n        Called by [`QuamDict.to_dict`][quam.core.quam_classes.QuamDict.to_dict] to\n        determine whether to add the __class__ key.\n\n        Args:\n            attr: The name of the attribute. Unused but added to match parent signature\n            val: The value of the attribute.\n\n        Note:\n            The attribute val is compared to `QuamDict._value_annotation`, which is set\n            when a dict is converted to a `QuamDict` using `convert_dict_and_list`.\n        \"\"\"\n        if isinstance(val, (QuamDict, QuamList)):\n            return True\n        if self._value_annotation is None:\n            return False\n        return type(val) == self._value_annotation\n\n    def _attr_val_is_default(self, attr: str, val: Any):\n        \"\"\"Check whether the value of an attribute is the default value.\n\n        Overrides parent method.\n        Since a QuamDict does not have any fixed attrs, this is always False.\n\n        \"\"\"\n        return False\n\n    def get_raw_value(self, attr: str) -&gt; Any:\n        \"\"\"Get the value of an attribute without following references.\n\n        Args:\n            attr: The name of the attribute.\n\n        Returns:\n            The value of the attribute. If the value is a reference, it returns the\n            reference string instead of the value it is referencing.\n        \"\"\"\n        try:\n            return self.__dict__[\"data\"][attr]\n        except KeyError as e:\n            raise AttributeError(\n                \"Cannot get raw (unreferenced)value from attribute {attr} that does not\"\n                \" exist in {self}\"\n            ) from e\n\n    def iterate_components(\n        self, skip_elems: Sequence[QuamBase] = None\n    ) -&gt; Generator[\"QuamBase\", None, None]:\n        \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n        Args:\n            skip_elems: A sequence of QuamBase objects to skip.\n                This is used to prevent infinite loops when iterating over nested\n                objects.\n\n        Returns:\n            A generator of QuamBase objects.\n        \"\"\"\n        if skip_elems is None:\n            skip_elems = []\n\n        for attr_val in self.data.values():\n            if any(attr_val is elem for elem in skip_elems):\n                continue\n\n            if isinstance(attr_val, QuamBase):\n                yield from attr_val.iterate_components(skip_elems=skip_elems)\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; dict:\n        \"\"\"Convert this object to a dictionary.\n\n        Ensures all child QUAM objects are also converted to dictionaries.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default\n                value.\n\n        Returns:\n            A dictionary representation of the object.\n        \"\"\"\n        quam_dict = super().to_dict(\n            follow_references=follow_references,\n            include_defaults=include_defaults,\n        )\n\n        # Remove __class__ from the dictionary as it's the default for a dict\n        quam_dict.pop(\"__class__\", None)\n\n        return quam_dict\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamDict.get_attr_name","title":"<code>get_attr_name(attr_val)</code>","text":"<p>Get the name of an attribute that matches the value.</p> <p>Parameters:</p> Name Type Description Default <code>attr_val</code> <code>Any</code> <p>The value of the attribute.</p> required <p>Returns:</p> Type Description <code>Union[str, int]</code> <p>The name of the attribute. This can also be an int depending on the dict key</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_attr_name(self, attr_val: Any) -&gt; Union[str, int]:\n    \"\"\"Get the name of an attribute that matches the value.\n\n    Args:\n        attr_val: The value of the attribute.\n\n    Returns:\n        The name of the attribute. This can also be an int depending on the dict key\n\n    Raises:\n        AttributeError if not found.\n    \"\"\"\n    for attr_name in self._get_attr_names():\n        if attr_name in self and self.get_raw_value(attr_name) is attr_val:\n            return attr_name\n    else:\n        raise AttributeError(\n            \"Could not find name corresponding to attribute.\\n\"\n            f\"attribute: {attr_val}\\n\"\n            f\"obj: {self}\"\n        )\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamDict.get_raw_value","title":"<code>get_raw_value(attr)</code>","text":"<p>Get the value of an attribute without following references.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the attribute. If the value is a reference, it returns the</p> <code>Any</code> <p>reference string instead of the value it is referencing.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_raw_value(self, attr: str) -&gt; Any:\n    \"\"\"Get the value of an attribute without following references.\n\n    Args:\n        attr: The name of the attribute.\n\n    Returns:\n        The value of the attribute. If the value is a reference, it returns the\n        reference string instead of the value it is referencing.\n    \"\"\"\n    try:\n        return self.__dict__[\"data\"][attr]\n    except KeyError as e:\n        raise AttributeError(\n            \"Cannot get raw (unreferenced)value from attribute {attr} that does not\"\n            \" exist in {self}\"\n        ) from e\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamDict.iterate_components","title":"<code>iterate_components(skip_elems=None)</code>","text":"<p>Iterate over all QuamBase objects in this object, including nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>skip_elems</code> <code>Sequence[QuamBase]</code> <p>A sequence of QuamBase objects to skip. This is used to prevent infinite loops when iterating over nested objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A generator of QuamBase objects.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def iterate_components(\n    self, skip_elems: Sequence[QuamBase] = None\n) -&gt; Generator[\"QuamBase\", None, None]:\n    \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n    Args:\n        skip_elems: A sequence of QuamBase objects to skip.\n            This is used to prevent infinite loops when iterating over nested\n            objects.\n\n    Returns:\n        A generator of QuamBase objects.\n    \"\"\"\n    if skip_elems is None:\n        skip_elems = []\n\n    for attr_val in self.data.values():\n        if any(attr_val is elem for elem in skip_elems):\n            continue\n\n        if isinstance(attr_val, QuamBase):\n            yield from attr_val.iterate_components(skip_elems=skip_elems)\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamDict.to_dict","title":"<code>to_dict(follow_references=False, include_defaults=True)</code>","text":"<p>Convert this object to a dictionary.</p> <p>Ensures all child QUAM objects are also converted to dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def to_dict(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; dict:\n    \"\"\"Convert this object to a dictionary.\n\n    Ensures all child QUAM objects are also converted to dictionaries.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default\n            value.\n\n    Returns:\n        A dictionary representation of the object.\n    \"\"\"\n    quam_dict = super().to_dict(\n        follow_references=follow_references,\n        include_defaults=include_defaults,\n    )\n\n    # Remove __class__ from the dictionary as it's the default for a dict\n    quam_dict.pop(\"__class__\", None)\n\n    return quam_dict\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamList","title":"<code>QuamList</code>","text":"<p>               Bases: <code>UserList</code>, <code>QuamBase</code></p> <p>A QUAM list class.</p> <p>Any list added to a <code>QuamBase</code> object is automatically converted to a <code>QuamList</code>. The <code>QuamList</code> adds the following functionalities to a list: - Elements can be references (see below)</p>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamList--quamlist-references","title":"QuamList references","text":"<p>QuamList values can be references, which are strings that start with <code>#</code>. See the documentation for details on references. An example is shown here: <pre><code>d = QuamList([1, \"#./0\"]])\nassert d[1] == 1\n</code></pre></p> Warning <p>This class is a subclass of <code>QuamBase</code>, but also of <code>UserList</code>. As a result, it can be used as a normal list, but it is not a subclass of <code>list</code>.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@quam_dataclass\nclass QuamList(UserList, QuamBase):\n    \"\"\"A QUAM list class.\n\n    Any list added to a `QuamBase` object is automatically converted to a `QuamList`.\n    The `QuamList` adds the following functionalities to a list:\n    - Elements can be references (see below)\n\n    # QuamList references\n    QuamList values can be references, which are strings that start with `#`. See the\n    documentation for details on references. An example is shown here:\n    ```\n    d = QuamList([1, \"#./0\"]])\n    assert d[1] == 1\n    ```\n\n    Warning:\n        This class is a subclass of `QuamBase`, but also of `UserList`. As a result,\n        it can be used as a normal list, but it is not a subclass of `list`.\n    \"\"\"\n\n    _value_annotation: ClassVar[type] = None\n\n    def __init__(self, *args, value_annotation: type = None):\n        self._value_annotation = value_annotation\n\n        # We manually add elements using extend instead of passing to super()\n        # To ensure that any dicts and lists get converted to QuamDict and QuamList\n        super().__init__()\n        if args:\n            self.extend(*args)\n\n    # Overloading methods from UserList\n    def __eq__(self, value: object) -&gt; bool:\n        return super().__eq__(value)\n\n    def __repr__(self) -&gt; str:\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\",\n                message=\"^Could not get reference*\",\n                category=UserWarning,\n            )\n            return super().__repr__()\n\n    def __getitem__(self, i):\n        elem = super().__getitem__(i)\n        if isinstance(i, slice):\n            if isinstance(elem, QuamList):\n                elem.parent = self.parent\n            # This automatically gets the referenced values\n            return list(elem)\n\n        elif not string_reference.is_reference(elem):\n            return elem\n\n        try:\n            target_obj, target_attr = self._follow_reference_chain(self, i)\n            # Handle list/dict indices that result from following the chain\n            if target_attr.isdigit() and isinstance(\n                target_obj, (list, UserList, QuamList)\n            ):\n                return target_obj[int(target_attr)]\n            elif isinstance(target_obj, (dict, UserDict, QuamDict)):\n                return target_obj[target_attr]\n            else:\n                return target_obj.get_raw_value(target_attr)\n        except (AttributeError, KeyError, ValueError):\n            # Chain couldn't be followed (broken reference, missing attribute, etc.)\n            # Return the reference string - _get_referenced_value handles warnings\n            return self._get_referenced_value(elem)\n\n    def __setitem__(self, i, item):\n        converted_item = convert_dict_and_list(item)\n        super().__setitem__(i, converted_item)\n\n        if isinstance(converted_item, QuamBase):\n            converted_item.parent = self\n\n    def __iadd__(self, other: Iterable):\n        converted_other = [convert_dict_and_list(elem) for elem in other]\n        return super().__iadd__(converted_other)\n\n    def append(self, item: Any) -&gt; None:\n        converted_item = convert_dict_and_list(item)\n\n        if isinstance(converted_item, QuamBase):\n            converted_item.parent = self\n\n        return super().append(converted_item)\n\n    def insert(self, i: int, item: Any) -&gt; None:\n        converted_item = convert_dict_and_list(item)\n\n        if isinstance(converted_item, QuamBase):\n            converted_item.parent = self\n\n        return super().insert(i, converted_item)\n\n    def extend(self, iterable: Iterator) -&gt; None:\n        converted_iterable = [convert_dict_and_list(elem) for elem in iterable]\n        for converted_item in converted_iterable:\n            if isinstance(converted_item, QuamBase):\n                converted_item.parent = self\n\n        return super().extend(converted_iterable)\n\n    # Quam methods\n    def _val_matches_attr_annotation(self, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the type of an attribute matches the annotation.\n\n        Called by QuamList.to_dict to determine whether to add the __class__ key.\n        For the QuamList, we compare the type to the _value_annotation.\n        \"\"\"\n        if isinstance(val, (QuamDict, QuamList)):\n            return True\n        if self._value_annotation is None:\n            return False\n        return type(val) == self._value_annotation\n\n    def get_attr_name(self, attr_val: Any) -&gt; str:\n        for k, elem in enumerate(self.data):\n            if elem is attr_val:\n                return str(k)\n        else:\n            raise AttributeError(\n                \"Could not find name corresponding to attribute\"\n                f\"attribute: {attr_val}\\n\"\n                f\"obj: {self}\"\n            )\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; list:\n        \"\"\"Convert this object to a list, usually as part of a dictionary representation.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default\n                value.\n\n        Returns:\n            A list with the values of this object. Any QuamBase objects will be\n            recursively converted to dictionaries.\n\n        Note:\n            If the value of an attribute does not match the annotation of\n            `QuamList._value_annotation`, the `\"__class__\"` key will be added to the\n            dictionary. This is to ensure that the object can be reconstructed when\n            loading from a file.\n        \"\"\"\n        quam_list = []\n        for val in self.data:\n            if isinstance(val, QuamBase):\n                quam_list.append(\n                    val.to_dict(\n                        follow_references=follow_references,\n                        include_defaults=include_defaults,\n                    )\n                )\n            else:\n                quam_list.append(val)\n        return quam_list\n\n    def iterate_components(\n        self, skip_elems: List[QuamBase] = None\n    ) -&gt; Generator[\"QuamBase\", None, None]:\n        \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n        Args:\n            skip_elems: A list of QuamBase objects to skip.\n                This is used to prevent infinite loops when iterating over nested\n                objects.\n\n        Returns:\n            A generator of QuamBase objects.\n        \"\"\"\n        if skip_elems is None:\n            skip_elems = []\n\n        for attr_val in self.data:\n            if any(attr_val is elem for elem in skip_elems):\n                continue\n\n            if isinstance(attr_val, QuamBase):\n                yield from attr_val.iterate_components(skip_elems=skip_elems)\n\n    def get_attrs(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        raise NotImplementedError(\"QuamList does not have attributes\")\n\n    def print_summary(self, indent: int = 0):\n        \"\"\"Print a summary of the QuamBase object.\n\n        Args:\n            indent: The number of spaces to indent the summary.\n        \"\"\"\n\n        if self.parent is None:\n            full_name = f\"{self.__class__.__name__} (parent unknown):\"\n        else:\n            try:\n                attr_name = self.parent.get_attr_name(self)\n                full_name = f\"{attr_name}: {self.__class__.__name__}\"\n            except AttributeError:\n                full_name = f\"{self.__class__.__name__}:\"\n\n        if not self.data:\n            print(\" \" * indent + f\"{full_name} = []\")\n            return\n\n        print(\" \" * indent + f\"{full_name}:\")\n        if len(str(self.data)) + 2 * indent &lt; 80:\n            print(\" \" * (indent + 2) + f\"{self.data}\")\n        else:\n            for k, val in enumerate(self.data):\n                if isinstance(val, QuamBase):\n                    val.print_summary(indent=indent + 2)\n                else:\n                    print(\" \" * (indent + 2) + f\"{k}: {val}\")\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamList.iterate_components","title":"<code>iterate_components(skip_elems=None)</code>","text":"<p>Iterate over all QuamBase objects in this object, including nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>skip_elems</code> <code>List[QuamBase]</code> <p>A list of QuamBase objects to skip. This is used to prevent infinite loops when iterating over nested objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A generator of QuamBase objects.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def iterate_components(\n    self, skip_elems: List[QuamBase] = None\n) -&gt; Generator[\"QuamBase\", None, None]:\n    \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n    Args:\n        skip_elems: A list of QuamBase objects to skip.\n            This is used to prevent infinite loops when iterating over nested\n            objects.\n\n    Returns:\n        A generator of QuamBase objects.\n    \"\"\"\n    if skip_elems is None:\n        skip_elems = []\n\n    for attr_val in self.data:\n        if any(attr_val is elem for elem in skip_elems):\n            continue\n\n        if isinstance(attr_val, QuamBase):\n            yield from attr_val.iterate_components(skip_elems=skip_elems)\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamList.print_summary","title":"<code>print_summary(indent=0)</code>","text":"<p>Print a summary of the QuamBase object.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The number of spaces to indent the summary.</p> <code>0</code> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def print_summary(self, indent: int = 0):\n    \"\"\"Print a summary of the QuamBase object.\n\n    Args:\n        indent: The number of spaces to indent the summary.\n    \"\"\"\n\n    if self.parent is None:\n        full_name = f\"{self.__class__.__name__} (parent unknown):\"\n    else:\n        try:\n            attr_name = self.parent.get_attr_name(self)\n            full_name = f\"{attr_name}: {self.__class__.__name__}\"\n        except AttributeError:\n            full_name = f\"{self.__class__.__name__}:\"\n\n    if not self.data:\n        print(\" \" * indent + f\"{full_name} = []\")\n        return\n\n    print(\" \" * indent + f\"{full_name}:\")\n    if len(str(self.data)) + 2 * indent &lt; 80:\n        print(\" \" * (indent + 2) + f\"{self.data}\")\n    else:\n        for k, val in enumerate(self.data):\n            if isinstance(val, QuamBase):\n                val.print_summary(indent=indent + 2)\n            else:\n                print(\" \" * (indent + 2) + f\"{k}: {val}\")\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamList.to_dict","title":"<code>to_dict(follow_references=False, include_defaults=True)</code>","text":"<p>Convert this object to a list, usually as part of a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list with the values of this object. Any QuamBase objects will be</p> <code>list</code> <p>recursively converted to dictionaries.</p> Note <p>If the value of an attribute does not match the annotation of <code>QuamList._value_annotation</code>, the <code>\"__class__\"</code> key will be added to the dictionary. This is to ensure that the object can be reconstructed when loading from a file.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def to_dict(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; list:\n    \"\"\"Convert this object to a list, usually as part of a dictionary representation.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default\n            value.\n\n    Returns:\n        A list with the values of this object. Any QuamBase objects will be\n        recursively converted to dictionaries.\n\n    Note:\n        If the value of an attribute does not match the annotation of\n        `QuamList._value_annotation`, the `\"__class__\"` key will be added to the\n        dictionary. This is to ensure that the object can be reconstructed when\n        loading from a file.\n    \"\"\"\n    quam_list = []\n    for val in self.data:\n        if isinstance(val, QuamBase):\n            quam_list.append(\n                val.to_dict(\n                    follow_references=follow_references,\n                    include_defaults=include_defaults,\n                )\n            )\n        else:\n            quam_list.append(val)\n    return quam_list\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamRoot","title":"<code>QuamRoot</code>","text":"<p>               Bases: <code>QuamBase</code></p> <p>Base class for the root of a QUAM object.</p> <p>This class should be subclassed and made a dataclass.</p> Note <p>This class should not be used directly, but should generally be subclassed and made a dataclass. The dataclass fields should correspond to the QUAM root structure.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>class QuamRoot(QuamBase):\n    \"\"\"Base class for the root of a QUAM object.\n\n    This class should be subclassed and made a dataclass.\n\n    Note:\n        This class should not be used directly, but should generally be subclassed and\n        made a dataclass. The dataclass fields should correspond to the QUAM root\n        structure.\n    \"\"\"\n\n    def __post_init__(self):\n        QuamBase._last_instantiated_root = self\n        self.serialiser = self.get_serialiser()\n        super().__post_init__()\n\n    def __setattr__(self, name, value):\n        converted_val = convert_dict_and_list(value, cls_or_obj=self, attr=name)\n        super().__setattr__(name, converted_val)\n\n        if isinstance(converted_val, QuamBase) and name != \"parent\":\n            converted_val.parent = self\n\n    @classmethod\n    def get_serialiser(cls) -&gt; AbstractSerialiser:\n        \"\"\"Get the serialiser for the QuamRoot class, which is the JSONSerialiser.\n\n        This method can be overridden by subclasses to provide a custom serialiser.\n        \"\"\"\n        return JSONSerialiser()\n\n    def get_reference(\n        self, attr: Optional[str] = None, relative_path: Optional[str] = None\n    ) -&gt; Optional[str]:\n        if attr is not None:\n            return f\"#/{attr}\"\n\n        reference = \"#/\"\n        if relative_path is not None:\n            reference = string_reference.join_references(reference, relative_path)\n        return reference\n\n    def get_root(self: QuamRootType) -&gt; QuamRootType:\n        \"\"\"Get the QuamRoot object of this object, i.e. the object itself.\n\n        This QuamRoot function overrides the QuamBase function to return the object\n        itself, rather than following the parent chain.\n\n        Returns:\n            The current QuamRoot object (self).\n        \"\"\"\n        return self\n\n    def save(\n        self,\n        path: Optional[Union[Path, str]] = None,\n        content_mapping: Optional[Dict[str, str]] = None,\n        include_defaults: Optional[bool] = None,\n        ignore: Optional[Sequence[str]] = None,\n    ):\n        \"\"\"Save the entire QuamRoot object to a file. This includes nested objects.\n\n        Args:\n            path: The path to save the file to. If None, the path will be extracted from\n                the `state_path` attribute of the serialiser, which could be set by the\n                quam config file or environment variable.\n            content_mapping: Optional mapping of component names to filenames. This can\n                be used to save different parts of the QuamRoot object to different\n                files.\n            include_defaults: Whether to include attributes that have the default\n                value.\n            ignore: A list of components to ignore.\n        \"\"\"\n        self.serialiser.save(\n            quam_obj=self,\n            path=path,\n            content_mapping=content_mapping,\n            include_defaults=include_defaults,\n            ignore=ignore,\n        )\n\n    @classmethod\n    def load(\n        cls: type[QuamRootType],\n        filepath_or_dict: Optional[Union[str, Path, dict]] = None,\n        validate_type: bool = True,\n        fix_attrs: bool = True,\n    ) -&gt; QuamRootType:\n        \"\"\"Load a QuamRoot object from a file.\n\n        Args:\n            filepath_or_dict: The path to the file/folder to load, or a dictionary.\n                The dictionary would be the result from a call to `QuamRoot.save()`\n                Can be omitted, in which case the serialiser will use the default state\n                path, which is typically defined in the quam config file.\n            validate_type: Whether to validate the type of all attributes while loading.\n            fix_attrs: Whether attributes can be added to QuamBase objects that are not\n                defined as dataclass fields.\n\n        Returns:\n            A QuamRoot object instantiated from the file/folder/dict.\n        \"\"\"\n        if isinstance(filepath_or_dict, dict):\n            contents = filepath_or_dict\n        else:\n            serialiser = cls.get_serialiser()\n            contents, _ = serialiser.load(filepath_or_dict)\n\n        return instantiate_quam_class(\n            quam_class=cls,\n            contents=contents,\n            fix_attrs=fix_attrs,\n            validate_type=validate_type,\n        )\n\n    def generate_config(self) -&gt; DictQuaConfig:\n        \"\"\"Generate the QUA configuration from the QUAM object.\n\n        Returns:\n            A dictionary with the QUA configuration.\n\n        Note:\n            This function collects all the nested QuamComponent objects and calls\n            `QuamComponent.apply_to_config` on them.\n        \"\"\"\n        qua_config = deepcopy(qua_config_template)\n\n        quam_components = list(self.iterate_components())\n        sorted_components = sort_quam_components(quam_components)\n\n        for quam_component in sorted_components:\n            quam_component.apply_to_config(qua_config)\n\n        generate_config_final_actions(qua_config)\n\n        return qua_config\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamRoot.generate_config","title":"<code>generate_config()</code>","text":"<p>Generate the QUA configuration from the QUAM object.</p> <p>Returns:</p> Type Description <code>DictQuaConfig</code> <p>A dictionary with the QUA configuration.</p> Note <p>This function collects all the nested QuamComponent objects and calls <code>QuamComponent.apply_to_config</code> on them.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def generate_config(self) -&gt; DictQuaConfig:\n    \"\"\"Generate the QUA configuration from the QUAM object.\n\n    Returns:\n        A dictionary with the QUA configuration.\n\n    Note:\n        This function collects all the nested QuamComponent objects and calls\n        `QuamComponent.apply_to_config` on them.\n    \"\"\"\n    qua_config = deepcopy(qua_config_template)\n\n    quam_components = list(self.iterate_components())\n    sorted_components = sort_quam_components(quam_components)\n\n    for quam_component in sorted_components:\n        quam_component.apply_to_config(qua_config)\n\n    generate_config_final_actions(qua_config)\n\n    return qua_config\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamRoot.get_root","title":"<code>get_root()</code>","text":"<p>Get the QuamRoot object of this object, i.e. the object itself.</p> <p>This QuamRoot function overrides the QuamBase function to return the object itself, rather than following the parent chain.</p> <p>Returns:</p> Type Description <code>QuamRootType</code> <p>The current QuamRoot object (self).</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_root(self: QuamRootType) -&gt; QuamRootType:\n    \"\"\"Get the QuamRoot object of this object, i.e. the object itself.\n\n    This QuamRoot function overrides the QuamBase function to return the object\n    itself, rather than following the parent chain.\n\n    Returns:\n        The current QuamRoot object (self).\n    \"\"\"\n    return self\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamRoot.get_serialiser","title":"<code>get_serialiser()</code>  <code>classmethod</code>","text":"<p>Get the serialiser for the QuamRoot class, which is the JSONSerialiser.</p> <p>This method can be overridden by subclasses to provide a custom serialiser.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@classmethod\ndef get_serialiser(cls) -&gt; AbstractSerialiser:\n    \"\"\"Get the serialiser for the QuamRoot class, which is the JSONSerialiser.\n\n    This method can be overridden by subclasses to provide a custom serialiser.\n    \"\"\"\n    return JSONSerialiser()\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamRoot.load","title":"<code>load(filepath_or_dict=None, validate_type=True, fix_attrs=True)</code>  <code>classmethod</code>","text":"<p>Load a QuamRoot object from a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_dict</code> <code>Optional[Union[str, Path, dict]]</code> <p>The path to the file/folder to load, or a dictionary. The dictionary would be the result from a call to <code>QuamRoot.save()</code> Can be omitted, in which case the serialiser will use the default state path, which is typically defined in the quam config file.</p> <code>None</code> <code>validate_type</code> <code>bool</code> <p>Whether to validate the type of all attributes while loading.</p> <code>True</code> <code>fix_attrs</code> <code>bool</code> <p>Whether attributes can be added to QuamBase objects that are not defined as dataclass fields.</p> <code>True</code> <p>Returns:</p> Type Description <code>QuamRootType</code> <p>A QuamRoot object instantiated from the file/folder/dict.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@classmethod\ndef load(\n    cls: type[QuamRootType],\n    filepath_or_dict: Optional[Union[str, Path, dict]] = None,\n    validate_type: bool = True,\n    fix_attrs: bool = True,\n) -&gt; QuamRootType:\n    \"\"\"Load a QuamRoot object from a file.\n\n    Args:\n        filepath_or_dict: The path to the file/folder to load, or a dictionary.\n            The dictionary would be the result from a call to `QuamRoot.save()`\n            Can be omitted, in which case the serialiser will use the default state\n            path, which is typically defined in the quam config file.\n        validate_type: Whether to validate the type of all attributes while loading.\n        fix_attrs: Whether attributes can be added to QuamBase objects that are not\n            defined as dataclass fields.\n\n    Returns:\n        A QuamRoot object instantiated from the file/folder/dict.\n    \"\"\"\n    if isinstance(filepath_or_dict, dict):\n        contents = filepath_or_dict\n    else:\n        serialiser = cls.get_serialiser()\n        contents, _ = serialiser.load(filepath_or_dict)\n\n    return instantiate_quam_class(\n        quam_class=cls,\n        contents=contents,\n        fix_attrs=fix_attrs,\n        validate_type=validate_type,\n    )\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.QuamRoot.save","title":"<code>save(path=None, content_mapping=None, include_defaults=None, ignore=None)</code>","text":"<p>Save the entire QuamRoot object to a file. This includes nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Union[Path, str]]</code> <p>The path to save the file to. If None, the path will be extracted from the <code>state_path</code> attribute of the serialiser, which could be set by the quam config file or environment variable.</p> <code>None</code> <code>content_mapping</code> <code>Optional[Dict[str, str]]</code> <p>Optional mapping of component names to filenames. This can be used to save different parts of the QuamRoot object to different files.</p> <code>None</code> <code>include_defaults</code> <code>Optional[bool]</code> <p>Whether to include attributes that have the default value.</p> <code>None</code> <code>ignore</code> <code>Optional[Sequence[str]]</code> <p>A list of components to ignore.</p> <code>None</code> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def save(\n    self,\n    path: Optional[Union[Path, str]] = None,\n    content_mapping: Optional[Dict[str, str]] = None,\n    include_defaults: Optional[bool] = None,\n    ignore: Optional[Sequence[str]] = None,\n):\n    \"\"\"Save the entire QuamRoot object to a file. This includes nested objects.\n\n    Args:\n        path: The path to save the file to. If None, the path will be extracted from\n            the `state_path` attribute of the serialiser, which could be set by the\n            quam config file or environment variable.\n        content_mapping: Optional mapping of component names to filenames. This can\n            be used to save different parts of the QuamRoot object to different\n            files.\n        include_defaults: Whether to include attributes that have the default\n            value.\n        ignore: A list of components to ignore.\n    \"\"\"\n    self.serialiser.save(\n        quam_obj=self,\n        path=path,\n        content_mapping=content_mapping,\n        include_defaults=include_defaults,\n        ignore=ignore,\n    )\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.convert_dict_and_list","title":"<code>convert_dict_and_list(value, cls_or_obj=None, attr=None)</code>","text":"<p>Convert a dict or list to a QuamDict or QuamList if possible.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def convert_dict_and_list(value, cls_or_obj=None, attr=None):\n    \"\"\"Convert a dict or list to a QuamDict or QuamList if possible.\"\"\"\n    if isinstance(value, dict):\n        value_annotation = _get_value_annotation(cls_or_obj=cls_or_obj, attr=attr)\n        return QuamDict(value, value_annotation=value_annotation)\n    elif type(value) == list:\n        value_annotation = _get_value_annotation(cls_or_obj=cls_or_obj, attr=attr)\n        return QuamList(value, value_annotation=value_annotation)\n    else:\n        return value\n</code></pre>"},{"location":"API_references/core/quam_classes/#quam.core.quam_classes.sort_quam_components","title":"<code>sort_quam_components(components, max_attempts=5)</code>","text":"<p>Sort QuamComponent objects based on their config_settings.</p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>List['QuamComponent']</code> <p>A list of QuamComponent objects.</p> required <code>max_attempts</code> <p>The maximum number of attempts to sort the components. If the components aren't yet properly sorted after all these attempts, a warning is raised and the components are returned in the final attempted ordering.</p> <code>5</code> <p>Returns:</p> Type Description <code>List['QuamComponent']</code> <p>A sorted list of QuamComponent objects.</p> Note <p>This function is used by <code>QuamRoot.generate_config</code> to determine the order in which to add the components to the QUA config. This sorting isn't guaranteed to be successful.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def sort_quam_components(\n    components: List[\"QuamComponent\"], max_attempts=5\n) -&gt; List[\"QuamComponent\"]:\n    \"\"\"Sort QuamComponent objects based on their config_settings.\n\n    Args:\n        components: A list of QuamComponent objects.\n        max_attempts: The maximum number of attempts to sort the components.\n            If the components aren't yet properly sorted after all these attempts,\n            a warning is raised and the components are returned in the final attempted\n            ordering.\n\n    Returns:\n        A sorted list of QuamComponent objects.\n\n    Note:\n        This function is used by\n        [`QuamRoot.generate_config`][quam.core.quam_classes.QuamRoot.generate_config]\n        to determine the order in which to add the components to the QUA config.\n        This sorting isn't guaranteed to be successful.\n    \"\"\"\n    sorted_components = components.copy()\n    for _ in range(max_attempts):\n        adjustments_made = False\n\n        for component in components:\n            if component.config_settings is None:\n                continue\n\n            component_idx = sorted_components.index(component)\n\n            if \"after\" in component.config_settings:\n                for after_component in component.config_settings[\"after\"]:\n                    after_component_idx = sorted_components.index(after_component)\n                    if after_component_idx &lt; component_idx:\n                        continue\n                    sorted_components.remove(after_component)\n                    sorted_components.insert(component_idx, after_component)\n                    adjustments_made = True\n\n            if \"before\" in component.config_settings:\n                for before_component in component.config_settings[\"before\"]:\n                    before_component_idx = sorted_components.index(before_component)\n                    if before_component_idx &gt; component_idx:\n                        continue\n                    sorted_components.remove(before_component)\n                    sorted_components.insert(component_idx + 1, before_component)\n                    adjustments_made = True\n\n        if not adjustments_made:\n            break\n    else:\n        warnings.warn(\n            \"Unable to sort QuamComponents based on config_settings. \"\n            \"This may cause issues when generating the QUA config.\"\n        )\n\n    return sorted_components\n</code></pre>"},{"location":"API_references/core/quam_classes_API/","title":"QUAM Classes API","text":""},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase","title":"<code>QuamBase</code>","text":"<p>               Bases: <code>ReferenceClass</code></p> <p>Base class for any QUAM component class.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <p>The parent of this object. This is automatically set when adding this object to another QuamBase object.</p> required <code>config_settings</code> <p>A dictionary of configuration settings for this object. This is used by <code>QuamRoot.generate_config</code> to determine the order in which to add the components to the QUA config. Keys are \"before\" and \"after\", and the values are a list of QuamComponents</p> required Note <p>This class should not be used directly, but should generally be subclassed. The subclasses should be dataclasses.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>class QuamBase(ReferenceClass):\n    \"\"\"Base class for any QUAM component class.\n\n    args:\n        parent: The parent of this object. This is automatically set when adding\n            this object to another QuamBase object.\n        config_settings: A dictionary of configuration settings for this object.\n            This is used by [`QuamRoot.generate_config`][quam.core.quam_classes.QuamRoot.generate_config]\n            to determine the order in which to add the components to the QUA config.\n            Keys are \"before\" and \"after\", and the values are a list of QuamComponents\n\n    Note:\n        This class should not be used directly, but should generally be subclassed.\n        The subclasses should be dataclasses.\n    \"\"\"\n\n    parent: ClassVar[\"QuamBase\"] = ParentDescriptor()\n    _last_instantiated_root: ClassVar[Optional[\"QuamRoot\"]] = None\n    config_settings: ClassVar[Dict[str, Any]] = None\n    _MAX_REFERENCE_DEPTH: ClassVar[int] = 10\n\n    def __init__(self):\n        # This prohibits instantiating without it being a dataclass\n        # This means that we have to subclass this class and make it a dataclass\n        if not is_dataclass(self):\n            if type(self) in [QuamBase, QuamComponent, QuamRoot]:\n                raise TypeError(\n                    f\"Cannot instantiate {self.__class__.__name__} directly. \"\n                    \"Please create a subclass and make it a dataclass.\"\n                )\n            else:\n                raise TypeError(\n                    f\"Cannot instantiate {self.__class__.__name__}. \"\n                    \"Please make it a dataclass.\"\n                )\n\n    def _get_attr_names(self) -&gt; List[str]:\n        \"\"\"Get names of all dataclass attributes of this object.\n\n        Returns:\n            List of attribute names.\n\n        Raises:\n            AssertionError if not a dataclass.\n        \"\"\"\n        assert is_dataclass(self)\n        return [data_field.name for data_field in fields(self)]\n\n    def get_root(self) -&gt; Optional[QuamRoot]:\n        \"\"\"Get the QuamRoot object of this object.\n\n        This function recursively searches the parent chain for a QuamRoot object.\n        If no QuamRoot object is found, it will return the last instantiated QuamRoot\n        if it exists, else None.\n\n        Returns:\n            The root of this object, or None if no root is found.\n        \"\"\"\n        if self.parent is not None:\n            return self.parent.get_root()\n\n        if self._last_instantiated_root is not None:\n            warnings.warn(\n                f\"This component is not part of any QuamRoot, using last \"\n                f\"instantiated QuamRoot. This is not recommended as it may lead to \"\n                f\"unexpected behaviour. Component: {self.__class__.__name__}\"\n            )\n            return self._last_instantiated_root\n        return None\n\n    def get_attr_name(self, attr_val: Any) -&gt; str:\n        \"\"\"Get the name of an attribute that matches the value.\n\n        Args:\n            attr_val: The value of the attribute.\n\n        Returns:\n            The name of the attribute.\n\n        Raises:\n            AttributeError if not found.\n        \"\"\"\n        for attr_name in self._get_attr_names():\n            if self.get_raw_value(attr_name) is attr_val:\n                return attr_name\n        else:\n            raise AttributeError(\n                \"Could not find name corresponding to attribute.\\n\"\n                f\"attribute: {attr_val}\\n\"\n                f\"obj: {self}\"\n            )\n\n    def _attr_val_is_default(self, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the value of an attribute is the default value.\n\n        Args:\n            attr: The name of the attribute.\n            val: The value of the attribute.\n\n        Returns:\n            True if the value is the default value, False otherwise.\n            False is also returned if the parent is not a dataclass\n        \"\"\"\n        if not is_dataclass(self):\n            return False\n\n        dataclass_fields = fields(self)\n        if not any(field.name == attr for field in dataclass_fields):\n            return False\n\n        field = next(field for field in dataclass_fields if field.name == attr)\n        if field.default is not MISSING:\n            return val == field.default\n        elif field.default_factory is not MISSING:\n            try:\n                default_val = field.default_factory()\n                return val == default_val\n            except TypeError:\n                return False\n\n        return False\n\n    @classmethod\n    def _val_matches_attr_annotation(cls, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the type of an attribute matches the annotation.\n\n        The attribute type must exactly match the annotation.\n        For dict and list, no additional type check of args is performed.\n        \"\"\"\n        annotated_attrs = get_dataclass_attr_annotations(cls)\n        if attr not in annotated_attrs[\"allowed\"]:\n            return False\n\n        required_type = annotated_attrs[\"allowed\"][attr]\n        if type_is_optional(required_type):\n            required_type = get_args(required_type)[0]\n\n        if required_type == dict or get_origin(required_type) == dict:\n            return isinstance(val, (dict, QuamDict))\n        elif required_type == list or get_origin(required_type) == list:\n            return isinstance(val, (list, QuamList))\n        return type(val) == required_type\n\n    def get_reference(\n        self,\n        attr: Optional[str] = None,\n        relative_path: Optional[str] = None,\n        follow_chain: bool = False,\n    ) -&gt; Optional[str]:\n        \"\"\"Get the reference path of this object or one of its attributes.\n\n        Args:\n            attr: The optional attribute to get the reference path for.\n                If None, the reference path of the object itself is returned.\n            relative_path: The optional relative path to join with the reference path.\n            follow_chain: If True and attr is a reference, follow the reference chain\n                to return the ultimate target reference. Default is False for backward\n                compatibility. Only applies when attr is specified.\n\n        Returns:\n            The reference path of this object or the specified attribute.\n\n        Raises:\n            ValueError: If both attr and relative_path are specified, or if follow_chain\n                is True but attr is not a reference.\n\n        Examples:\n            We assume a QuamRoot object with a component \"elem\".\n            - elem.get_reference() == \"#/elem\"\n            - elem.get_reference(attr=\"child\") == \"#/elem/child\"\n            - elem.get_reference(relative_path=\"#./child\") == \"#/elem/child\"\n            - elem.get_reference(relative_path=\"#../child\") == \"#/child\"\n            - elem.get_reference(relative_path=\"#./child/grandchild\") == \"#/elem/child/grandchild\"\n\n            With follow_chain=True (if attr contains a reference to another reference):\n            - elem.get_reference(attr=\"chain_ref\", follow_chain=True)  # returns ultimate target\n        \"\"\"\n\n        if attr is not None and relative_path is not None:\n            raise ValueError(\n                \"Cannot specify both attr and relative_path. \"\n                \"Please specify only one of them.\"\n            )\n\n        # Handle follow_chain before computing the reference path\n        if follow_chain and attr is not None:\n            raw_value = self.get_raw_value(attr)\n            if not string_reference.is_reference(raw_value):\n                raise ValueError(\n                    f\"Cannot follow reference chain for attr '{attr}': \"\n                    f\"value is not a reference (value={raw_value})\"\n                )\n            # Follow the reference chain to get the ultimate target\n            try:\n                target_obj, target_attr = self._follow_reference_chain(self, attr)\n                # Return the reference path to the ultimate target\n                return target_obj.get_reference(attr=target_attr)\n            except (AttributeError, ValueError, RecursionError) as e:\n                raise ValueError(\n                    f\"Failed to follow reference chain for attr '{attr}': {e}\"\n                ) from e\n\n        if self.parent is None:\n            raise AttributeError(\n                \"Unable to extract reference path for {self}: No parent defined\"\n            )\n\n        try:\n            base_reference = self.parent.get_reference()\n            if base_reference == \"#/\":\n                base_reference = \"#\"\n        except AttributeError:\n            raise AttributeError(\n                f\"Unable to extract reference path for {self}: Could not get \"\n                f\"reference path for parent {self.parent}\"\n            )\n\n        try:\n            attr_name = self.parent.get_attr_name(self)\n        except AttributeError:\n            raise AttributeError(\n                f\"Unable to extract reference path for {self}: Could not get \"\n                f\"attribute name from parent {self.parent}\"\n            )\n\n        reference = f\"{base_reference}/{attr_name}\"\n\n        if relative_path is not None:\n            if not string_reference.is_reference(relative_path):\n                raise ValueError(\n                    f\"Unable to extract reference path for {self}: \"\n                    f\"relative_path {relative_path} is not a reference\"\n                )\n\n            reference = string_reference.join_references(reference, relative_path)\n        elif attr is not None:\n            reference = f\"{reference}/{attr}\"\n\n        return reference\n\n    def get_attrs(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Get all attributes and corresponding values of this object.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default\n                value.\n\n        Returns:\n            A dictionary of attribute names and values.\n\n        \"\"\"\n        attr_names = self._get_attr_names()\n\n        skip_attrs = getattr(self, \"_skip_attrs\", [])\n        attr_names = [attr for attr in attr_names if attr not in skip_attrs]\n\n        # Apply skip_save metadata filter\n        if is_dataclass(self):\n            skip_save_attrs = [\n                field.name\n                for field in fields(self)\n                if field.metadata.get(\"skip_save\", False)\n            ]\n            attr_names = [attr for attr in attr_names if attr not in skip_save_attrs]\n\n        if not follow_references:\n            attrs = {attr: self.get_raw_value(attr) for attr in attr_names}\n        else:\n            attrs = {attr: getattr(self, attr) for attr in attr_names}\n\n        if not include_defaults:\n            attrs = {\n                attr: val\n                for attr, val in attrs.items()\n                if not self._attr_val_is_default(attr, val)\n            }\n        return attrs\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Convert this object to a dictionary.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default value.\n\n        Returns:\n            A dictionary representation of this object.\n            Any QuamBase objects will be recursively converted to dictionaries.\n\n        Note:\n            If the value of an attribute does not match the annotation, the\n            `\"__class__\"` key will be added to the dictionary. This is to ensure\n            that the object can be reconstructed when loading from a file.\n        \"\"\"\n        attrs = self.get_attrs(\n            follow_references=follow_references, include_defaults=include_defaults\n        )\n        quam_dict = {}\n        for attr, val in attrs.items():\n            if isinstance(val, QuamBase):\n                quam_dict[attr] = val.to_dict(\n                    follow_references=follow_references,\n                    include_defaults=include_defaults,\n                )\n            else:\n                quam_dict[attr] = val\n\n        # Add __class__ to specify the class of the object\n        quam_dict[\"__class__\"] = get_full_class_path(self)\n\n        return quam_dict\n\n    def iterate_components(\n        self, skip_elems: Optional[Sequence[\"QuamBase\"]] = None\n    ) -&gt; Generator[\"QuamBase\", None, None]:\n        \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n        Args:\n            skip_elems: A sequence of QuamBase objects to skip.\n                This is used to prevent infinite loops when iterating over nested\n                objects.\n\n        Returns:\n            A generator of QuamBase objects.\n        \"\"\"\n        if skip_elems is None:\n            skip_elems = []\n\n        # We don't use \"self in skip_elems\" because we want to check for identity,\n        # not equality. The reason is that you would otherwise have to instantiate\n        # dataclasses using @dataclass(eq=False)\n        in_skip_elems = any(self is elem for elem in skip_elems)\n        if isinstance(self, QuamComponent) and not in_skip_elems:\n            skip_elems.append(self)\n            yield self\n\n        attrs = self.get_attrs(follow_references=False, include_defaults=True)\n\n        for attr_val in attrs.values():\n            if any(attr_val is elem for elem in skip_elems):\n                continue\n\n            if isinstance(attr_val, QuamBase):\n                yield from attr_val.iterate_components(skip_elems=skip_elems)\n\n    def _is_reference(self, attr: str) -&gt; bool:\n        \"\"\"Check whether an attribute is a reference.\n\n        Args:\n            attr: The name of the attribute.\n\n        Returns:\n            True if the attribute is a reference, False otherwise.\n\n        Note:\n            This function is used from the ReferenceClass class.\n        \"\"\"\n        return string_reference.is_reference(attr)\n\n    def _get_referenced_value(self, reference: str) -&gt; Any:\n        \"\"\"Get the value of an attribute by reference\n\n        Args:\n            reference: The reference to the attribute.\n\n        Returns:\n            The value of the attribute, or the reference if it is not a reference\n\n        Note:\n            This function is used from the ReferenceClass class.\n        \"\"\"\n        if not string_reference.is_reference(reference):\n            return reference\n\n        root = self.get_root()\n        if string_reference.is_absolute_reference(reference) and root is None:\n            warnings.warn(\n                f\"No QuamRoot initialized, cannot retrieve absolute reference \"\n                f\"{reference} from {self.__class__.__name__}\"\n            )\n            return reference\n\n        try:\n            return string_reference.get_referenced_value(self, reference, root=root)\n        except InvalidReferenceError as e:\n            try:\n                ref = f\"{self.__class__.__name__}: {self.get_reference()}\"\n            except Exception:\n                ref = self.__class__.__name__\n\n            # Construct message using the chained exception's message\n            base_error_msg = str(e)\n            component_ref_str = f\"component {ref}\"\n            msg = (\n                f'Could not get reference \"{reference}\" from {component_ref_str}. '\n                f\"Error: {base_error_msg}\"\n            )\n\n            try:\n                cfg = get_quam_config()\n                raise_error_missing_reference = cfg.raise_error_missing_reference\n            except FileNotFoundError:\n                # Default behavior if config file not found\n                raise_error_missing_reference = False\n\n            if not raise_error_missing_reference:\n                warnings.warn(msg)\n            else:\n                # Re-raise with context, keeping the original exception chain\n                raise InvalidReferenceError(msg) from e\n            return reference\n\n    def print_summary(self, indent: int = 0):\n        \"\"\"Print a summary of the QuamBase object.\n\n        Args:\n            indent: The number of spaces to indent the summary.\n        \"\"\"\n        if self.get_root() is self:\n            full_name = \"QUAM:\"\n        elif self.parent is None:\n            full_name = f\"{self.__class__.__name__} (parent unknown):\"\n        else:\n            try:\n                attr_name = self.parent.get_attr_name(self)\n                full_name = f\"{attr_name}: {self.__class__.__name__}\"\n            except AttributeError:\n                full_name = f\"{self.__class__.__name__}:\"\n\n        if not self.get_attrs():\n            print(\" \" * indent + f\"{full_name} Empty\")\n            return\n\n        print(\" \" * indent + f\"{full_name}\")\n        for attr, val in self.get_attrs().items():\n            if isinstance(val, str):\n                val = f'\"{val}\"'\n            if isinstance(val, QuamBase):\n                val.print_summary(indent=indent + 2)\n            else:\n                print(\" \" * (indent + 2) + f\"{attr}: {val}\")\n\n    def _follow_reference_chain(\n        self, obj: \"QuamBase\", attr: str, max_depth: Optional[int] = None\n    ) -&gt; tuple[\"QuamBase\", str]:\n        \"\"\"Recursively follow a reference chain to find the ultimate target.\n\n        This method follows reference strings through nested references until\n        reaching a non-reference value. It is used internally by\n        set_at_reference() and get_reference() to handle chained references.\n\n        Args:\n            obj: The QuamBase object containing the attribute.\n            attr: The attribute name to follow (may be a list index like \"0\").\n            max_depth: Maximum recursion depth to prevent infinite loops\n                (default: QuamBase._MAX_REFERENCE_DEPTH).\n\n        Returns:\n            A tuple of (target_object, final_attr_name) where:\n            - target_object: The QuamBase object containing the ultimate value\n            - final_attr_name: The final attribute name (after following all chains)\n\n        Raises:\n            AttributeError: If a reference in the chain cannot be resolved.\n            RecursionError: If max_depth is exceeded (indicates circular reference).\n        \"\"\"\n        # Normalize attr to string for consistent handling\n        attr = str(attr)\n\n        if max_depth is None:\n            max_depth = self._MAX_REFERENCE_DEPTH\n        if max_depth &lt;= 0:\n            raise RecursionError(\n                f\"Reference chain exceeded maximum depth of {self._MAX_REFERENCE_DEPTH}. \"\n                f\"Possible circular reference starting from {obj.get_attr_path()}\"\n            )\n\n        # Handle list/dict index access specially\n        if attr.isdigit() and isinstance(obj, (list, UserList, QuamList)):\n            # For list indices, get the raw element directly from the list\n            index = int(attr)\n            if isinstance(obj, QuamList):\n                raw_value = obj.data[index]\n            else:\n                raw_value = obj[index]\n        else:\n            raw_value = obj.get_raw_value(attr)\n\n        # Base case: value is not a reference\n        if not string_reference.is_reference(raw_value):\n            return obj, attr\n\n        # Recursive case: follow the reference chain\n        parent_reference, parent_attr = string_reference.split_reference(raw_value)\n        if not parent_attr:\n            raise ValueError(\n                f\"Invalid reference {raw_value}: must have an attribute part\"\n            )\n\n        parent_obj = obj._get_referenced_value(parent_reference)\n        if not isinstance(parent_obj, QuamBase):\n            # This can happen when:\n            # 1. Broken reference: _get_referenced_value returns the reference string\n            # 2. Reference to a non-QuamBase value (e.g., primitive)\n            # Raise AttributeError to match the expected contract for set_at_reference\n            raise AttributeError(\n                f\"Cannot follow reference chain: '{parent_reference}' resolved to \"\n                f\"{type(parent_obj).__name__}, not a QuamBase object\"\n            )\n\n        # Recursively follow the chain\n        return self._follow_reference_chain(parent_obj, parent_attr, max_depth - 1)\n\n    def set_at_reference(\n        self, attr: str, value: Any, allow_non_reference: bool = True\n    ):\n        \"\"\"Follow the reference of an attribute and set the value at the reference.\n\n        This method follows reference chains recursively. If an attribute contains\n        a reference to another reference, both references are preserved while the\n        ultimate target value is updated.\n\n        Args:\n            attr: The attribute to set the value at the reference of.\n            value: The value to set.\n            allow_non_reference: Whether to allow the attribute to be a non-reference.\n                If True (default), non-reference attributes are allowed. If False,\n                the attribute must be a reference or an error is raised.\n\n        Raises:\n            ValueError: If the attribute is not a reference and `allow_non_reference` is\n                False.\n            ValueError: If the reference is invalid, e.g. \"#./\" since it has no\n                attribute.\n        \"\"\"\n        raw_value = self.get_raw_value(attr)\n        if not string_reference.is_reference(raw_value):\n            if not allow_non_reference:\n                raise ValueError(\n                    f\"Cannot set at reference because attr '{attr}' is not a reference. \"\n                    f\"'{attr}' = {raw_value}\"\n                )\n            target_obj, target_attr = self, attr\n        else:\n            # Follow the reference chain to get the ultimate target\n            target_obj, target_attr = self._follow_reference_chain(self, attr)\n\n        # Use __setitem__ for dict/list types, otherwise use setattr\n        if isinstance(target_obj, (dict, list, UserDict, UserList, QuamDict, QuamList)):\n            # Convert string index to int for list types\n            if (\n                isinstance(target_obj, (list, UserList, QuamList))\n                and target_attr.isdigit()\n            ):\n                target_attr = int(target_attr)\n            target_obj[target_attr] = value\n        else:\n            setattr(target_obj, target_attr, value)\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.get_attr_name","title":"<code>get_attr_name(attr_val)</code>","text":"<p>Get the name of an attribute that matches the value.</p> <p>Parameters:</p> Name Type Description Default <code>attr_val</code> <code>Any</code> <p>The value of the attribute.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the attribute.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_attr_name(self, attr_val: Any) -&gt; str:\n    \"\"\"Get the name of an attribute that matches the value.\n\n    Args:\n        attr_val: The value of the attribute.\n\n    Returns:\n        The name of the attribute.\n\n    Raises:\n        AttributeError if not found.\n    \"\"\"\n    for attr_name in self._get_attr_names():\n        if self.get_raw_value(attr_name) is attr_val:\n            return attr_name\n    else:\n        raise AttributeError(\n            \"Could not find name corresponding to attribute.\\n\"\n            f\"attribute: {attr_val}\\n\"\n            f\"obj: {self}\"\n        )\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.get_attrs","title":"<code>get_attrs(follow_references=False, include_defaults=True)</code>","text":"<p>Get all attributes and corresponding values of this object.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary of attribute names and values.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_attrs(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; Dict[str, Any]:\n    \"\"\"Get all attributes and corresponding values of this object.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default\n            value.\n\n    Returns:\n        A dictionary of attribute names and values.\n\n    \"\"\"\n    attr_names = self._get_attr_names()\n\n    skip_attrs = getattr(self, \"_skip_attrs\", [])\n    attr_names = [attr for attr in attr_names if attr not in skip_attrs]\n\n    # Apply skip_save metadata filter\n    if is_dataclass(self):\n        skip_save_attrs = [\n            field.name\n            for field in fields(self)\n            if field.metadata.get(\"skip_save\", False)\n        ]\n        attr_names = [attr for attr in attr_names if attr not in skip_save_attrs]\n\n    if not follow_references:\n        attrs = {attr: self.get_raw_value(attr) for attr in attr_names}\n    else:\n        attrs = {attr: getattr(self, attr) for attr in attr_names}\n\n    if not include_defaults:\n        attrs = {\n            attr: val\n            for attr, val in attrs.items()\n            if not self._attr_val_is_default(attr, val)\n        }\n    return attrs\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.get_reference","title":"<code>get_reference(attr=None, relative_path=None, follow_chain=False)</code>","text":"<p>Get the reference path of this object or one of its attributes.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>Optional[str]</code> <p>The optional attribute to get the reference path for. If None, the reference path of the object itself is returned.</p> <code>None</code> <code>relative_path</code> <code>Optional[str]</code> <p>The optional relative path to join with the reference path.</p> <code>None</code> <code>follow_chain</code> <code>bool</code> <p>If True and attr is a reference, follow the reference chain to return the ultimate target reference. Default is False for backward compatibility. Only applies when attr is specified.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The reference path of this object or the specified attribute.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both attr and relative_path are specified, or if follow_chain is True but attr is not a reference.</p> <p>Examples:</p> <p>We assume a QuamRoot object with a component \"elem\". - elem.get_reference() == \"#/elem\" - elem.get_reference(attr=\"child\") == \"#/elem/child\" - elem.get_reference(relative_path=\"#./child\") == \"#/elem/child\" - elem.get_reference(relative_path=\"#../child\") == \"#/child\" - elem.get_reference(relative_path=\"#./child/grandchild\") == \"#/elem/child/grandchild\"</p> <p>With follow_chain=True (if attr contains a reference to another reference): - elem.get_reference(attr=\"chain_ref\", follow_chain=True)  # returns ultimate target</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_reference(\n    self,\n    attr: Optional[str] = None,\n    relative_path: Optional[str] = None,\n    follow_chain: bool = False,\n) -&gt; Optional[str]:\n    \"\"\"Get the reference path of this object or one of its attributes.\n\n    Args:\n        attr: The optional attribute to get the reference path for.\n            If None, the reference path of the object itself is returned.\n        relative_path: The optional relative path to join with the reference path.\n        follow_chain: If True and attr is a reference, follow the reference chain\n            to return the ultimate target reference. Default is False for backward\n            compatibility. Only applies when attr is specified.\n\n    Returns:\n        The reference path of this object or the specified attribute.\n\n    Raises:\n        ValueError: If both attr and relative_path are specified, or if follow_chain\n            is True but attr is not a reference.\n\n    Examples:\n        We assume a QuamRoot object with a component \"elem\".\n        - elem.get_reference() == \"#/elem\"\n        - elem.get_reference(attr=\"child\") == \"#/elem/child\"\n        - elem.get_reference(relative_path=\"#./child\") == \"#/elem/child\"\n        - elem.get_reference(relative_path=\"#../child\") == \"#/child\"\n        - elem.get_reference(relative_path=\"#./child/grandchild\") == \"#/elem/child/grandchild\"\n\n        With follow_chain=True (if attr contains a reference to another reference):\n        - elem.get_reference(attr=\"chain_ref\", follow_chain=True)  # returns ultimate target\n    \"\"\"\n\n    if attr is not None and relative_path is not None:\n        raise ValueError(\n            \"Cannot specify both attr and relative_path. \"\n            \"Please specify only one of them.\"\n        )\n\n    # Handle follow_chain before computing the reference path\n    if follow_chain and attr is not None:\n        raw_value = self.get_raw_value(attr)\n        if not string_reference.is_reference(raw_value):\n            raise ValueError(\n                f\"Cannot follow reference chain for attr '{attr}': \"\n                f\"value is not a reference (value={raw_value})\"\n            )\n        # Follow the reference chain to get the ultimate target\n        try:\n            target_obj, target_attr = self._follow_reference_chain(self, attr)\n            # Return the reference path to the ultimate target\n            return target_obj.get_reference(attr=target_attr)\n        except (AttributeError, ValueError, RecursionError) as e:\n            raise ValueError(\n                f\"Failed to follow reference chain for attr '{attr}': {e}\"\n            ) from e\n\n    if self.parent is None:\n        raise AttributeError(\n            \"Unable to extract reference path for {self}: No parent defined\"\n        )\n\n    try:\n        base_reference = self.parent.get_reference()\n        if base_reference == \"#/\":\n            base_reference = \"#\"\n    except AttributeError:\n        raise AttributeError(\n            f\"Unable to extract reference path for {self}: Could not get \"\n            f\"reference path for parent {self.parent}\"\n        )\n\n    try:\n        attr_name = self.parent.get_attr_name(self)\n    except AttributeError:\n        raise AttributeError(\n            f\"Unable to extract reference path for {self}: Could not get \"\n            f\"attribute name from parent {self.parent}\"\n        )\n\n    reference = f\"{base_reference}/{attr_name}\"\n\n    if relative_path is not None:\n        if not string_reference.is_reference(relative_path):\n            raise ValueError(\n                f\"Unable to extract reference path for {self}: \"\n                f\"relative_path {relative_path} is not a reference\"\n            )\n\n        reference = string_reference.join_references(reference, relative_path)\n    elif attr is not None:\n        reference = f\"{reference}/{attr}\"\n\n    return reference\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.get_root","title":"<code>get_root()</code>","text":"<p>Get the QuamRoot object of this object.</p> <p>This function recursively searches the parent chain for a QuamRoot object. If no QuamRoot object is found, it will return the last instantiated QuamRoot if it exists, else None.</p> <p>Returns:</p> Type Description <code>Optional[QuamRoot]</code> <p>The root of this object, or None if no root is found.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_root(self) -&gt; Optional[QuamRoot]:\n    \"\"\"Get the QuamRoot object of this object.\n\n    This function recursively searches the parent chain for a QuamRoot object.\n    If no QuamRoot object is found, it will return the last instantiated QuamRoot\n    if it exists, else None.\n\n    Returns:\n        The root of this object, or None if no root is found.\n    \"\"\"\n    if self.parent is not None:\n        return self.parent.get_root()\n\n    if self._last_instantiated_root is not None:\n        warnings.warn(\n            f\"This component is not part of any QuamRoot, using last \"\n            f\"instantiated QuamRoot. This is not recommended as it may lead to \"\n            f\"unexpected behaviour. Component: {self.__class__.__name__}\"\n        )\n        return self._last_instantiated_root\n    return None\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.iterate_components","title":"<code>iterate_components(skip_elems=None)</code>","text":"<p>Iterate over all QuamBase objects in this object, including nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>skip_elems</code> <code>Optional[Sequence['QuamBase']]</code> <p>A sequence of QuamBase objects to skip. This is used to prevent infinite loops when iterating over nested objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A generator of QuamBase objects.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def iterate_components(\n    self, skip_elems: Optional[Sequence[\"QuamBase\"]] = None\n) -&gt; Generator[\"QuamBase\", None, None]:\n    \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n    Args:\n        skip_elems: A sequence of QuamBase objects to skip.\n            This is used to prevent infinite loops when iterating over nested\n            objects.\n\n    Returns:\n        A generator of QuamBase objects.\n    \"\"\"\n    if skip_elems is None:\n        skip_elems = []\n\n    # We don't use \"self in skip_elems\" because we want to check for identity,\n    # not equality. The reason is that you would otherwise have to instantiate\n    # dataclasses using @dataclass(eq=False)\n    in_skip_elems = any(self is elem for elem in skip_elems)\n    if isinstance(self, QuamComponent) and not in_skip_elems:\n        skip_elems.append(self)\n        yield self\n\n    attrs = self.get_attrs(follow_references=False, include_defaults=True)\n\n    for attr_val in attrs.values():\n        if any(attr_val is elem for elem in skip_elems):\n            continue\n\n        if isinstance(attr_val, QuamBase):\n            yield from attr_val.iterate_components(skip_elems=skip_elems)\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.print_summary","title":"<code>print_summary(indent=0)</code>","text":"<p>Print a summary of the QuamBase object.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The number of spaces to indent the summary.</p> <code>0</code> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def print_summary(self, indent: int = 0):\n    \"\"\"Print a summary of the QuamBase object.\n\n    Args:\n        indent: The number of spaces to indent the summary.\n    \"\"\"\n    if self.get_root() is self:\n        full_name = \"QUAM:\"\n    elif self.parent is None:\n        full_name = f\"{self.__class__.__name__} (parent unknown):\"\n    else:\n        try:\n            attr_name = self.parent.get_attr_name(self)\n            full_name = f\"{attr_name}: {self.__class__.__name__}\"\n        except AttributeError:\n            full_name = f\"{self.__class__.__name__}:\"\n\n    if not self.get_attrs():\n        print(\" \" * indent + f\"{full_name} Empty\")\n        return\n\n    print(\" \" * indent + f\"{full_name}\")\n    for attr, val in self.get_attrs().items():\n        if isinstance(val, str):\n            val = f'\"{val}\"'\n        if isinstance(val, QuamBase):\n            val.print_summary(indent=indent + 2)\n        else:\n            print(\" \" * (indent + 2) + f\"{attr}: {val}\")\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.set_at_reference","title":"<code>set_at_reference(attr, value, allow_non_reference=True)</code>","text":"<p>Follow the reference of an attribute and set the value at the reference.</p> <p>This method follows reference chains recursively. If an attribute contains a reference to another reference, both references are preserved while the ultimate target value is updated.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The attribute to set the value at the reference of.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required <code>allow_non_reference</code> <code>bool</code> <p>Whether to allow the attribute to be a non-reference. If True (default), non-reference attributes are allowed. If False, the attribute must be a reference or an error is raised.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the attribute is not a reference and <code>allow_non_reference</code> is False.</p> <code>ValueError</code> <p>If the reference is invalid, e.g. \"#./\" since it has no attribute.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def set_at_reference(\n    self, attr: str, value: Any, allow_non_reference: bool = True\n):\n    \"\"\"Follow the reference of an attribute and set the value at the reference.\n\n    This method follows reference chains recursively. If an attribute contains\n    a reference to another reference, both references are preserved while the\n    ultimate target value is updated.\n\n    Args:\n        attr: The attribute to set the value at the reference of.\n        value: The value to set.\n        allow_non_reference: Whether to allow the attribute to be a non-reference.\n            If True (default), non-reference attributes are allowed. If False,\n            the attribute must be a reference or an error is raised.\n\n    Raises:\n        ValueError: If the attribute is not a reference and `allow_non_reference` is\n            False.\n        ValueError: If the reference is invalid, e.g. \"#./\" since it has no\n            attribute.\n    \"\"\"\n    raw_value = self.get_raw_value(attr)\n    if not string_reference.is_reference(raw_value):\n        if not allow_non_reference:\n            raise ValueError(\n                f\"Cannot set at reference because attr '{attr}' is not a reference. \"\n                f\"'{attr}' = {raw_value}\"\n            )\n        target_obj, target_attr = self, attr\n    else:\n        # Follow the reference chain to get the ultimate target\n        target_obj, target_attr = self._follow_reference_chain(self, attr)\n\n    # Use __setitem__ for dict/list types, otherwise use setattr\n    if isinstance(target_obj, (dict, list, UserDict, UserList, QuamDict, QuamList)):\n        # Convert string index to int for list types\n        if (\n            isinstance(target_obj, (list, UserList, QuamList))\n            and target_attr.isdigit()\n        ):\n            target_attr = int(target_attr)\n        target_obj[target_attr] = value\n    else:\n        setattr(target_obj, target_attr, value)\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamBase.to_dict","title":"<code>to_dict(follow_references=False, include_defaults=True)</code>","text":"<p>Convert this object to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary representation of this object.</p> <code>Dict[str, Any]</code> <p>Any QuamBase objects will be recursively converted to dictionaries.</p> Note <p>If the value of an attribute does not match the annotation, the <code>\"__class__\"</code> key will be added to the dictionary. This is to ensure that the object can be reconstructed when loading from a file.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def to_dict(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; Dict[str, Any]:\n    \"\"\"Convert this object to a dictionary.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default value.\n\n    Returns:\n        A dictionary representation of this object.\n        Any QuamBase objects will be recursively converted to dictionaries.\n\n    Note:\n        If the value of an attribute does not match the annotation, the\n        `\"__class__\"` key will be added to the dictionary. This is to ensure\n        that the object can be reconstructed when loading from a file.\n    \"\"\"\n    attrs = self.get_attrs(\n        follow_references=follow_references, include_defaults=include_defaults\n    )\n    quam_dict = {}\n    for attr, val in attrs.items():\n        if isinstance(val, QuamBase):\n            quam_dict[attr] = val.to_dict(\n                follow_references=follow_references,\n                include_defaults=include_defaults,\n            )\n        else:\n            quam_dict[attr] = val\n\n    # Add __class__ to specify the class of the object\n    quam_dict[\"__class__\"] = get_full_class_path(self)\n\n    return quam_dict\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamRoot","title":"<code>QuamRoot</code>","text":"<p>               Bases: <code>QuamBase</code></p> <p>Base class for the root of a QUAM object.</p> <p>This class should be subclassed and made a dataclass.</p> Note <p>This class should not be used directly, but should generally be subclassed and made a dataclass. The dataclass fields should correspond to the QUAM root structure.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>class QuamRoot(QuamBase):\n    \"\"\"Base class for the root of a QUAM object.\n\n    This class should be subclassed and made a dataclass.\n\n    Note:\n        This class should not be used directly, but should generally be subclassed and\n        made a dataclass. The dataclass fields should correspond to the QUAM root\n        structure.\n    \"\"\"\n\n    def __post_init__(self):\n        QuamBase._last_instantiated_root = self\n        self.serialiser = self.get_serialiser()\n        super().__post_init__()\n\n    def __setattr__(self, name, value):\n        converted_val = convert_dict_and_list(value, cls_or_obj=self, attr=name)\n        super().__setattr__(name, converted_val)\n\n        if isinstance(converted_val, QuamBase) and name != \"parent\":\n            converted_val.parent = self\n\n    @classmethod\n    def get_serialiser(cls) -&gt; AbstractSerialiser:\n        \"\"\"Get the serialiser for the QuamRoot class, which is the JSONSerialiser.\n\n        This method can be overridden by subclasses to provide a custom serialiser.\n        \"\"\"\n        return JSONSerialiser()\n\n    def get_reference(\n        self, attr: Optional[str] = None, relative_path: Optional[str] = None\n    ) -&gt; Optional[str]:\n        if attr is not None:\n            return f\"#/{attr}\"\n\n        reference = \"#/\"\n        if relative_path is not None:\n            reference = string_reference.join_references(reference, relative_path)\n        return reference\n\n    def get_root(self: QuamRootType) -&gt; QuamRootType:\n        \"\"\"Get the QuamRoot object of this object, i.e. the object itself.\n\n        This QuamRoot function overrides the QuamBase function to return the object\n        itself, rather than following the parent chain.\n\n        Returns:\n            The current QuamRoot object (self).\n        \"\"\"\n        return self\n\n    def save(\n        self,\n        path: Optional[Union[Path, str]] = None,\n        content_mapping: Optional[Dict[str, str]] = None,\n        include_defaults: Optional[bool] = None,\n        ignore: Optional[Sequence[str]] = None,\n    ):\n        \"\"\"Save the entire QuamRoot object to a file. This includes nested objects.\n\n        Args:\n            path: The path to save the file to. If None, the path will be extracted from\n                the `state_path` attribute of the serialiser, which could be set by the\n                quam config file or environment variable.\n            content_mapping: Optional mapping of component names to filenames. This can\n                be used to save different parts of the QuamRoot object to different\n                files.\n            include_defaults: Whether to include attributes that have the default\n                value.\n            ignore: A list of components to ignore.\n        \"\"\"\n        self.serialiser.save(\n            quam_obj=self,\n            path=path,\n            content_mapping=content_mapping,\n            include_defaults=include_defaults,\n            ignore=ignore,\n        )\n\n    @classmethod\n    def load(\n        cls: type[QuamRootType],\n        filepath_or_dict: Optional[Union[str, Path, dict]] = None,\n        validate_type: bool = True,\n        fix_attrs: bool = True,\n    ) -&gt; QuamRootType:\n        \"\"\"Load a QuamRoot object from a file.\n\n        Args:\n            filepath_or_dict: The path to the file/folder to load, or a dictionary.\n                The dictionary would be the result from a call to `QuamRoot.save()`\n                Can be omitted, in which case the serialiser will use the default state\n                path, which is typically defined in the quam config file.\n            validate_type: Whether to validate the type of all attributes while loading.\n            fix_attrs: Whether attributes can be added to QuamBase objects that are not\n                defined as dataclass fields.\n\n        Returns:\n            A QuamRoot object instantiated from the file/folder/dict.\n        \"\"\"\n        if isinstance(filepath_or_dict, dict):\n            contents = filepath_or_dict\n        else:\n            serialiser = cls.get_serialiser()\n            contents, _ = serialiser.load(filepath_or_dict)\n\n        return instantiate_quam_class(\n            quam_class=cls,\n            contents=contents,\n            fix_attrs=fix_attrs,\n            validate_type=validate_type,\n        )\n\n    def generate_config(self) -&gt; DictQuaConfig:\n        \"\"\"Generate the QUA configuration from the QUAM object.\n\n        Returns:\n            A dictionary with the QUA configuration.\n\n        Note:\n            This function collects all the nested QuamComponent objects and calls\n            `QuamComponent.apply_to_config` on them.\n        \"\"\"\n        qua_config = deepcopy(qua_config_template)\n\n        quam_components = list(self.iterate_components())\n        sorted_components = sort_quam_components(quam_components)\n\n        for quam_component in sorted_components:\n            quam_component.apply_to_config(qua_config)\n\n        generate_config_final_actions(qua_config)\n\n        return qua_config\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamRoot.generate_config","title":"<code>generate_config()</code>","text":"<p>Generate the QUA configuration from the QUAM object.</p> <p>Returns:</p> Type Description <code>DictQuaConfig</code> <p>A dictionary with the QUA configuration.</p> Note <p>This function collects all the nested QuamComponent objects and calls <code>QuamComponent.apply_to_config</code> on them.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def generate_config(self) -&gt; DictQuaConfig:\n    \"\"\"Generate the QUA configuration from the QUAM object.\n\n    Returns:\n        A dictionary with the QUA configuration.\n\n    Note:\n        This function collects all the nested QuamComponent objects and calls\n        `QuamComponent.apply_to_config` on them.\n    \"\"\"\n    qua_config = deepcopy(qua_config_template)\n\n    quam_components = list(self.iterate_components())\n    sorted_components = sort_quam_components(quam_components)\n\n    for quam_component in sorted_components:\n        quam_component.apply_to_config(qua_config)\n\n    generate_config_final_actions(qua_config)\n\n    return qua_config\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamRoot.get_root","title":"<code>get_root()</code>","text":"<p>Get the QuamRoot object of this object, i.e. the object itself.</p> <p>This QuamRoot function overrides the QuamBase function to return the object itself, rather than following the parent chain.</p> <p>Returns:</p> Type Description <code>QuamRootType</code> <p>The current QuamRoot object (self).</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_root(self: QuamRootType) -&gt; QuamRootType:\n    \"\"\"Get the QuamRoot object of this object, i.e. the object itself.\n\n    This QuamRoot function overrides the QuamBase function to return the object\n    itself, rather than following the parent chain.\n\n    Returns:\n        The current QuamRoot object (self).\n    \"\"\"\n    return self\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamRoot.get_serialiser","title":"<code>get_serialiser()</code>  <code>classmethod</code>","text":"<p>Get the serialiser for the QuamRoot class, which is the JSONSerialiser.</p> <p>This method can be overridden by subclasses to provide a custom serialiser.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@classmethod\ndef get_serialiser(cls) -&gt; AbstractSerialiser:\n    \"\"\"Get the serialiser for the QuamRoot class, which is the JSONSerialiser.\n\n    This method can be overridden by subclasses to provide a custom serialiser.\n    \"\"\"\n    return JSONSerialiser()\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamRoot.load","title":"<code>load(filepath_or_dict=None, validate_type=True, fix_attrs=True)</code>  <code>classmethod</code>","text":"<p>Load a QuamRoot object from a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_dict</code> <code>Optional[Union[str, Path, dict]]</code> <p>The path to the file/folder to load, or a dictionary. The dictionary would be the result from a call to <code>QuamRoot.save()</code> Can be omitted, in which case the serialiser will use the default state path, which is typically defined in the quam config file.</p> <code>None</code> <code>validate_type</code> <code>bool</code> <p>Whether to validate the type of all attributes while loading.</p> <code>True</code> <code>fix_attrs</code> <code>bool</code> <p>Whether attributes can be added to QuamBase objects that are not defined as dataclass fields.</p> <code>True</code> <p>Returns:</p> Type Description <code>QuamRootType</code> <p>A QuamRoot object instantiated from the file/folder/dict.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@classmethod\ndef load(\n    cls: type[QuamRootType],\n    filepath_or_dict: Optional[Union[str, Path, dict]] = None,\n    validate_type: bool = True,\n    fix_attrs: bool = True,\n) -&gt; QuamRootType:\n    \"\"\"Load a QuamRoot object from a file.\n\n    Args:\n        filepath_or_dict: The path to the file/folder to load, or a dictionary.\n            The dictionary would be the result from a call to `QuamRoot.save()`\n            Can be omitted, in which case the serialiser will use the default state\n            path, which is typically defined in the quam config file.\n        validate_type: Whether to validate the type of all attributes while loading.\n        fix_attrs: Whether attributes can be added to QuamBase objects that are not\n            defined as dataclass fields.\n\n    Returns:\n        A QuamRoot object instantiated from the file/folder/dict.\n    \"\"\"\n    if isinstance(filepath_or_dict, dict):\n        contents = filepath_or_dict\n    else:\n        serialiser = cls.get_serialiser()\n        contents, _ = serialiser.load(filepath_or_dict)\n\n    return instantiate_quam_class(\n        quam_class=cls,\n        contents=contents,\n        fix_attrs=fix_attrs,\n        validate_type=validate_type,\n    )\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamRoot.save","title":"<code>save(path=None, content_mapping=None, include_defaults=None, ignore=None)</code>","text":"<p>Save the entire QuamRoot object to a file. This includes nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Union[Path, str]]</code> <p>The path to save the file to. If None, the path will be extracted from the <code>state_path</code> attribute of the serialiser, which could be set by the quam config file or environment variable.</p> <code>None</code> <code>content_mapping</code> <code>Optional[Dict[str, str]]</code> <p>Optional mapping of component names to filenames. This can be used to save different parts of the QuamRoot object to different files.</p> <code>None</code> <code>include_defaults</code> <code>Optional[bool]</code> <p>Whether to include attributes that have the default value.</p> <code>None</code> <code>ignore</code> <code>Optional[Sequence[str]]</code> <p>A list of components to ignore.</p> <code>None</code> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def save(\n    self,\n    path: Optional[Union[Path, str]] = None,\n    content_mapping: Optional[Dict[str, str]] = None,\n    include_defaults: Optional[bool] = None,\n    ignore: Optional[Sequence[str]] = None,\n):\n    \"\"\"Save the entire QuamRoot object to a file. This includes nested objects.\n\n    Args:\n        path: The path to save the file to. If None, the path will be extracted from\n            the `state_path` attribute of the serialiser, which could be set by the\n            quam config file or environment variable.\n        content_mapping: Optional mapping of component names to filenames. This can\n            be used to save different parts of the QuamRoot object to different\n            files.\n        include_defaults: Whether to include attributes that have the default\n            value.\n        ignore: A list of components to ignore.\n    \"\"\"\n    self.serialiser.save(\n        quam_obj=self,\n        path=path,\n        content_mapping=content_mapping,\n        include_defaults=include_defaults,\n        ignore=ignore,\n    )\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamComponent","title":"<code>QuamComponent</code>","text":"<p>               Bases: <code>QuamBase</code></p> <p>Base class for any QUAM component class.</p> <p>Examples of QuamComponent classes are <code>Mixer</code>, <code>LocalOscillator</code>, <code>Pulse</code>, etc.</p> Note <p>This class should be subclassed and made a dataclass.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>class QuamComponent(QuamBase):\n    \"\"\"Base class for any QUAM component class.\n\n    Examples of QuamComponent classes are [`Mixer`][quam.components.hardware.Mixer],\n    [`LocalOscillator`][quam.components.hardware.LocalOscillator],\n    [`Pulse`][quam.components.pulses.Pulse], etc.\n\n    Note:\n        This class should be subclassed and made a dataclass.\n    \"\"\"\n\n    def __setattr__(self, name, value):\n        converted_val = convert_dict_and_list(value, cls_or_obj=self, attr=name)\n        super().__setattr__(name, converted_val)\n\n        if isinstance(converted_val, QuamBase) and name != \"parent\":\n            converted_val.parent = self\n\n    def apply_to_config(self, config: dict) -&gt; None:\n        \"\"\"Add information to the QUA configuration, such as pulses and waveforms.\n\n        Args:\n            config: The QUA configuration dictionary. Initially this is a nearly empty\n                dictionary, but\n\n        Note:\n            This function is called by\n            [`QuamRoot.generate_config`][quam.core.quam_classes.QuamRoot.generate_config].\n\n        Note:\n            The config has a starting template, defined at [`quam.core.qua_config_template`][]\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamComponent.apply_to_config","title":"<code>apply_to_config(config)</code>","text":"<p>Add information to the QUA configuration, such as pulses and waveforms.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The QUA configuration dictionary. Initially this is a nearly empty dictionary, but</p> required Note <p>This function is called by <code>QuamRoot.generate_config</code>.</p> Note <p>The config has a starting template, defined at <code>quam.core.qua_config_template</code></p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def apply_to_config(self, config: dict) -&gt; None:\n    \"\"\"Add information to the QUA configuration, such as pulses and waveforms.\n\n    Args:\n        config: The QUA configuration dictionary. Initially this is a nearly empty\n            dictionary, but\n\n    Note:\n        This function is called by\n        [`QuamRoot.generate_config`][quam.core.quam_classes.QuamRoot.generate_config].\n\n    Note:\n        The config has a starting template, defined at [`quam.core.qua_config_template`][]\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamDict","title":"<code>QuamDict</code>","text":"<p>               Bases: <code>UserDict</code>, <code>QuamBase</code></p> <p>A QUAM dictionary class.</p> <p>Any dict added to a <code>QuamBase</code> object is automatically converted to a <code>QuamDict</code>. The <code>QuamDict</code> adds the following functionalities to a dict: - Values can be references (see below) - Keys can also be accessed through attributes (e.g. <code>d.a</code> instead of <code>d[\"a\"]</code>)</p>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamDict--quamdict-references","title":"QuamDict references","text":"<p>QuamDict values can be references, which are strings that start with <code>#</code>. See the documentation for details on references. An example is shown here: <pre><code>d = QuamDict({\"a\": 1, \"b\": \"#./a\"})\nassert d[\"b\"] == 1\n</code></pre></p> Warning <p>This class is a subclass of <code>QuamBase</code>, but also of <code>UserDict</code>. As a result, it can be used as a normal dictionary, but it is not a subclass of <code>dict</code>.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@quam_dataclass\nclass QuamDict(UserDict, QuamBase):\n    \"\"\"A QUAM dictionary class.\n\n    Any dict added to a `QuamBase` object is automatically converted to a `QuamDict`.\n    The `QuamDict` adds the following functionalities to a dict:\n    - Values can be references (see below)\n    - Keys can also be accessed through attributes (e.g. `d.a` instead of `d[\"a\"]`)\n\n    # QuamDict references\n    QuamDict values can be references, which are strings that start with `#`. See the\n    documentation for details on references. An example is shown here:\n    ```\n    d = QuamDict({\"a\": 1, \"b\": \"#./a\"})\n    assert d[\"b\"] == 1\n    ```\n\n    Warning:\n        This class is a subclass of `QuamBase`, but also of `UserDict`. As a result,\n        it can be used as a normal dictionary, but it is not a subclass of `dict`.\n    \"\"\"\n\n    _value_annotation: ClassVar[type] = None\n\n    def __init__(self, dict=None, /, value_annotation: type = None, **kwargs):\n        self.__dict__[\"data\"] = {}\n        self.__dict__[\"_value_annotation\"] = value_annotation\n        self.__dict__[\"_initialized\"] = True\n        super().__init__(dict, **kwargs)\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError as e:\n            try:\n                repr = f\"{self.__class__.__name__}: {self.get_reference()}\"\n            except Exception:\n                repr = self.__class__.__name__\n            raise AttributeError(f'{repr} has no attribute \"{key}\"') from e\n\n    def __setattr__(self, key, value):\n        if key in [\"data\", \"parent\", \"config_settings\", \"_initialized\"]:\n            super().__setattr__(key, value)\n        else:\n            self[key] = value\n\n    def __getitem__(self, i):\n        elem = super().__getitem__(i)\n\n        if not string_reference.is_reference(elem):\n            return elem\n\n        try:\n            target_obj, target_attr = self._follow_reference_chain(self, i)\n            # Handle list/dict indices that result from following the chain\n            if target_attr.isdigit() and isinstance(\n                target_obj, (list, UserList, QuamList)\n            ):\n                return target_obj[int(target_attr)]\n            elif isinstance(target_obj, (dict, UserDict, QuamDict)):\n                return target_obj[target_attr]\n            else:\n                return target_obj.get_raw_value(target_attr)\n        except (AttributeError, KeyError, ValueError):\n            # Chain couldn't be followed (broken reference, missing attribute, etc.)\n            # Return the reference string - _get_referenced_value handles warnings\n            return self._get_referenced_value(elem)\n\n    # Overriding methods from UserDict\n    def __setitem__(self, key, value):\n        value = convert_dict_and_list(value)\n        self._is_valid_setattr(key, value, error_on_False=True)\n        super().__setitem__(key, value)\n\n        if isinstance(value, QuamBase):\n            value.parent = self\n\n    def __eq__(self, other) -&gt; bool:\n        if isinstance(other, dict):\n            return self.data == other\n        return super().__eq__(other)\n\n    def __repr__(self) -&gt; str:\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\",\n                message=\"^Could not get reference*\",\n                category=UserWarning,\n            )\n            return super().__repr__()\n\n    # QUAM methods\n    def _get_attr_names(self):\n        return list(self.data.keys())\n\n    def get_attrs(\n        self, follow_references=False, include_defaults=True\n    ) -&gt; Dict[str, Any]:\n        # TODO implement reference kwargs\n        return self.data\n\n    def get_attr_name(self, attr_val: Any) -&gt; Union[str, int]:\n        \"\"\"Get the name of an attribute that matches the value.\n\n        Args:\n            attr_val: The value of the attribute.\n\n        Returns:\n            The name of the attribute. This can also be an int depending on the dict key\n\n        Raises:\n            AttributeError if not found.\n        \"\"\"\n        for attr_name in self._get_attr_names():\n            if attr_name in self and self.get_raw_value(attr_name) is attr_val:\n                return attr_name\n        else:\n            raise AttributeError(\n                \"Could not find name corresponding to attribute.\\n\"\n                f\"attribute: {attr_val}\\n\"\n                f\"obj: {self}\"\n            )\n\n    def _val_matches_attr_annotation(self, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the type of an attribute matches the annotation.\n\n        Called by [`QuamDict.to_dict`][quam.core.quam_classes.QuamDict.to_dict] to\n        determine whether to add the __class__ key.\n\n        Args:\n            attr: The name of the attribute. Unused but added to match parent signature\n            val: The value of the attribute.\n\n        Note:\n            The attribute val is compared to `QuamDict._value_annotation`, which is set\n            when a dict is converted to a `QuamDict` using `convert_dict_and_list`.\n        \"\"\"\n        if isinstance(val, (QuamDict, QuamList)):\n            return True\n        if self._value_annotation is None:\n            return False\n        return type(val) == self._value_annotation\n\n    def _attr_val_is_default(self, attr: str, val: Any):\n        \"\"\"Check whether the value of an attribute is the default value.\n\n        Overrides parent method.\n        Since a QuamDict does not have any fixed attrs, this is always False.\n\n        \"\"\"\n        return False\n\n    def get_raw_value(self, attr: str) -&gt; Any:\n        \"\"\"Get the value of an attribute without following references.\n\n        Args:\n            attr: The name of the attribute.\n\n        Returns:\n            The value of the attribute. If the value is a reference, it returns the\n            reference string instead of the value it is referencing.\n        \"\"\"\n        try:\n            return self.__dict__[\"data\"][attr]\n        except KeyError as e:\n            raise AttributeError(\n                \"Cannot get raw (unreferenced)value from attribute {attr} that does not\"\n                \" exist in {self}\"\n            ) from e\n\n    def iterate_components(\n        self, skip_elems: Sequence[QuamBase] = None\n    ) -&gt; Generator[\"QuamBase\", None, None]:\n        \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n        Args:\n            skip_elems: A sequence of QuamBase objects to skip.\n                This is used to prevent infinite loops when iterating over nested\n                objects.\n\n        Returns:\n            A generator of QuamBase objects.\n        \"\"\"\n        if skip_elems is None:\n            skip_elems = []\n\n        for attr_val in self.data.values():\n            if any(attr_val is elem for elem in skip_elems):\n                continue\n\n            if isinstance(attr_val, QuamBase):\n                yield from attr_val.iterate_components(skip_elems=skip_elems)\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; dict:\n        \"\"\"Convert this object to a dictionary.\n\n        Ensures all child QUAM objects are also converted to dictionaries.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default\n                value.\n\n        Returns:\n            A dictionary representation of the object.\n        \"\"\"\n        quam_dict = super().to_dict(\n            follow_references=follow_references,\n            include_defaults=include_defaults,\n        )\n\n        # Remove __class__ from the dictionary as it's the default for a dict\n        quam_dict.pop(\"__class__\", None)\n\n        return quam_dict\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamDict.get_attr_name","title":"<code>get_attr_name(attr_val)</code>","text":"<p>Get the name of an attribute that matches the value.</p> <p>Parameters:</p> Name Type Description Default <code>attr_val</code> <code>Any</code> <p>The value of the attribute.</p> required <p>Returns:</p> Type Description <code>Union[str, int]</code> <p>The name of the attribute. This can also be an int depending on the dict key</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_attr_name(self, attr_val: Any) -&gt; Union[str, int]:\n    \"\"\"Get the name of an attribute that matches the value.\n\n    Args:\n        attr_val: The value of the attribute.\n\n    Returns:\n        The name of the attribute. This can also be an int depending on the dict key\n\n    Raises:\n        AttributeError if not found.\n    \"\"\"\n    for attr_name in self._get_attr_names():\n        if attr_name in self and self.get_raw_value(attr_name) is attr_val:\n            return attr_name\n    else:\n        raise AttributeError(\n            \"Could not find name corresponding to attribute.\\n\"\n            f\"attribute: {attr_val}\\n\"\n            f\"obj: {self}\"\n        )\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamDict.get_raw_value","title":"<code>get_raw_value(attr)</code>","text":"<p>Get the value of an attribute without following references.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>The name of the attribute.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the attribute. If the value is a reference, it returns the</p> <code>Any</code> <p>reference string instead of the value it is referencing.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def get_raw_value(self, attr: str) -&gt; Any:\n    \"\"\"Get the value of an attribute without following references.\n\n    Args:\n        attr: The name of the attribute.\n\n    Returns:\n        The value of the attribute. If the value is a reference, it returns the\n        reference string instead of the value it is referencing.\n    \"\"\"\n    try:\n        return self.__dict__[\"data\"][attr]\n    except KeyError as e:\n        raise AttributeError(\n            \"Cannot get raw (unreferenced)value from attribute {attr} that does not\"\n            \" exist in {self}\"\n        ) from e\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamDict.iterate_components","title":"<code>iterate_components(skip_elems=None)</code>","text":"<p>Iterate over all QuamBase objects in this object, including nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>skip_elems</code> <code>Sequence[QuamBase]</code> <p>A sequence of QuamBase objects to skip. This is used to prevent infinite loops when iterating over nested objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A generator of QuamBase objects.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def iterate_components(\n    self, skip_elems: Sequence[QuamBase] = None\n) -&gt; Generator[\"QuamBase\", None, None]:\n    \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n    Args:\n        skip_elems: A sequence of QuamBase objects to skip.\n            This is used to prevent infinite loops when iterating over nested\n            objects.\n\n    Returns:\n        A generator of QuamBase objects.\n    \"\"\"\n    if skip_elems is None:\n        skip_elems = []\n\n    for attr_val in self.data.values():\n        if any(attr_val is elem for elem in skip_elems):\n            continue\n\n        if isinstance(attr_val, QuamBase):\n            yield from attr_val.iterate_components(skip_elems=skip_elems)\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamDict.to_dict","title":"<code>to_dict(follow_references=False, include_defaults=True)</code>","text":"<p>Convert this object to a dictionary.</p> <p>Ensures all child QUAM objects are also converted to dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the object.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def to_dict(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; dict:\n    \"\"\"Convert this object to a dictionary.\n\n    Ensures all child QUAM objects are also converted to dictionaries.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default\n            value.\n\n    Returns:\n        A dictionary representation of the object.\n    \"\"\"\n    quam_dict = super().to_dict(\n        follow_references=follow_references,\n        include_defaults=include_defaults,\n    )\n\n    # Remove __class__ from the dictionary as it's the default for a dict\n    quam_dict.pop(\"__class__\", None)\n\n    return quam_dict\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamList","title":"<code>QuamList</code>","text":"<p>               Bases: <code>UserList</code>, <code>QuamBase</code></p> <p>A QUAM list class.</p> <p>Any list added to a <code>QuamBase</code> object is automatically converted to a <code>QuamList</code>. The <code>QuamList</code> adds the following functionalities to a list: - Elements can be references (see below)</p>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamList--quamlist-references","title":"QuamList references","text":"<p>QuamList values can be references, which are strings that start with <code>#</code>. See the documentation for details on references. An example is shown here: <pre><code>d = QuamList([1, \"#./0\"]])\nassert d[1] == 1\n</code></pre></p> Warning <p>This class is a subclass of <code>QuamBase</code>, but also of <code>UserList</code>. As a result, it can be used as a normal list, but it is not a subclass of <code>list</code>.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>@quam_dataclass\nclass QuamList(UserList, QuamBase):\n    \"\"\"A QUAM list class.\n\n    Any list added to a `QuamBase` object is automatically converted to a `QuamList`.\n    The `QuamList` adds the following functionalities to a list:\n    - Elements can be references (see below)\n\n    # QuamList references\n    QuamList values can be references, which are strings that start with `#`. See the\n    documentation for details on references. An example is shown here:\n    ```\n    d = QuamList([1, \"#./0\"]])\n    assert d[1] == 1\n    ```\n\n    Warning:\n        This class is a subclass of `QuamBase`, but also of `UserList`. As a result,\n        it can be used as a normal list, but it is not a subclass of `list`.\n    \"\"\"\n\n    _value_annotation: ClassVar[type] = None\n\n    def __init__(self, *args, value_annotation: type = None):\n        self._value_annotation = value_annotation\n\n        # We manually add elements using extend instead of passing to super()\n        # To ensure that any dicts and lists get converted to QuamDict and QuamList\n        super().__init__()\n        if args:\n            self.extend(*args)\n\n    # Overloading methods from UserList\n    def __eq__(self, value: object) -&gt; bool:\n        return super().__eq__(value)\n\n    def __repr__(self) -&gt; str:\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\",\n                message=\"^Could not get reference*\",\n                category=UserWarning,\n            )\n            return super().__repr__()\n\n    def __getitem__(self, i):\n        elem = super().__getitem__(i)\n        if isinstance(i, slice):\n            if isinstance(elem, QuamList):\n                elem.parent = self.parent\n            # This automatically gets the referenced values\n            return list(elem)\n\n        elif not string_reference.is_reference(elem):\n            return elem\n\n        try:\n            target_obj, target_attr = self._follow_reference_chain(self, i)\n            # Handle list/dict indices that result from following the chain\n            if target_attr.isdigit() and isinstance(\n                target_obj, (list, UserList, QuamList)\n            ):\n                return target_obj[int(target_attr)]\n            elif isinstance(target_obj, (dict, UserDict, QuamDict)):\n                return target_obj[target_attr]\n            else:\n                return target_obj.get_raw_value(target_attr)\n        except (AttributeError, KeyError, ValueError):\n            # Chain couldn't be followed (broken reference, missing attribute, etc.)\n            # Return the reference string - _get_referenced_value handles warnings\n            return self._get_referenced_value(elem)\n\n    def __setitem__(self, i, item):\n        converted_item = convert_dict_and_list(item)\n        super().__setitem__(i, converted_item)\n\n        if isinstance(converted_item, QuamBase):\n            converted_item.parent = self\n\n    def __iadd__(self, other: Iterable):\n        converted_other = [convert_dict_and_list(elem) for elem in other]\n        return super().__iadd__(converted_other)\n\n    def append(self, item: Any) -&gt; None:\n        converted_item = convert_dict_and_list(item)\n\n        if isinstance(converted_item, QuamBase):\n            converted_item.parent = self\n\n        return super().append(converted_item)\n\n    def insert(self, i: int, item: Any) -&gt; None:\n        converted_item = convert_dict_and_list(item)\n\n        if isinstance(converted_item, QuamBase):\n            converted_item.parent = self\n\n        return super().insert(i, converted_item)\n\n    def extend(self, iterable: Iterator) -&gt; None:\n        converted_iterable = [convert_dict_and_list(elem) for elem in iterable]\n        for converted_item in converted_iterable:\n            if isinstance(converted_item, QuamBase):\n                converted_item.parent = self\n\n        return super().extend(converted_iterable)\n\n    # Quam methods\n    def _val_matches_attr_annotation(self, attr: str, val: Any) -&gt; bool:\n        \"\"\"Check whether the type of an attribute matches the annotation.\n\n        Called by QuamList.to_dict to determine whether to add the __class__ key.\n        For the QuamList, we compare the type to the _value_annotation.\n        \"\"\"\n        if isinstance(val, (QuamDict, QuamList)):\n            return True\n        if self._value_annotation is None:\n            return False\n        return type(val) == self._value_annotation\n\n    def get_attr_name(self, attr_val: Any) -&gt; str:\n        for k, elem in enumerate(self.data):\n            if elem is attr_val:\n                return str(k)\n        else:\n            raise AttributeError(\n                \"Could not find name corresponding to attribute\"\n                f\"attribute: {attr_val}\\n\"\n                f\"obj: {self}\"\n            )\n\n    def to_dict(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; list:\n        \"\"\"Convert this object to a list, usually as part of a dictionary representation.\n\n        Args:\n            follow_references: Whether to follow references when getting the value.\n                If False, the reference will be returned as a string.\n            include_defaults: Whether to include attributes that have the default\n                value.\n\n        Returns:\n            A list with the values of this object. Any QuamBase objects will be\n            recursively converted to dictionaries.\n\n        Note:\n            If the value of an attribute does not match the annotation of\n            `QuamList._value_annotation`, the `\"__class__\"` key will be added to the\n            dictionary. This is to ensure that the object can be reconstructed when\n            loading from a file.\n        \"\"\"\n        quam_list = []\n        for val in self.data:\n            if isinstance(val, QuamBase):\n                quam_list.append(\n                    val.to_dict(\n                        follow_references=follow_references,\n                        include_defaults=include_defaults,\n                    )\n                )\n            else:\n                quam_list.append(val)\n        return quam_list\n\n    def iterate_components(\n        self, skip_elems: List[QuamBase] = None\n    ) -&gt; Generator[\"QuamBase\", None, None]:\n        \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n        Args:\n            skip_elems: A list of QuamBase objects to skip.\n                This is used to prevent infinite loops when iterating over nested\n                objects.\n\n        Returns:\n            A generator of QuamBase objects.\n        \"\"\"\n        if skip_elems is None:\n            skip_elems = []\n\n        for attr_val in self.data:\n            if any(attr_val is elem for elem in skip_elems):\n                continue\n\n            if isinstance(attr_val, QuamBase):\n                yield from attr_val.iterate_components(skip_elems=skip_elems)\n\n    def get_attrs(\n        self, follow_references: bool = False, include_defaults: bool = True\n    ) -&gt; Dict[str, Any]:\n        raise NotImplementedError(\"QuamList does not have attributes\")\n\n    def print_summary(self, indent: int = 0):\n        \"\"\"Print a summary of the QuamBase object.\n\n        Args:\n            indent: The number of spaces to indent the summary.\n        \"\"\"\n\n        if self.parent is None:\n            full_name = f\"{self.__class__.__name__} (parent unknown):\"\n        else:\n            try:\n                attr_name = self.parent.get_attr_name(self)\n                full_name = f\"{attr_name}: {self.__class__.__name__}\"\n            except AttributeError:\n                full_name = f\"{self.__class__.__name__}:\"\n\n        if not self.data:\n            print(\" \" * indent + f\"{full_name} = []\")\n            return\n\n        print(\" \" * indent + f\"{full_name}:\")\n        if len(str(self.data)) + 2 * indent &lt; 80:\n            print(\" \" * (indent + 2) + f\"{self.data}\")\n        else:\n            for k, val in enumerate(self.data):\n                if isinstance(val, QuamBase):\n                    val.print_summary(indent=indent + 2)\n                else:\n                    print(\" \" * (indent + 2) + f\"{k}: {val}\")\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamList.iterate_components","title":"<code>iterate_components(skip_elems=None)</code>","text":"<p>Iterate over all QuamBase objects in this object, including nested objects.</p> <p>Parameters:</p> Name Type Description Default <code>skip_elems</code> <code>List[QuamBase]</code> <p>A list of QuamBase objects to skip. This is used to prevent infinite loops when iterating over nested objects.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A generator of QuamBase objects.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def iterate_components(\n    self, skip_elems: List[QuamBase] = None\n) -&gt; Generator[\"QuamBase\", None, None]:\n    \"\"\"Iterate over all QuamBase objects in this object, including nested objects.\n\n    Args:\n        skip_elems: A list of QuamBase objects to skip.\n            This is used to prevent infinite loops when iterating over nested\n            objects.\n\n    Returns:\n        A generator of QuamBase objects.\n    \"\"\"\n    if skip_elems is None:\n        skip_elems = []\n\n    for attr_val in self.data:\n        if any(attr_val is elem for elem in skip_elems):\n            continue\n\n        if isinstance(attr_val, QuamBase):\n            yield from attr_val.iterate_components(skip_elems=skip_elems)\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamList.print_summary","title":"<code>print_summary(indent=0)</code>","text":"<p>Print a summary of the QuamBase object.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>The number of spaces to indent the summary.</p> <code>0</code> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def print_summary(self, indent: int = 0):\n    \"\"\"Print a summary of the QuamBase object.\n\n    Args:\n        indent: The number of spaces to indent the summary.\n    \"\"\"\n\n    if self.parent is None:\n        full_name = f\"{self.__class__.__name__} (parent unknown):\"\n    else:\n        try:\n            attr_name = self.parent.get_attr_name(self)\n            full_name = f\"{attr_name}: {self.__class__.__name__}\"\n        except AttributeError:\n            full_name = f\"{self.__class__.__name__}:\"\n\n    if not self.data:\n        print(\" \" * indent + f\"{full_name} = []\")\n        return\n\n    print(\" \" * indent + f\"{full_name}:\")\n    if len(str(self.data)) + 2 * indent &lt; 80:\n        print(\" \" * (indent + 2) + f\"{self.data}\")\n    else:\n        for k, val in enumerate(self.data):\n            if isinstance(val, QuamBase):\n                val.print_summary(indent=indent + 2)\n            else:\n                print(\" \" * (indent + 2) + f\"{k}: {val}\")\n</code></pre>"},{"location":"API_references/core/quam_classes_API/#quam.core.quam_classes.QuamList.to_dict","title":"<code>to_dict(follow_references=False, include_defaults=True)</code>","text":"<p>Convert this object to a list, usually as part of a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>follow_references</code> <code>bool</code> <p>Whether to follow references when getting the value. If False, the reference will be returned as a string.</p> <code>False</code> <code>include_defaults</code> <code>bool</code> <p>Whether to include attributes that have the default value.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list with the values of this object. Any QuamBase objects will be</p> <code>list</code> <p>recursively converted to dictionaries.</p> Note <p>If the value of an attribute does not match the annotation of <code>QuamList._value_annotation</code>, the <code>\"__class__\"</code> key will be added to the dictionary. This is to ensure that the object can be reconstructed when loading from a file.</p> Source code in <code>quam/core/quam_classes.py</code> <pre><code>def to_dict(\n    self, follow_references: bool = False, include_defaults: bool = True\n) -&gt; list:\n    \"\"\"Convert this object to a list, usually as part of a dictionary representation.\n\n    Args:\n        follow_references: Whether to follow references when getting the value.\n            If False, the reference will be returned as a string.\n        include_defaults: Whether to include attributes that have the default\n            value.\n\n    Returns:\n        A list with the values of this object. Any QuamBase objects will be\n        recursively converted to dictionaries.\n\n    Note:\n        If the value of an attribute does not match the annotation of\n        `QuamList._value_annotation`, the `\"__class__\"` key will be added to the\n        dictionary. This is to ensure that the object can be reconstructed when\n        loading from a file.\n    \"\"\"\n    quam_list = []\n    for val in self.data:\n        if isinstance(val, QuamBase):\n            quam_list.append(\n                val.to_dict(\n                    follow_references=follow_references,\n                    include_defaults=include_defaults,\n                )\n            )\n        else:\n            quam_list.append(val)\n    return quam_list\n</code></pre>"},{"location":"API_references/core/quam_instantiation/","title":"Quam instantiation","text":""},{"location":"API_references/core/quam_instantiation/#quam.core.quam_instantiation.instantiate_attr","title":"<code>instantiate_attr(attr_val, expected_type, allow_none=False, fix_attrs=True, validate_type=True, str_repr='')</code>","text":"<p>Instantiate a single attribute which may be a QuamComponent</p> The attribute instantiation behaviour depends on the required attribute type <ul> <li>If the required type is a QuamComponent -&gt; instantiate the QuamComponent</li> <li>If the required type is a dict -&gt; instantiate all elements of the dict</li> <li>If the required type is a list -&gt; instantiate all elements of the list</li> <li>Otherwise, the attribute is not instantiated</li> </ul> <p>Note that references and None are not instantiated, nor validated.</p> <p>Parameters:</p> Name Type Description Default <code>attr_val</code> <p>The value of the to instantiate.</p> required <code>required_type</code> <p>The required type of the attribute.</p> required <code>allow_none</code> <code>bool</code> <p>Whether None is allowed as a value even if it's the wrong type.</p> <code>False</code> <code>fix_attrs</code> <code>bool</code> <p>Whether to only allow attributes that have been defined in the class Only included because it's passed on when instantiating QuamComponents.</p> <code>True</code> <code>validate_type</code> <code>bool</code> <p>Whether to validate the type of the attributes. If True, a TypeError is raised if an attribute has the wrong type.</p> <code>True</code> <code>str_repr</code> <code>str</code> <p>A string representation of the object, used for error messages.</p> <code>''</code> <p>Returns:</p> Type Description <p>The instantiated attribute.</p> Source code in <code>quam/core/quam_instantiation.py</code> <pre><code>def instantiate_attr(\n    attr_val,\n    expected_type: type,\n    allow_none: bool = False,\n    fix_attrs: bool = True,\n    validate_type: bool = True,\n    str_repr: str = \"\",\n):\n    \"\"\"Instantiate a single attribute which may be a QuamComponent\n\n    The attribute instantiation behaviour depends on the required attribute type:\n        - If the required type is a QuamComponent -&gt; instantiate the QuamComponent\n        - If the required type is a dict -&gt; instantiate all elements of the dict\n        - If the required type is a list -&gt; instantiate all elements of the list\n        - Otherwise, the attribute is not instantiated\n\n    Note that references and None are not instantiated, nor validated.\n\n    Args:\n        attr_val: The value of the to instantiate.\n        required_type: The required type of the attribute.\n        allow_none: Whether None is allowed as a value even if it's the wrong type.\n        fix_attrs: Whether to only allow attributes that have been defined in the class\n            Only included because it's passed on when instantiating QuamComponents.\n        validate_type: Whether to validate the type of the attributes.\n            If True, a TypeError is raised if an attribute has the wrong type.\n        str_repr: A string representation of the object, used for error messages.\n\n    Returns:\n        The instantiated attribute.\n    \"\"\"\n    from quam.core import QuamComponent  # noqa: F811\n\n    # Convert Optional[T] to T with allow_none=True\n    if type_is_optional(expected_type):\n        expected_type = typing.get_args(expected_type)[0]\n        allow_none = True\n\n    if string_reference.is_reference(attr_val):\n        # Value is a reference, add without instantiating\n        instantiated_attr = attr_val\n    elif attr_val is None:\n        instantiated_attr = attr_val\n    elif isclass(expected_type) and issubclass(expected_type, QuamComponent):\n        instantiated_attr = instantiate_quam_class(\n            quam_class=expected_type,\n            contents=attr_val,\n            fix_attrs=fix_attrs,\n            validate_type=validate_type,\n            str_repr=str_repr,\n        )\n    elif isinstance(attr_val, dict) and \"__class__\" in attr_val:\n        instantiated_attr = instantiate_quam_class(\n            quam_class=expected_type,\n            contents=attr_val,\n            fix_attrs=fix_attrs,\n            validate_type=validate_type,\n            str_repr=str_repr,\n        )\n    elif isinstance(expected_type, dict) or typing.get_origin(expected_type) == dict:\n        instantiated_attr = instantiate_attrs_from_dict(\n            attr_dict=attr_val,\n            required_type=expected_type,\n            fix_attrs=fix_attrs,\n            validate_type=validate_type,\n            str_repr=str_repr,\n        )\n        if typing.get_origin(expected_type) == dict:\n            expected_type = dict\n    elif typing.get_origin(expected_type) in union_types:\n        for union_type in typing.get_args(expected_type):\n            try:\n                instantiated_attr = instantiate_attr(\n                    attr_val=attr_val,\n                    expected_type=union_type,\n                    allow_none=allow_none,\n                    fix_attrs=fix_attrs,\n                    validate_type=validate_type,\n                    str_repr=str_repr,\n                )\n                break\n            except TypeError:\n                continue\n        else:\n            raise TypeError(\n                f\"Could not instantiate {str_repr} with any of the types in {expected_type}\"\n            )\n    elif (\n        isinstance(expected_type, list)\n        or typing.get_origin(expected_type) == list\n        or isinstance(attr_val, list)\n    ):\n        instantiated_attr = instantiate_attrs_from_list(\n            attr_list=attr_val,\n            required_type=expected_type,\n            fix_attrs=fix_attrs,\n            validate_type=validate_type,\n            str_repr=str_repr,\n        )\n        if typing.get_origin(expected_type) == list:\n            expected_type = list\n        elif typing.get_origin(expected_type) == tuple:\n            instantiated_attr = tuple(instantiated_attr)\n    elif typing.get_origin(expected_type) == tuple:\n        if isinstance(attr_val, list):\n            attr_val = tuple(attr_val)\n        instantiated_attr = attr_val\n    elif typing.get_origin(expected_type) == typing.Literal:\n        instantiated_attr = attr_val\n    elif typing.get_origin(expected_type) is not None and validate_type:\n        raise TypeError(\n            f\"Instantiation for type {expected_type} in {str_repr} not implemented\"\n        )\n    else:\n        instantiated_attr = attr_val\n\n    if validate_type:\n        # Handle specific case: float-to-int coercion for saved state compatibility\n        if expected_type == int and isinstance(instantiated_attr, float):\n            instantiated_attr = int(instantiated_attr)\n\n        # TODO Add logic that required attributes cannot be None\n        validate_obj_type(\n            elem=instantiated_attr,\n            required_type=expected_type,\n            allow_none=allow_none,\n            str_repr=str_repr,\n        )\n    return instantiated_attr\n</code></pre>"},{"location":"API_references/core/quam_instantiation/#quam.core.quam_instantiation.instantiate_attrs","title":"<code>instantiate_attrs(attr_annotations, contents, fix_attrs=True, validate_type=True, str_repr='')</code>","text":"<p>Instantiate attributes if they are or contain QuamComponents</p> <p>Dictionaries and lists are instantiated recursively</p> <p>Parameters:</p> Name Type Description Default <code>attr_annotations</code> <code>Dict[str, Dict[str, type]]</code> <p>The attributes of the QuamComponent or QuamDict together with their types. Grouped into \"required\", \"optional\" and \"allowed\"</p> required <code>contents</code> <code>dict</code> <p>The attr contents of the QuamRoot, QuamComponent or QuamDict.</p> required <code>fix_attrs</code> <code>bool</code> <p>Whether to only allow attributes that have been defined in the class definition. If False, any attribute can be set. QuamDicts are never fixed.</p> <code>True</code> <code>validate_type</code> <code>bool</code> <p>Whether to validate the type of the attributes. A TypeError is raised if an attribute has the wrong type.</p> <code>True</code> <code>str_repr</code> <code>str</code> <p>A string representation of the object, used for error messages.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary where each element has been instantiated if it is a QuamComponent</p> Source code in <code>quam/core/quam_instantiation.py</code> <pre><code>def instantiate_attrs(\n    attr_annotations: Dict[str, Dict[str, type]],\n    contents: dict,\n    fix_attrs: bool = True,\n    validate_type: bool = True,\n    str_repr: str = \"\",\n) -&gt; Dict[str, Any]:\n    \"\"\"Instantiate attributes if they are or contain QuamComponents\n\n    Dictionaries and lists are instantiated recursively\n\n    Args:\n        attr_annotations: The attributes of the QuamComponent or QuamDict\n            together with their types. Grouped into \"required\", \"optional\" and \"allowed\"\n        contents: The attr contents of the QuamRoot, QuamComponent or QuamDict.\n        fix_attrs: Whether to only allow attributes that have been defined in the\n            class definition. If False, any attribute can be set.\n            QuamDicts are never fixed.\n        validate_type: Whether to validate the type of the attributes.\n            A TypeError is raised if an attribute has the wrong type.\n        str_repr: A string representation of the object, used for error messages.\n\n    Returns:\n        A dictionary where each element has been instantiated if it is a QuamComponent\n    \"\"\"\n    instantiated_attrs = {\"required\": {}, \"optional\": {}, \"extra\": {}}\n    for attr_name, attr_val in contents.items():\n        if attr_name == \"__class__\":\n            continue\n        if attr_name not in attr_annotations[\"allowed\"]:\n            if not fix_attrs:\n                instantiated_attrs[\"extra\"][attr_name] = attr_val\n                continue\n            raise AttributeError(\n                f\"Attribute {attr_name} is not a valid attr of {str_repr}\"\n            )\n\n        if isinstance(attr_val, dict) and \"__class__\" in attr_val:\n            expected_type = get_class_from_path(attr_val[\"__class__\"])\n        else:\n            expected_type = attr_annotations[\"allowed\"][attr_name]\n\n        instantiated_attr = instantiate_attr(\n            attr_val=attr_val,\n            expected_type=expected_type,\n            allow_none=attr_name not in attr_annotations[\"required\"],\n            fix_attrs=fix_attrs,\n            validate_type=validate_type,\n            str_repr=f\"{str_repr}.{attr_name}\",\n        )\n\n        if attr_name in attr_annotations[\"required\"]:\n            instantiated_attrs[\"required\"][attr_name] = instantiated_attr\n        else:\n            instantiated_attrs[\"optional\"][attr_name] = instantiated_attr\n\n    missing_attrs = set(attr_annotations[\"required\"]) - set(\n        instantiated_attrs[\"required\"]\n    )\n    if missing_attrs:\n        raise AttributeError(f\"Missing required attrs {missing_attrs} for {str_repr}\")\n\n    return instantiated_attrs\n</code></pre>"},{"location":"API_references/core/quam_instantiation/#quam.core.quam_instantiation.instantiate_attrs_from_dict","title":"<code>instantiate_attrs_from_dict(attr_dict, required_type, fix_attrs=True, validate_type=True, str_repr='')</code>","text":"<p>Instantiate the QuamComponent attributes in a dict</p> <p>QuamComponents are only instantiated if required_type is typing.Dict and the value subtype is a QuamComponent. In this case, the value is instantiated as a QuamComponent. Otherwise, no QuamComponents are instantiated.</p> <p>Parameters:</p> Name Type Description Default <code>attr_dict</code> <code>dict</code> <p>The attributes to instantiate.</p> required <code>required_type</code> <code>type</code> <p>The required type of the attributes, either dict or typing.Dict.</p> required <code>fix_attrs</code> <code>bool</code> <p>Whether to only allow attributes that have been defined in the class Only included because it's passed on when instantiating QuamComponents.</p> <code>True</code> <code>validate_type</code> <code>bool</code> <p>Whether to validate the type of the attributes. A TypeError is raised if an attribute has the wrong type.</p> <code>True</code> <code>str_repr</code> <code>str</code> <p>A string representation of the object, used for error messages.</p> <code>''</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with the instantiated attributes.</p> Source code in <code>quam/core/quam_instantiation.py</code> <pre><code>def instantiate_attrs_from_dict(\n    attr_dict: dict,\n    required_type: type,\n    fix_attrs: bool = True,\n    validate_type: bool = True,\n    str_repr: str = \"\",\n) -&gt; dict:\n    \"\"\"Instantiate the QuamComponent attributes in a dict\n\n    QuamComponents are only instantiated if required_type is typing.Dict and the value\n    subtype is a QuamComponent. In this case, the value is instantiated as a\n    QuamComponent.\n    Otherwise, no QuamComponents are instantiated.\n\n    Args:\n        attr_dict: The attributes to instantiate.\n        required_type: The required type of the attributes, either dict or typing.Dict.\n        fix_attrs: Whether to only allow attributes that have been defined in the class\n            Only included because it's passed on when instantiating QuamComponents.\n        validate_type: Whether to validate the type of the attributes.\n            A TypeError is raised if an attribute has the wrong type.\n        str_repr: A string representation of the object, used for error messages.\n\n    Returns:\n        A dictionary with the instantiated attributes.\n    \"\"\"\n    from quam.core import QuamComponent  # noqa: F811\n\n    if typing.get_origin(required_type) == dict:\n        required_subtype = typing.get_args(required_type)[1]\n    else:\n        required_subtype = None\n\n    if not isinstance(attr_dict, (dict, UserDict)):\n        raise TypeError(\n            f\"Failed instantiating QUAM attribute '{str_repr}'. \"\n            f\"Expected dict or UserDict, got {type(attr_dict)}: {attr_dict}\"\n        )\n\n    instantiated_attr_dict = {}\n    for attr_name, attr_val in attr_dict.items():\n        instantiated_attr_dict[attr_name] = instantiate_attr(\n            attr_val=attr_val,\n            expected_type=required_subtype,\n            allow_none=False,\n            fix_attrs=fix_attrs,\n            validate_type=validate_type if required_subtype is not None else False,\n            str_repr=f'{str_repr}[\"{attr_name}\"]',\n        )\n\n    return instantiated_attr_dict\n</code></pre>"},{"location":"API_references/core/quam_instantiation/#quam.core.quam_instantiation.instantiate_attrs_from_list","title":"<code>instantiate_attrs_from_list(attr_list, required_type, fix_attrs=True, validate_type=True, str_repr='')</code>","text":"<p>Instantiate the QuamComponent attributes in a list</p> <p>QuamComponents are only instantiated if required_type is typing.List and the subtype is a QuamComponent. In this case, the value is instantiated as a QuamComponent. Otherwise, no QuamComponents are instantiated.</p> <p>Parameters:</p> Name Type Description Default <code>attr_list</code> <code>list</code> <p>The attributes to instantiate.</p> required <code>required_type</code> <code>type</code> <p>The required type of the attributes, either list or typing.List.</p> required <code>fix_attrs</code> <code>bool</code> <p>Whether to only allow attributes that have been defined in the class Only included because it's passed on when instantiating QuamComponents.</p> <code>True</code> <code>validate_type</code> <code>bool</code> <p>Whether to validate the type of the attributes. A TypeError is raised if an attribute has the wrong type.</p> <code>True</code> <code>str_repr</code> <code>str</code> <p>A string representation of the object, used for error messages.</p> <code>''</code> <p>Returns:</p> Type Description <code>list</code> <p>A list with the instantiated attributes.</p> Source code in <code>quam/core/quam_instantiation.py</code> <pre><code>def instantiate_attrs_from_list(\n    attr_list: list,\n    required_type: type,\n    fix_attrs: bool = True,\n    validate_type: bool = True,\n    str_repr: str = \"\",\n) -&gt; list:\n    \"\"\"Instantiate the QuamComponent attributes in a list\n\n    QuamComponents are only instantiated if required_type is typing.List and the subtype\n    is a QuamComponent. In this case, the value is instantiated as a QuamComponent.\n    Otherwise, no QuamComponents are instantiated.\n\n    Args:\n        attr_list: The attributes to instantiate.\n        required_type: The required type of the attributes, either list or typing.List.\n        fix_attrs: Whether to only allow attributes that have been defined in the class\n            Only included because it's passed on when instantiating QuamComponents.\n        validate_type: Whether to validate the type of the attributes.\n            A TypeError is raised if an attribute has the wrong type.\n        str_repr: A string representation of the object, used for error messages.\n\n    Returns:\n        A list with the instantiated attributes.\n    \"\"\"\n    from quam.core import QuamComponent  # noqa: F811\n\n    if typing.get_origin(required_type) == list:\n        required_subtype = typing.get_args(required_type)[0]\n    else:\n        required_subtype = None\n\n    if not isinstance(attr_list, (list, UserList)):\n        raise TypeError(\n            f\"Failed instantiating QUAM attribute '{str_repr}'. \"\n            f\"Expected list or UserList, got {type(attr_list)}: {attr_list}\"\n        )\n\n    instantiated_attr_list = []\n    for k, attr_val in enumerate(attr_list):\n        instantiated_attr_list.append(\n            instantiate_attr(\n                attr_val=attr_val,\n                expected_type=required_subtype,\n                allow_none=False,\n                fix_attrs=fix_attrs,\n                validate_type=validate_type if required_subtype is not None else False,\n                str_repr=f\"{str_repr}[{k}]\",\n            )\n        )\n    return instantiated_attr_list\n</code></pre>"},{"location":"API_references/core/quam_instantiation/#quam.core.quam_instantiation.instantiate_quam_class","title":"<code>instantiate_quam_class(quam_class, contents, fix_attrs=True, validate_type=True, str_repr='')</code>","text":"<p>Instantiate a QuamBase from a dict</p> <p>Note that any nested QuamBases are instantiated recursively</p> <p>Parameters:</p> Name Type Description Default <code>quam_class</code> <code>type[QuamBase]</code> <p>QuamBase class to instantiate</p> required <code>contents</code> <code>dict</code> <p>dict of attributes to instantiate the QuamBase with</p> required <code>fix_attrs</code> <code>bool</code> <p>Whether to only allow attributes that have been defined in the class definition. If False, any attribute can be set. QuamDicts are never fixed.</p> <code>True</code> <code>validate_type</code> <code>bool</code> <p>Whether to validate the type of the attributes. A TypeError is raised if an attribute has the wrong type.</p> <code>True</code> <code>str_repr</code> <code>str</code> <p>A string representation of the object, used for error messages.</p> <code>''</code> <p>Returns:</p> Type Description <code>QuamBase</code> <p>QuamBase instance</p> Source code in <code>quam/core/quam_instantiation.py</code> <pre><code>def instantiate_quam_class(\n    quam_class: type[QuamBase],\n    contents: dict,\n    fix_attrs: bool = True,\n    validate_type: bool = True,\n    str_repr: str = \"\",\n) -&gt; QuamBase:\n    \"\"\"Instantiate a QuamBase from a dict\n\n    Note that any nested QuamBases are instantiated recursively\n\n    Args:\n        quam_class: QuamBase class to instantiate\n        contents: dict of attributes to instantiate the QuamBase with\n        fix_attrs: Whether to only allow attributes that have been defined in the class\n            definition. If False, any attribute can be set.\n            QuamDicts are never fixed.\n        validate_type: Whether to validate the type of the attributes.\n            A TypeError is raised if an attribute has the wrong type.\n        str_repr: A string representation of the object, used for error messages.\n\n    Returns:\n        QuamBase instance\n    \"\"\"\n    # Add depcrecation checks\n    for deprecation_rule in instantiation_deprecations:\n        if deprecation_rule.match(quam_class=quam_class, contents=contents):\n            quam_class, contents = deprecation_rule.apply(\n                quam_class=quam_class, contents=contents\n            )\n\n    if not str_repr:\n        str_repr = quam_class.__name__\n    # str_repr = f\"{str_repr}.{quam_class.__name__}\" if str_repr else quam_class.__name__\n\n    if \"__class__\" in contents:\n        try:\n            quam_class = get_class_from_path(contents[\"__class__\"])\n        except ModuleNotFoundError:\n            warnings.warn(\n                f\"Could not instantiate {str_repr} with class {contents['__class__']}, \"\n                f\"falling back to {quam_class.__name__}\"\n            )\n\n    if not isinstance(contents, dict):\n        raise TypeError(\n            f\"contents must be a dict, not {type(contents)}, could not instantiate\"\n            f\" {str_repr}. Contents: {contents}\"\n        )\n\n    attr_annotations = get_dataclass_attr_annotations(quam_class)\n\n    instantiated_attrs = instantiate_attrs(\n        attr_annotations=attr_annotations,\n        contents=contents,\n        fix_attrs=fix_attrs,\n        validate_type=validate_type,\n        str_repr=str_repr,\n    )\n\n    quam_component = quam_class(\n        **{**instantiated_attrs[\"required\"], **instantiated_attrs[\"optional\"]}\n    )\n\n    if fix_attrs:\n        assert not instantiated_attrs[\"extra\"]\n    else:\n        for attr, val in instantiated_attrs[\"extra\"].items():\n            setattr(quam_component, attr, val)\n\n    return quam_component\n</code></pre>"},{"location":"API_references/core/macro/base_macro/","title":"Base macro","text":""},{"location":"API_references/core/macro/base_macro/#quam.core.macro.base_macro.BaseMacro","title":"<code>BaseMacro</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all macro types in the system</p> Source code in <code>quam/core/macro/base_macro.py</code> <pre><code>class BaseMacro(ABC):\n    \"\"\"Base class for all macro types in the system\"\"\"\n\n    @abstractmethod\n    def apply(self, *args, **kwargs) -&gt; Any:\n        \"\"\"Applies the macro operation\"\"\"\n        pass\n</code></pre>"},{"location":"API_references/core/macro/base_macro/#quam.core.macro.base_macro.BaseMacro.apply","title":"<code>apply(*args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Applies the macro operation</p> Source code in <code>quam/core/macro/base_macro.py</code> <pre><code>@abstractmethod\ndef apply(self, *args, **kwargs) -&gt; Any:\n    \"\"\"Applies the macro operation\"\"\"\n    pass\n</code></pre>"},{"location":"API_references/core/macro/method_macro/","title":"Method macro","text":""},{"location":"API_references/core/macro/method_macro/#quam.core.macro.method_macro.MethodMacro","title":"<code>MethodMacro</code>","text":"<p>               Bases: <code>BaseMacro</code></p> <p>Decorator that marks methods which should be exposed as macros.</p> Source code in <code>quam/core/macro/method_macro.py</code> <pre><code>class MethodMacro(BaseMacro):\n    \"\"\"Decorator that marks methods which should be exposed as macros.\"\"\"\n\n    def __init__(self, func: T) -&gt; None:\n        functools.wraps(func)(self)\n        self.func = func\n        self.instance = None\n\n    def __get__(self, instance, owner):\n        # Store the instance to which this method is bound\n        self.instance = instance\n        return self\n\n    def apply(self, *args, **kwargs) -&gt; Any:\n        \"\"\"Implements BaseMacro.apply by calling the wrapped function\"\"\"\n        if self.instance is not None:\n            # Call the function with the instance as the first argument\n            return self.func(self.instance, *args, **kwargs)\n        return self.func(*args, **kwargs)\n\n    def __call__(self, *args, **kwargs):\n        if args and args[0] is self.instance:\n            args = args[1:]\n        return self.apply(*args, **kwargs)\n\n    @staticmethod\n    def is_macro_method(obj: Any) -&gt; bool:\n        return isinstance(obj, MethodMacro)\n</code></pre>"},{"location":"API_references/core/macro/method_macro/#quam.core.macro.method_macro.MethodMacro.apply","title":"<code>apply(*args, **kwargs)</code>","text":"<p>Implements BaseMacro.apply by calling the wrapped function</p> Source code in <code>quam/core/macro/method_macro.py</code> <pre><code>def apply(self, *args, **kwargs) -&gt; Any:\n    \"\"\"Implements BaseMacro.apply by calling the wrapped function\"\"\"\n    if self.instance is not None:\n        # Call the function with the instance as the first argument\n        return self.func(self.instance, *args, **kwargs)\n    return self.func(*args, **kwargs)\n</code></pre>"},{"location":"API_references/core/macro/quam_macro/","title":"Quam macro","text":""},{"location":"API_references/core/macro/quam_macro/#quam.core.macro.quam_macro.QuamMacro","title":"<code>QuamMacro</code>","text":"<p>               Bases: <code>QuamComponent</code>, <code>BaseMacro</code>, <code>ABC</code></p> Source code in <code>quam/core/macro/quam_macro.py</code> <pre><code>@quam_dataclass\nclass QuamMacro(QuamComponent, BaseMacro, ABC):\n    id: str = \"#./inferred_id\"\n    fidelity: Optional[float] = None\n    duration: Optional[float] = \"#./inferred_duration\"\n\n    @property\n    def inferred_id(self):\n        if not str_ref.is_reference(self.get_raw_value(\"id\")):\n            return self.id\n        elif self.parent is not None:\n            name = self.parent.get_attr_name(self)\n            return name\n        else:\n            raise AttributeError(\n                f\"Cannot infer id of {self} because it is not attached to a parent\"\n            )\n\n    @property\n    def inferred_duration(self) -&gt; Optional[float]:\n        \"\"\"\n        This property is used to get the duration of the macro (in seconds).\n        It is not implemented in the base class, but can be overridden in subclasses.\n        If not implemented, the macro is assumed to have no fixed duration.\n        \"\"\"\n        return None\n</code></pre>"},{"location":"API_references/core/macro/quam_macro/#quam.core.macro.quam_macro.QuamMacro.inferred_duration","title":"<code>inferred_duration</code>  <code>property</code>","text":"<p>This property is used to get the duration of the macro (in seconds). It is not implemented in the base class, but can be overridden in subclasses. If not implemented, the macro is assumed to have no fixed duration.</p>"},{"location":"API_references/core/operation/function_properties/","title":"Function properties","text":""},{"location":"API_references/core/operation/function_properties/#quam.core.operation.function_properties.FunctionProperties","title":"<code>FunctionProperties</code>  <code>dataclass</code>","text":"<p>Properties of a quantum operation function.</p> <p>This class extracts and stores metadata about functions that operate on quantum components, including argument information and type requirements.</p> <p>Attributes:</p> Name Type Description <code>quantum_component_name</code> <code>str</code> <p>Name of the parameter accepting the quantum component</p> <code>quantum_component_type</code> <code>Type[QC]</code> <p>Type of quantum component the function operates on</p> <code>name</code> <code>str</code> <p>Name of the function</p> <code>required_args</code> <code>list[str]</code> <p>List of required argument names after the quantum component</p> <code>optional_args</code> <code>dict[str, Any]</code> <p>Dictionary of optional arguments and their default values</p> Source code in <code>quam/core/operation/function_properties.py</code> <pre><code>@dataclass\nclass FunctionProperties:\n    \"\"\"\n    Properties of a quantum operation function.\n\n    This class extracts and stores metadata about functions that operate on\n    quantum components, including argument information and type requirements.\n\n    Attributes:\n        quantum_component_name: Name of the parameter accepting the quantum component\n        quantum_component_type: Type of quantum component the function operates on\n        name: Name of the function\n        required_args: List of required argument names after the quantum component\n        optional_args: Dictionary of optional arguments and their default values\n    \"\"\"\n\n    quantum_component_name: str\n    quantum_component_type: Type[QC]\n    name: str = \"\"\n    required_args: list[str] = field(default_factory=list)\n    optional_args: dict[str, Any] = field(default_factory=dict)\n    return_type: Optional[Type] = None\n\n    def __post_init__(self):\n        # Make a new list/dict to avoid sharing between instances\n        self.required_args = list(self.required_args)\n        self.optional_args = dict(self.optional_args)\n\n        # Validate argument names\n        all_args = self.required_args + list(self.optional_args)\n        for arg in all_args:\n            if not arg.isidentifier():\n                raise ValueError(f\"Invalid argument name: {arg!r}\")\n            if keyword.iskeyword(arg):\n                raise ValueError(f\"Argument name cannot be a Python keyword: {arg!r}\")\n\n    @staticmethod\n    def _is_quantum_component_type(type_hint: Optional[Type]) -&gt; bool:\n        \"\"\"Check if type is or inherits from QuantumComponent.\"\"\"\n        try:\n            return (\n                type_hint is not None\n                and isinstance(type_hint, type)\n                and issubclass(type_hint, QuantumComponent)\n            )\n        except TypeError:\n            return False\n\n    @classmethod\n    def from_function(cls, func: Callable) -&gt; \"FunctionProperties\":\n        if not callable(func):\n            raise ValueError(f\"Input {func!r} must be a callable\")\n\n        signature = inspect.signature(func)\n        parameters = signature.parameters\n\n        if not parameters:\n            raise ValueError(\n                f\"Operation {func.__name__!r} must accept at least one argument \"\n                \"(a QuantumComponent)\"\n            )\n\n        # Try to get type hints, gracefully handle missing annotations\n        try:\n            type_hints = get_type_hints(func)\n        except (NameError, TypeError):\n            # Fallback to using the raw annotations if get_type_hints fails\n            type_hints = getattr(func, \"__annotations__\", {})\n\n        parameters_iterator = iter(parameters)\n        first_param_name = next(parameters_iterator)\n\n        # Get and resolve the type of the first parameter\n        first_param_type = type_hints.get(first_param_name)\n\n        if not cls._is_quantum_component_type(first_param_type):\n            if first_param_type is None:\n                msg = (\n                    f\"Operation {func.__name__!r} is missing type annotation for \"\n                    f\"first parameter {first_param_name!r}\"\n                )\n            else:\n                msg = (\n                    f\"Operation {func.__name__!r} must accept a QuantumComponent \"\n                    f\"as its first argument, got {first_param_type!r}\"\n                )\n            raise ValueError(msg)\n\n        function_properties = cls(\n            quantum_component_name=first_param_name,\n            quantum_component_type=first_param_type,  # type: ignore\n            name=func.__name__,\n        )\n\n        # Process remaining parameters\n        for param_name in parameters_iterator:\n            param = parameters[param_name]\n            if param.default == inspect.Parameter.empty:\n                function_properties.required_args.append(param_name)\n            else:\n                # Store the default value directly\n                function_properties.optional_args[param_name] = param.default\n\n        # Get the return type from the function annotations\n        function_properties.return_type = type_hints.get(\"return\")\n\n        return function_properties\n</code></pre>"},{"location":"API_references/core/operation/operation/","title":"Operation","text":""},{"location":"API_references/core/operation/operation/#quam.core.operation.operation.Operation","title":"<code>Operation</code>","text":"Source code in <code>quam/core/operation/operation.py</code> <pre><code>class Operation:\n    def __init__(self, func: Callable):\n        \"\"\"\n        Initialize a quantum operation.\n\n        This is typically used implicitly from the decorator @operations_registry.register_operation.\n\n        Args:\n            func: The function implementing the operation\n        \"\"\"\n        self.func = func\n        self.properties = FunctionProperties.from_function(func)\n\n    def get_macro(self, quantum_component: QuantumComponent):\n        \"\"\"\n        Get the macro implementation for this operation from a quantum component.\n\n        Args:\n            quantum_component: Component to get the macro from\n\n        Returns:\n            The macro implementation\n\n        Raises:\n            KeyError: If the macro is not implemented for this component\n        \"\"\"\n        macros = quantum_component.get_macros()\n        try:\n            return macros[self.properties.name]\n        except KeyError:\n            raise KeyError(\n                f\"Operation '{self.properties.name}' is not implemented for \"\n                f\"{quantum_component.__class__.__name__}\"\n            )\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        Execute the operation on a quantum component.\n\n        Args:\n            *args: Positional arguments, first must be a quantum component\n            **kwargs: Keyword arguments for the operation\n\n        Returns:\n            Result of the macro execution\n\n        Raises:\n            ValueError: If first argument is not the correct quantum component type\n        \"\"\"\n        if not args:\n            raise ValueError(\n                f\"Operation {self.properties.name} requires at least one argument\"\n            )\n\n        quantum_component = args[0]\n        if not isinstance(quantum_component, self.properties.quantum_component_type):\n            raise ValueError(\n                f\"First argument to {self.properties.name} must be a \"\n                f\"{self.properties.quantum_component_type.__name__}, got \"\n                f\"{type(quantum_component).__name__}\"\n            )\n\n        quantum_component, *required_args = args\n        macro = self.get_macro(quantum_component)\n        return macro.apply(*required_args, **kwargs)\n</code></pre>"},{"location":"API_references/core/operation/operation/#quam.core.operation.operation.Operation.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Execute the operation on a quantum component.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments, first must be a quantum component</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the operation</p> <code>{}</code> <p>Returns:</p> Type Description <p>Result of the macro execution</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If first argument is not the correct quantum component type</p> Source code in <code>quam/core/operation/operation.py</code> <pre><code>def __call__(self, *args, **kwargs):\n    \"\"\"\n    Execute the operation on a quantum component.\n\n    Args:\n        *args: Positional arguments, first must be a quantum component\n        **kwargs: Keyword arguments for the operation\n\n    Returns:\n        Result of the macro execution\n\n    Raises:\n        ValueError: If first argument is not the correct quantum component type\n    \"\"\"\n    if not args:\n        raise ValueError(\n            f\"Operation {self.properties.name} requires at least one argument\"\n        )\n\n    quantum_component = args[0]\n    if not isinstance(quantum_component, self.properties.quantum_component_type):\n        raise ValueError(\n            f\"First argument to {self.properties.name} must be a \"\n            f\"{self.properties.quantum_component_type.__name__}, got \"\n            f\"{type(quantum_component).__name__}\"\n        )\n\n    quantum_component, *required_args = args\n    macro = self.get_macro(quantum_component)\n    return macro.apply(*required_args, **kwargs)\n</code></pre>"},{"location":"API_references/core/operation/operation/#quam.core.operation.operation.Operation.__init__","title":"<code>__init__(func)</code>","text":"<p>Initialize a quantum operation.</p> <p>This is typically used implicitly from the decorator @operations_registry.register_operation.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function implementing the operation</p> required Source code in <code>quam/core/operation/operation.py</code> <pre><code>def __init__(self, func: Callable):\n    \"\"\"\n    Initialize a quantum operation.\n\n    This is typically used implicitly from the decorator @operations_registry.register_operation.\n\n    Args:\n        func: The function implementing the operation\n    \"\"\"\n    self.func = func\n    self.properties = FunctionProperties.from_function(func)\n</code></pre>"},{"location":"API_references/core/operation/operation/#quam.core.operation.operation.Operation.get_macro","title":"<code>get_macro(quantum_component)</code>","text":"<p>Get the macro implementation for this operation from a quantum component.</p> <p>Parameters:</p> Name Type Description Default <code>quantum_component</code> <code>QuantumComponent</code> <p>Component to get the macro from</p> required <p>Returns:</p> Type Description <p>The macro implementation</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the macro is not implemented for this component</p> Source code in <code>quam/core/operation/operation.py</code> <pre><code>def get_macro(self, quantum_component: QuantumComponent):\n    \"\"\"\n    Get the macro implementation for this operation from a quantum component.\n\n    Args:\n        quantum_component: Component to get the macro from\n\n    Returns:\n        The macro implementation\n\n    Raises:\n        KeyError: If the macro is not implemented for this component\n    \"\"\"\n    macros = quantum_component.get_macros()\n    try:\n        return macros[self.properties.name]\n    except KeyError:\n        raise KeyError(\n            f\"Operation '{self.properties.name}' is not implemented for \"\n            f\"{quantum_component.__class__.__name__}\"\n        )\n</code></pre>"},{"location":"API_references/core/operation/operations_registry/","title":"Operations registry","text":""},{"location":"API_references/core/operation/operations_registry/#quam.core.operation.operations_registry.OperationsRegistry","title":"<code>OperationsRegistry</code>","text":"<p>               Bases: <code>UserDict</code></p> <p>A registry to store and manage operations.</p> Source code in <code>quam/core/operation/operations_registry.py</code> <pre><code>class OperationsRegistry(UserDict):\n    \"\"\"A registry to store and manage operations.\"\"\"\n\n    def register_operation(self, func: Optional[T]) -&gt; T:\n        \"\"\"\n        Register a function as an operation.\n\n        This method stores the function in the operations dictionary and returns a\n        wrapped version of the function that maintains the original function's\n        signature and docstring.\n\n        Args:\n            func (callable): The function to register as an operation.\n\n        Returns:\n            callable: The wrapped function.\n        \"\"\"\n        # Optionally add this later such that we can pass parameters to the decorator\n        # if func is None:\n        #     return functools.partial(self.register_operation)\n\n        operation = Operation(func)\n        operation = functools.update_wrapper(operation, func)\n\n        self[func.__name__] = operation\n\n        return operation  # type: ignore\n</code></pre>"},{"location":"API_references/core/operation/operations_registry/#quam.core.operation.operations_registry.OperationsRegistry.register_operation","title":"<code>register_operation(func)</code>","text":"<p>Register a function as an operation.</p> <p>This method stores the function in the operations dictionary and returns a wrapped version of the function that maintains the original function's signature and docstring.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to register as an operation.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <code>T</code> <p>The wrapped function.</p> Source code in <code>quam/core/operation/operations_registry.py</code> <pre><code>def register_operation(self, func: Optional[T]) -&gt; T:\n    \"\"\"\n    Register a function as an operation.\n\n    This method stores the function in the operations dictionary and returns a\n    wrapped version of the function that maintains the original function's\n    signature and docstring.\n\n    Args:\n        func (callable): The function to register as an operation.\n\n    Returns:\n        callable: The wrapped function.\n    \"\"\"\n    # Optionally add this later such that we can pass parameters to the decorator\n    # if func is None:\n    #     return functools.partial(self.register_operation)\n\n    operation = Operation(func)\n    operation = functools.update_wrapper(operation, func)\n\n    self[func.__name__] = operation\n\n    return operation  # type: ignore\n</code></pre>"},{"location":"API_references/examples/superconducting_qubits/components/","title":"Components","text":""},{"location":"API_references/examples/superconducting_qubits/components/#quam.examples.superconducting_qubits.components.Quam","title":"<code>Quam</code>","text":"<p>               Bases: <code>QuamRoot</code></p> <p>Example QUAM root component.</p> Source code in <code>quam/examples/superconducting_qubits/components.py</code> <pre><code>@quam_dataclass\nclass Quam(QuamRoot):\n    \"\"\"Example QUAM root component.\"\"\"\n\n    qubits: Dict[str, Transmon] = field(default_factory=dict)\n    wiring: dict = field(default_factory=dict)\n</code></pre>"},{"location":"API_references/examples/superconducting_qubits/components/#quam.examples.superconducting_qubits.components.Transmon","title":"<code>Transmon</code>","text":"<p>               Bases: <code>QuamComponent</code></p> <p>Example QUAM component for a transmon qubit.</p> Source code in <code>quam/examples/superconducting_qubits/components.py</code> <pre><code>@quam_dataclass\nclass Transmon(QuamComponent):\n    \"\"\"Example QUAM component for a transmon qubit.\"\"\"\n\n    id: Union[int, str]\n\n    xy: IQChannel = None\n    z: SingleChannel = None\n\n    resonator: InOutIQChannel = None\n\n    @property\n    def name(self):\n        return self.id if isinstance(self.id, str) else f\"q{self.id}\"\n</code></pre>"},{"location":"API_references/examples/superconducting_qubits/cz_implementation/","title":"Cz implementation","text":""},{"location":"API_references/examples/superconducting_qubits/cz_implementation/#quam.examples.superconducting_qubits.cz_implementation.CZImplementation","title":"<code>CZImplementation</code>","text":"<p>               Bases: <code>QubitPairMacro</code></p> <p>CZ Operation for a qubit pair</p> Source code in <code>quam/examples/superconducting_qubits/cz_implementation.py</code> <pre><code>@quam_dataclass\nclass CZImplementation(QubitPairMacro):\n    \"\"\"CZ Operation for a qubit pair\"\"\"\n\n    flux_pulse: Pulse\n\n    phase_shift_control: float = 0.0\n    phase_shift_target: float = 0.0\n\n    def apply(self, *, amplitude_scale=None):\n        self.flux_pulse.play(amplitude_scale=amplitude_scale)\n        self.qubit_control.align(self.qubit_target)\n        self.qubit_control.xy.frame_rotation(self.phase_shift_control)\n        self.qubit_target.xy.frame_rotation(self.phase_shift_target)\n        self.qubit_pair.align()\n</code></pre>"},{"location":"API_references/examples/superconducting_qubits/generate_superconducting_quam/","title":"Generate superconducting quam","text":""},{"location":"API_references/examples/superconducting_qubits/generate_superconducting_quam/#quam.examples.superconducting_qubits.generate_superconducting_quam.create_quam_superconducting_referenced","title":"<code>create_quam_superconducting_referenced(num_qubits)</code>","text":"<p>Create a QUAM with a number of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>num_qubits</code> <code>int</code> <p>Number of qubits to create.</p> required <p>Returns:</p> Name Type Description <code>QuamRoot</code> <code>QuamRoot</code> <p>A QUAM with the specified number of qubits.</p> Source code in <code>quam/examples/superconducting_qubits/generate_superconducting_quam.py</code> <pre><code>def create_quam_superconducting_referenced(num_qubits: int) -&gt; QuamRoot:\n    \"\"\"Create a QUAM with a number of qubits.\n\n    Args:\n        num_qubits (int): Number of qubits to create.\n\n    Returns:\n        QuamRoot: A QUAM with the specified number of qubits.\n    \"\"\"\n    machine = Quam()\n    machine.wiring = {\n        \"qubits\": {\n            f\"q{idx}\": {\n                \"port_I\": (\"con1\", 3 * idx + 3),\n                \"port_Q\": (\"con1\", 3 * idx + 4),\n                \"port_Z\": (\"con1\", 3 * idx + 5),\n            }\n            for idx in range(num_qubits)\n        },\n        \"feedline\": {\n            \"opx_output_I\": (\"con1\", 1),\n            \"opx_output_Q\": (\"con1\", 2),\n            \"opx_input_I\": (\"con1\", 1),\n            \"opx_input_Q\": (\"con1\", 2),\n        },\n    }\n\n    for idx in range(num_qubits):\n        # Create qubit components\n        transmon = Transmon(id=idx)\n        machine.qubits[transmon.name] = transmon\n\n        transmon.xy = IQChannel(\n            opx_output_I=f\"#/wiring/qubits/q{idx}/port_I\",\n            opx_output_Q=f\"#/wiring/qubits/q{idx}/port_Q\",\n            frequency_converter_up=FrequencyConverter(\n                mixer=Mixer(),\n                local_oscillator=LocalOscillator(power=10, frequency=6e9),\n            ),\n            intermediate_frequency=100e6,\n        )\n\n        transmon.z = SingleChannel(opx_output=f\"#/wiring/qubits/q{idx}/port_Z\")\n\n        transmon.resonator = InOutIQChannel(\n            id=idx,\n            opx_output_I=\"#/wiring/feedline/opx_output_I\",\n            opx_output_Q=\"#/wiring/feedline/opx_output_Q\",\n            opx_input_I=\"#/wiring/feedline/opx_input_I\",\n            opx_input_Q=\"#/wiring/feedline/opx_input_Q\",\n            frequency_converter_up=FrequencyConverter(\n                mixer=Mixer(), local_oscillator=LocalOscillator(power=10, frequency=6e9)\n            ),\n        )\n    return machine\n</code></pre>"},{"location":"API_references/examples/superconducting_qubits/generate_superconducting_quam/#quam.examples.superconducting_qubits.generate_superconducting_quam.get_quam_config","title":"<code>get_quam_config(config_path=None, config=None, auto_migrate=True)</code>","text":"<p>Retrieve the Quam configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[Path]</code> <p>Path to the configuration file. If not provided, the default path will be used.</p> <code>None</code> <code>config</code> <code>Optional[RawConfigType]</code> <p>Optional pre-loaded configuration data. If not provided, it will load and resolve references from the config file.</p> <code>None</code> <code>auto_migrate</code> <code>bool</code> <p>is it needed to automatically apply migrations to config</p> <code>True</code> <p>Returns:</p> Type Description <code>QuamConfig</code> <p>An instance of QuamConfig with the loaded configuration.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the configuration file cannot be read or if the configuration state is invalid.</p> Source code in <code>quam/config/resolvers.py</code> <pre><code>def get_quam_config(\n    config_path: Optional[Path] = None,\n    config: Optional[RawConfigType] = None,\n    auto_migrate: bool = True,\n) -&gt; QuamConfig:\n    \"\"\"Retrieve the Quam configuration.\n\n    Args:\n        config_path: Path to the configuration file.\n            If not provided, the default path will be used.\n        config: Optional pre-loaded configuration data. If not provided, it\n            will load and resolve references from the config file.\n        auto_migrate: is it needed to automatically apply migrations to config\n\n    Returns:\n        An instance of QuamConfig with the loaded configuration.\n\n    Raises:\n        RuntimeError: If the configuration file cannot be read or if the\n            configuration state is invalid.\n    \"\"\"\n    if config_path is None:\n        config_path = get_quam_config_path()\n\n    get_config_model_part = partial(\n        get_config_model,\n        config_path,\n        config_key=None,\n        config_class=QuamTopLevelConfig,\n        config=config,\n    )\n    error_msg = (\n        \"Quam was unable to load the config. It is recommend to run \"\n        '\"quam config\" to fix any file issues. If this problem persists, '\n        f'please delete \"{config_path}\" and retry running '\n        '\"quam config\"'\n    )\n    try:\n        model = get_config_model_part(raw_config_validators=[quam_version_validator])\n    except GreaterThanSupportedQuamConfigVersionError:\n        # Package is too old, config is too new - don't attempt migration\n        raise\n    except InvalidQuamConfigVersionError:\n        if not auto_migrate:\n            raise\n        logging.info(\"Automatically migrate to new quam config\")\n        try:\n            migrate_command([\"--config-path\", str(config_path)], standalone_mode=False)\n        except Exception as migrate_error:\n            # If migration fails, provide helpful context\n            error_detail = f\"Migration failed: {migrate_error.__class__.__name__}: {migrate_error}\"\n            raise RuntimeError(\n                f\"Failed to automatically migrate config. {error_detail}\\n\"\n                f\"Please manually upgrade your configuration or run `quam migrate`.\"\n            ) from migrate_error\n    except (RuntimeError, ValueError) as ex:\n        raise RuntimeError(error_msg) from ex\n    else:\n        return model.quam\n    # migrated\n    try:\n        model = get_config_model_part()\n    except (RuntimeError, ValueError) as ex:\n        raise RuntimeError(error_msg) from ex\n    return model.quam\n</code></pre>"},{"location":"API_references/examples/superconducting_qubits/operations/","title":"Operations","text":""},{"location":"API_references/serialisation/base/","title":"Base","text":""},{"location":"API_references/serialisation/base/#quam.serialisation.base.AbstractSerialiser","title":"<code>AbstractSerialiser</code>","text":"<p>Base class for serialisers.</p> Source code in <code>quam/serialisation/base.py</code> <pre><code>class AbstractSerialiser:\n    \"\"\"Base class for serialisers.\"\"\"\n\n    def save(\n        self,\n        path: Optional[Union[Path, str]],\n        quam_obj: Union[QuamRoot, QuamComponent],\n        content_mapping: Optional[Dict[str, str]] = None,\n        **kwargs,\n    ):\n        raise NotImplementedError\n\n    def load(\n        self,\n        path: Optional[Union[Path, str]] = None,\n    ):\n        raise NotImplementedError\n</code></pre>"},{"location":"API_references/serialisation/json/","title":"Json","text":""},{"location":"API_references/serialisation/json/#quam.serialisation.json.JSONSerialiser","title":"<code>JSONSerialiser</code>","text":"<p>               Bases: <code>AbstractSerialiser</code></p> <p>Serialiser for QUAM objects to JSON files, allowing for splitting content across multiple files.</p> <p>Attributes:</p> Name Type Description <code>default_filename</code> <code>str</code> <p>Default filename if saving all content to one file.</p> <code>default_foldername</code> <code>str</code> <p>Default folder name if splitting content.</p> <code>content_mapping</code> <code>Dict[str, str]</code> <p>Defines how to split QUAM object content into different files. Keys are component names (top-level keys in the QUAM object's dictionary representation), and values are the relative filenames they should be saved to. If empty, saves to a single file</p> <code>include_defaults</code> <code>bool</code> <p>Whether to include default values in the serialised output.</p> <code>state_path</code> <code>Optional[Path]</code> <p>A specific path set during initialisation to be used as the default save/load location, overriding environment variables and configuration files.</p> Source code in <code>quam/serialisation/json.py</code> <pre><code>class JSONSerialiser(AbstractSerialiser):\n    \"\"\"\n    Serialiser for QUAM objects to JSON files, allowing for splitting\n    content across multiple files.\n\n    Attributes:\n        default_filename (str): Default filename if saving all content to one file.\n        default_foldername (str): Default folder name if splitting content.\n        content_mapping (Dict[str, str]): Defines how to split QUAM\n            object content into different files. Keys are component names (top-level\n            keys in the QUAM object's dictionary representation), and values are the\n            relative filenames they should be saved to. If empty, saves to a single file\n        include_defaults (bool): Whether to include default values in the\n            serialised output.\n        state_path (Optional[Path]): A specific path set during initialisation\n            to be used as the default save/load location, overriding environment\n            variables and configuration files.\n    \"\"\"\n\n    default_filename: str = \"state.json\"\n    default_foldername: str = \"quam_state\"\n    content_mapping: Dict[str, str] = {}  # Expected final format: component -&gt; filename\n\n    def _resolve_include_defaults(self) -&gt; bool:\n        \"\"\"\n        Resolves the include_defaults setting using a priority chain.\n\n        Priority (highest to lowest):\n        1. Explicit parameter passed to save() (handled in save() method)\n        2. Instance value (self.include_defaults)\n        3. Config setting (quam.config.serialization.include_defaults)\n        4. Fallback to True (default behavior)\n\n        Returns:\n            bool: Whether to include default values in serialization.\n        \"\"\"\n        if self.include_defaults is not None:\n            return self.include_defaults\n\n        config = get_quam_config()\n        if config.serialization is not None:\n            return config.serialization.include_defaults\n        return True\n\n    @staticmethod\n    def _validate_and_convert_content_mapping(\n        mapping: Optional[Dict],\n    ) -&gt; Dict[str, str]:\n        \"\"\"\n        Validates the content_mapping format and converts the old format\n        (filename -&gt; components) to the new format (component -&gt; filename)\n        if necessary, issuing a warning.\n\n        Args:\n            mapping: The content mapping dictionary to validate/convert.\n\n        Returns:\n            The validated content mapping in the new format (component -&gt; filename).\n\n        Raises:\n            TypeError: If the mapping format is invalid (e.g., mixed value types).\n        \"\"\"\n        if mapping is None:\n            return {}\n\n        if not isinstance(mapping, dict):\n            raise TypeError(\n                f\"content_mapping must be a dictionary, got {type(mapping)}\"\n            )\n\n        if not mapping:\n            return {}\n\n        # Check the type of the first value to infer format\n        first_value = next(iter(mapping.values()))\n        is_old_format = isinstance(\n            first_value, (list, tuple, set, Sequence)\n        ) and not isinstance(first_value, str)\n        is_new_format = isinstance(first_value, str)\n\n        if is_old_format:\n            # Handle Old Format\n            new_mapping: Dict[str, str] = {}\n            conflicts: Dict[str, List[str]] = {}\n\n            for filename, components in mapping.items():\n                if not isinstance(filename, str):\n                    raise TypeError(\n                        \"Invalid key in old format content_mapping: Expected string \"\n                        f\"filename, got {type(filename)} ({filename})\"\n                    )\n                if not isinstance(\n                    components, (list, tuple, set, Sequence)\n                ) or isinstance(components, str):\n                    # Check for mixed formats within the old format assumption\n                    raise TypeError(\n                        \"Mixed value types detected in content_mapping. Assumed old\"\n                        \" format (filename -&gt; components) based on first value, but\"\n                        f\" found non-sequence value '{components}' for key\"\n                        f\" '{filename}'.\"\n                    )\n\n                for component in components:\n                    if not isinstance(component, str):\n                        raise TypeError(\n                            \"Invalid component name in old format content_mapping:\"\n                            f\" Expected string, got {type(component)} ({component}) in\"\n                            f\" list for file '{filename}'\"\n                        )\n                    if component in new_mapping:\n                        conflicts.setdefault(\n                            component, [new_mapping[component]]\n                        ).append(filename)\n                    new_mapping[component] = filename\n\n            # Issue warnings for conflicts\n            if conflicts:\n                conflict_details = \"; \".join(\n                    [\n                        f\"'{comp}': [{', '.join(map(repr, files))}]\"\n                        for comp, files in conflicts.items()\n                    ]\n                )\n                warnings.warn(\n                    \"Component conflicts detected in old format content_mapping. \"\n                    f\"Components assigned to multiple files: {conflict_details}. \"\n                    \"Using the last assignment found.\",\n                    UserWarning,\n                )\n\n            # Issue the main conversion warning\n            old_repr = repr(mapping)\n            new_repr = repr(new_mapping)\n            warnings.warn(\n                \"Detected deprecated content_mapping format (filename -&gt; components\"\n                \" list).\\nAutomatically converted to the new format (component -&gt;\"\n                f\" filename).\\nOld mapping: {old_repr}\\nConverted to:\"\n                f\" {new_repr}\\nPlease update your code to use the new format for future\"\n                \" compatibility.\",\n                DeprecationWarning,\n                stacklevel=3,  # Point warning towards the caller of __init__ or save\n            )\n            return new_mapping\n\n        elif is_new_format:\n            # Handle New Format\n            # Validate that all values are strings\n            for key, value in mapping.items():\n                if not isinstance(key, str):\n                    raise TypeError(\n                        \"Invalid key in new format content_mapping: Expected string\"\n                        f\" component name, got {type(key)} ({key})\"\n                    )\n                if not isinstance(value, str):\n                    # Check for mixed formats within the new format assumption\n                    raise TypeError(\n                        \"Mixed value types detected in content_mapping. Assumed new\"\n                        \" format (component -&gt; filename) based on first value, but\"\n                        f\" found non-string value '{value}' for key '{key}'.\"\n                    )\n            return mapping  # Already in the correct format\n        else:\n            # Handle Invalid Format\n            raise TypeError(\n                \"Invalid format for content_mapping. Values must be either all strings\"\n                \" (component -&gt; filename) or all sequences (filename -&gt; components),\"\n                f\" but found type {type(first_value)} for the first value.\"\n            )\n\n    def __init__(\n        self,\n        content_mapping: Optional[Dict] = None,  # Accept Dict initially for validation\n        include_defaults: Optional[bool] = None,\n        state_path: Optional[Union[str, Path]] = None,\n    ):\n        \"\"\"\n        Initialises the JSONSerialiser.\n\n        Args:\n            content_mapping: A specific content mapping to use. Can be in the old\n                (filename-&gt;components) or new (component-&gt;filename) format. If old\n                format is detected, a warning is issued and it's converted.\n                If None, uses the class default.\n            include_defaults: Whether to include fields set to their default\n                values in the output. If None, follows priority chain:\n                1. Config setting (quam.config.serialization.include_defaults)\n                2. Fallback to True (default behavior)\n            state_path: An optional default path for saving/loading state. If provided,\n                this path takes precedence over environment variables or configuration\n                files when determining the default save/load location.\n        \"\"\"\n        initial_mapping = (\n            content_mapping\n            if content_mapping is not None\n            else self.__class__.content_mapping\n        )\n        # Validate and potentially convert the mapping\n        self.content_mapping = self._validate_and_convert_content_mapping(\n            initial_mapping\n        )\n\n        self.include_defaults = include_defaults\n        # Store the state_path, resolving it if provided\n        self.state_path: Optional[Path] = (\n            Path(state_path).resolve() if state_path else None\n        )\n\n    def _save_dict_to_json(self, contents: Dict[str, Any], filepath: Path):\n        \"\"\"\n        Saves a dictionary to a specified JSON file.\n\n        Args:\n            contents: The dictionary to save.\n            filepath: The exact path to the JSON file.\n        \"\"\"\n        # Ensure parent directory exists just before writing\n        filepath.parent.mkdir(parents=True, exist_ok=True)\n        with filepath.open(\"w\", encoding=\"utf-8\") as f:\n            json.dump(contents, fp=f, indent=4, ensure_ascii=False)\n\n    def _save_split_content(\n        self,\n        full_contents: Dict[str, Any],\n        folder: Path,\n        content_mapping: Dict[str, str],  # Expects new format here\n    ):\n        \"\"\"\n        Saves dictionary content split across multiple files in a folder\n        based on the content_mapping (component -&gt; filename format).\n\n        Args:\n            full_contents: The complete dictionary of the QUAM object.\n            folder: The target directory to save files into.\n            content_mapping: Dictionary mapping component names (keys) to\n                relative filenames (values). Old format (filename -&gt; components)\n                is not supported in this method.\n        \"\"\"\n        remaining_contents = full_contents.copy()\n        # Stores filepath -&gt; content dict\n        files_to_save: Dict[Path, Dict[str, Any]] = {}\n\n        # Iterate through components and assign them to files based on mapping\n        mapped_keys = set()\n        for component_key, filename in content_mapping.items():\n            if component_key in remaining_contents:\n                # Resolve the filepath\n                component_file = Path(filename)\n                if component_file.is_absolute():\n                    warnings.warn(\n                        f\"Absolute path '{filename}' in content_mapping is ignored. \"\n                        f\"Using filename part only relative to '{folder}'.\",\n                        UserWarning,\n                    )\n                    component_filepath = folder / component_file.name\n                else:\n                    component_filepath = folder / component_file\n\n                # Add component to the dictionary for this file\n                if component_filepath not in files_to_save:\n                    files_to_save[component_filepath] = {}\n                files_to_save[component_filepath][component_key] = (\n                    remaining_contents.pop(component_key)\n                )\n                mapped_keys.add(component_key)\n            else:\n                warnings.warn(\n                    f\"Key '{component_key}' specified in content_mapping was not found \"\n                    \"in the QUAM object's data\",\n                    UserWarning,\n                )\n\n        # Save the collected components to their respective files\n        for filepath, file_contents in files_to_save.items():\n            self._save_dict_to_json(file_contents, filepath)\n\n        # Save any remaining contents to the default file\n        if remaining_contents:\n            default_filepath = folder / self.default_filename\n            self._save_dict_to_json(remaining_contents, default_filepath)\n\n    def save(\n        self,\n        quam_obj: QuamRoot,\n        path: Optional[Union[Path, str]] = None,\n        content_mapping: Optional[Dict] = None,  # Accept Dict initially\n        include_defaults: Optional[bool] = None,\n        ignore: Optional[Sequence[str]] = None,\n    ):\n        \"\"\"\n        Saves a QuamRoot object to JSON file(s).\n\n        Determines the save location and format (single file vs. split) based\n        on the provided path and content_mapping arguments, falling back to\n        instance/class defaults if arguments are None.\n\n        Args:\n            quam_obj: The QuamRoot object to serialise.\n            path: The target file or folder path. If None, uses default path logic\n                  (checking instance `state_path`, env var, config).\n            content_mapping: Overrides the instance's content_mapping for this save.\n                Can be in old or new format. If old format is provided, a warning is\n                issued and it's converted internally.\n            include_defaults: Overrides the instance's include_defaults for this save.\n            ignore: A sequence of top-level keys in the QUAM object to exclude\n                    from the saved output.\n        \"\"\"\n        # Validate and convert the provided content_mapping, or use the instance's\n        # (already validated) one\n        if content_mapping is not None:\n            current_content_mapping = self._validate_and_convert_content_mapping(\n                content_mapping\n            )\n        else:\n            current_content_mapping = self.content_mapping  # Already validated in init\n\n        # Resolve include_defaults with priority:\n        # parameter &gt; instance &gt; config &gt; fallback\n        if include_defaults is not None:\n            current_include_defaults = include_defaults\n        else:\n            current_include_defaults = self._resolve_include_defaults()\n\n        if path is None:\n            path = self._get_state_path()\n        path = Path(path)\n\n        # Get the dictionary representation of the object\n        contents_dict = quam_obj.to_dict(include_defaults=current_include_defaults)\n\n        # Apply ignore filter directly to the source dictionary before saving\n        # This modification is temporary for the save operation.\n        effective_contents = contents_dict.copy()\n        if ignore:\n            current_content_mapping = current_content_mapping.copy()\n            for key in ignore:\n                effective_contents.pop(key, None)  # Modify the copy\n                current_content_mapping.pop(key, None)\n\n        if path.suffix == \".json\":\n            # Target is a json file, save content to it\n            self._save_dict_to_json(effective_contents, path)\n        elif not path.suffix:\n            # Target is a directory, use split logic\n            self._save_split_content(\n                full_contents=effective_contents,\n                folder=path,\n                content_mapping=current_content_mapping,  # Pass validated mapping\n            )\n        else:\n            raise ValueError(\n                f\"Cannot save QUAM: Unsupported path suffix '{path.suffix}'\"\n            )\n\n    def _get_state_path(self) -&gt; Path:\n        \"\"\"\n        Determines the default path for saving/loading state.\n\n        Resolution order:\n        1. `self.state_path` (if set during `__init__`).\n        2. `QUAM_STATE_PATH` environment variable.\n        3. `state_path` from QUAM configuration (via `get_quam_config`).\n        4. Fallback to `default_foldername` or `default_filename` in the current\n           directory.\n\n        Returns:\n            The default Path object, resolved to an absolute path.\n        \"\"\"\n        # 1. Check instance path first\n        if self.state_path is not None:\n            return self.state_path.resolve()\n\n        # 2. Check environment variable\n        env_path = os.environ.get(\"QUAM_STATE_PATH\")\n        if env_path:\n            return Path(env_path).resolve()\n\n        # 3. Check configuration file\n        try:\n            cfg = get_quam_config()\n            if cfg and cfg.state_path is not None:\n                return Path(cfg.state_path).resolve()\n\n        except (AttributeError, FileNotFoundError):  # Catch potential errors\n            warnings.warn(\n                \"Could not determine state path from QUAM configuration. \"\n                \"Falling back to environment or default.\",\n                UserWarning,\n            )\n\n        # 4. No path found - Fallback to saving in current directory\n        # Decide on using the folder or single file default based on content_mapping\n        # Use the mapping already validated/converted in __init__\n        if self.content_mapping:\n            default_path = Path(self.default_foldername)\n            warnings.warn(\n                \"No state path found via init, environment, or config. Defaulting \"\n                f\"to folder '{default_path}' in the current directory because \"\n                \"content_mapping is defined.\",\n                UserWarning,\n            )\n        else:\n            default_path = Path(self.default_filename)\n            warnings.warn(\n                \"No state path found via init, environment, or config. Defaulting \"\n                f\"to file '{default_path}' in the current directory.\",\n                UserWarning,\n            )\n        return default_path.resolve()\n\n    def _load_from_file(self, filepath: Path) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]:\n        \"\"\"\n        Loads dictionary content from a single JSON file.\n\n        Args:\n            filepath: The exact path to the JSON file.\n\n        Returns:\n            Tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing the loaded\n                dictionary content and metadata dictionary including inferred\n                'content_mapping' (component -&gt; filename), 'default_filename',\n                and 'default_foldername'.\n\n        Raises:\n            TypeError: If the filepath does not have a .json suffix.\n            json.JSONDecodeError: If the file content is invalid JSON.\n            IOError: If the file cannot be read.\n        \"\"\"\n        if filepath.suffix.lower() != \".json\":\n            raise TypeError(f\"File {filepath} is not a JSON file.\")\n\n        try:\n            with filepath.open(\"r\", encoding=\"utf-8\") as f:\n                contents = json.load(f, object_hook=convert_int_keys)\n            if not isinstance(contents, dict):\n                raise TypeError(\n                    f\"File {filepath} does not contain a valid JSON dictionary.\",\n                )\n\n            metadata = {\n                \"content_mapping\": {},\n                \"default_filename\": filepath.name,\n                \"default_foldername\": None,\n            }\n            return contents, metadata\n        except json.JSONDecodeError as e:\n            raise json.JSONDecodeError(\n                f\"Error decoding JSON from {filepath}: {e.msg}\", e.doc, e.pos\n            ) from e\n        except IOError as e:\n            raise IOError(f\"Error reading file {filepath}: {e}\") from e\n        except Exception as e:  # Catch unexpected errors during loading\n            raise RuntimeError(\n                f\"An unexpected error occurred while loading {filepath}: {e}\"\n            ) from e\n\n    def _load_from_directory(\n        self, dirpath: Path\n    ) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]:\n        \"\"\"\n        Loads and merges content from all .json files in a directory and its\n        subdirectories. Infers the content mapping (component -&gt; filename).\n        Skips hidden directories (those starting with a dot).\n\n        Args:\n            dirpath: The path to the directory to load from.\n\n        Returns:\n            Tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing the merged\n                dictionary content and metadata dictionary including inferred\n                'content_mapping', 'default_filename', and 'default_foldername'.\n        \"\"\"\n        contents: Dict[str, Any] = {}\n        inferred_mapping: Dict[str, str] = {}  # component -&gt; relative_filename\n        metadata: Dict[str, Any] = {\n            \"content_mapping\": inferred_mapping,\n            \"default_filename\": None,\n            \"default_foldername\": str(dirpath.resolve()),\n        }\n\n        # Find all JSON files, excluding those in hidden directories (starting with dot)\n        found_files = []\n        for json_file in dirpath.rglob(\"*.json\"):\n            # Check if any part of the path contains a directory starting with dot\n            relative_path = json_file.relative_to(dirpath)\n            if any(part.startswith(\".\") for part in relative_path.parts[:-1]):\n                # Skip files in hidden directories\n                continue\n            found_files.append(json_file)\n\n        if not found_files:\n            warnings.warn(f\"No JSON files found in directory {dirpath}\", UserWarning)\n            return contents, metadata\n\n        processed_files_count = 0\n        for file in found_files:\n            try:\n                file_contents, _ = self._load_from_file(\n                    file\n                )  # Metadata from single file load is not needed here\n                if not file_contents:  # Skip empty files\n                    warnings.warn(\n                        f\"Skipping empty or invalid JSON file: {file}\", UserWarning\n                    )\n                    continue\n\n                relative_filepath = file.relative_to(dirpath).as_posix()\n                processed_files_count += 1\n\n                # Check for key conflicts before updating contents\n                conflicts = contents.keys() &amp; file_contents.keys()\n                if conflicts:\n                    conflict_details = {\n                        key: inferred_mapping[key]\n                        for key in conflicts\n                        if key in inferred_mapping\n                    }\n                    warnings.warn(\n                        f\"Key conflicts detected: Components {list(conflicts)} found in\"\n                        f\" '{relative_filepath}' overwrite existing definitions from\"\n                        f\" files {conflict_details}. Using definition from\"\n                        f\" '{relative_filepath}'.\",\n                        UserWarning,\n                    )\n                contents.update(file_contents)\n\n                # Update inferred mapping: component -&gt; relative_filepath\n                for key in file_contents.keys():\n                    # Overwrite mapping on conflict\n                    inferred_mapping[key] = relative_filepath\n\n                # Check if this file is the default file at the root level\n                if file.name == self.default_filename and file.parent == dirpath:\n                    metadata[\"default_filename\"] = file.name\n\n            except (\n                json.JSONDecodeError,\n                IOError,\n                TypeError,\n                RuntimeError,\n            ) as e:\n                warnings.warn(f\"Skipping file {file} due to error: {e}\", UserWarning)\n\n        if processed_files_count == 0 and found_files:\n            warnings.warn(\n                f\"Found {len(found_files)} JSON files in {dirpath}, but none contained\"\n                \" valid data.\",\n                UserWarning,\n            )\n\n        # Filter out inferred_mapping keys that point to the default file\n        inferred_mapping = {\n            key: value\n            for key, value in inferred_mapping.items()\n            if value != self.default_filename\n        }\n\n        metadata[\"content_mapping\"] = inferred_mapping\n        return contents, metadata\n\n    def load(\n        self,\n        path: Optional[Union[Path, str]] = None,\n    ) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]:\n        \"\"\"\n        Loads a QuamRoot object's dictionary representation from JSON file(s).\n\n        Determines the load path using the provided `path` argument or falls back\n        to default logic (instance `state_path`, env var, config). Loads from a\n        single file or merges from a directory (recursively).\n\n        Args:\n            path: The path to load from (file or directory). If None, uses the\n                  default state path logic via `_get_state_path()`.\n\n        Returns:\n            Tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing the dictionary\n                representation of the loaded QUAM object and metadata dictionary\n                including inferred 'content_mapping' (component -&gt; filename),\n                'default_filename', and 'default_foldername'.\n\n        Raises:\n            FileNotFoundError: If the resolved path does not exist.\n            ValueError: If the resolved path is neither a file nor a directory.\n        \"\"\"\n        load_path: Path\n        if path is None:\n            load_path = self._get_state_path()\n        else:\n            load_path = Path(path).resolve()\n\n        if not load_path.exists():\n            raise FileNotFoundError(f\"Path {load_path} not found, cannot load JSON.\")\n\n        contents: Dict[str, Any]\n        metadata: Dict[str, Any]\n\n        if load_path.is_file():\n            contents, metadata = self._load_from_file(load_path)\n        elif load_path.is_dir():\n            contents, metadata = self._load_from_directory(load_path)\n        else:\n            raise ValueError(f\"Path {load_path} is neither a valid file nor directory.\")\n\n        # Update the instance's content_mapping *only if* it wasn't explicitly set\n        # during initialization or via the save method argument override.\n        is_default_mapping = self.content_mapping == self.__class__.content_mapping\n        if is_default_mapping and \"content_mapping\" in metadata:\n            self.content_mapping = metadata[\"content_mapping\"]\n\n        return contents, metadata\n</code></pre>"},{"location":"API_references/serialisation/json/#quam.serialisation.json.JSONSerialiser.__init__","title":"<code>__init__(content_mapping=None, include_defaults=None, state_path=None)</code>","text":"<p>Initialises the JSONSerialiser.</p> <p>Parameters:</p> Name Type Description Default <code>content_mapping</code> <code>Optional[Dict]</code> <p>A specific content mapping to use. Can be in the old (filename-&gt;components) or new (component-&gt;filename) format. If old format is detected, a warning is issued and it's converted. If None, uses the class default.</p> <code>None</code> <code>include_defaults</code> <code>Optional[bool]</code> <p>Whether to include fields set to their default values in the output. If None, follows priority chain: 1. Config setting (quam.config.serialization.include_defaults) 2. Fallback to True (default behavior)</p> <code>None</code> <code>state_path</code> <code>Optional[Union[str, Path]]</code> <p>An optional default path for saving/loading state. If provided, this path takes precedence over environment variables or configuration files when determining the default save/load location.</p> <code>None</code> Source code in <code>quam/serialisation/json.py</code> <pre><code>def __init__(\n    self,\n    content_mapping: Optional[Dict] = None,  # Accept Dict initially for validation\n    include_defaults: Optional[bool] = None,\n    state_path: Optional[Union[str, Path]] = None,\n):\n    \"\"\"\n    Initialises the JSONSerialiser.\n\n    Args:\n        content_mapping: A specific content mapping to use. Can be in the old\n            (filename-&gt;components) or new (component-&gt;filename) format. If old\n            format is detected, a warning is issued and it's converted.\n            If None, uses the class default.\n        include_defaults: Whether to include fields set to their default\n            values in the output. If None, follows priority chain:\n            1. Config setting (quam.config.serialization.include_defaults)\n            2. Fallback to True (default behavior)\n        state_path: An optional default path for saving/loading state. If provided,\n            this path takes precedence over environment variables or configuration\n            files when determining the default save/load location.\n    \"\"\"\n    initial_mapping = (\n        content_mapping\n        if content_mapping is not None\n        else self.__class__.content_mapping\n    )\n    # Validate and potentially convert the mapping\n    self.content_mapping = self._validate_and_convert_content_mapping(\n        initial_mapping\n    )\n\n    self.include_defaults = include_defaults\n    # Store the state_path, resolving it if provided\n    self.state_path: Optional[Path] = (\n        Path(state_path).resolve() if state_path else None\n    )\n</code></pre>"},{"location":"API_references/serialisation/json/#quam.serialisation.json.JSONSerialiser.load","title":"<code>load(path=None)</code>","text":"<p>Loads a QuamRoot object's dictionary representation from JSON file(s).</p> <p>Determines the load path using the provided <code>path</code> argument or falls back to default logic (instance <code>state_path</code>, env var, config). Loads from a single file or merges from a directory (recursively).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Union[Path, str]]</code> <p>The path to load from (file or directory). If None, uses the   default state path logic via <code>_get_state_path()</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, Any], Dict[str, Any]]</code> <p>Tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing the dictionary representation of the loaded QUAM object and metadata dictionary including inferred 'content_mapping' (component -&gt; filename), 'default_filename', and 'default_foldername'.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the resolved path does not exist.</p> <code>ValueError</code> <p>If the resolved path is neither a file nor a directory.</p> Source code in <code>quam/serialisation/json.py</code> <pre><code>def load(\n    self,\n    path: Optional[Union[Path, str]] = None,\n) -&gt; Tuple[Dict[str, Any], Dict[str, Any]]:\n    \"\"\"\n    Loads a QuamRoot object's dictionary representation from JSON file(s).\n\n    Determines the load path using the provided `path` argument or falls back\n    to default logic (instance `state_path`, env var, config). Loads from a\n    single file or merges from a directory (recursively).\n\n    Args:\n        path: The path to load from (file or directory). If None, uses the\n              default state path logic via `_get_state_path()`.\n\n    Returns:\n        Tuple[Dict[str, Any], Dict[str, Any]]: A tuple containing the dictionary\n            representation of the loaded QUAM object and metadata dictionary\n            including inferred 'content_mapping' (component -&gt; filename),\n            'default_filename', and 'default_foldername'.\n\n    Raises:\n        FileNotFoundError: If the resolved path does not exist.\n        ValueError: If the resolved path is neither a file nor a directory.\n    \"\"\"\n    load_path: Path\n    if path is None:\n        load_path = self._get_state_path()\n    else:\n        load_path = Path(path).resolve()\n\n    if not load_path.exists():\n        raise FileNotFoundError(f\"Path {load_path} not found, cannot load JSON.\")\n\n    contents: Dict[str, Any]\n    metadata: Dict[str, Any]\n\n    if load_path.is_file():\n        contents, metadata = self._load_from_file(load_path)\n    elif load_path.is_dir():\n        contents, metadata = self._load_from_directory(load_path)\n    else:\n        raise ValueError(f\"Path {load_path} is neither a valid file nor directory.\")\n\n    # Update the instance's content_mapping *only if* it wasn't explicitly set\n    # during initialization or via the save method argument override.\n    is_default_mapping = self.content_mapping == self.__class__.content_mapping\n    if is_default_mapping and \"content_mapping\" in metadata:\n        self.content_mapping = metadata[\"content_mapping\"]\n\n    return contents, metadata\n</code></pre>"},{"location":"API_references/serialisation/json/#quam.serialisation.json.JSONSerialiser.save","title":"<code>save(quam_obj, path=None, content_mapping=None, include_defaults=None, ignore=None)</code>","text":"<p>Saves a QuamRoot object to JSON file(s).</p> <p>Determines the save location and format (single file vs. split) based on the provided path and content_mapping arguments, falling back to instance/class defaults if arguments are None.</p> <p>Parameters:</p> Name Type Description Default <code>quam_obj</code> <code>QuamRoot</code> <p>The QuamRoot object to serialise.</p> required <code>path</code> <code>Optional[Union[Path, str]]</code> <p>The target file or folder path. If None, uses default path logic   (checking instance <code>state_path</code>, env var, config).</p> <code>None</code> <code>content_mapping</code> <code>Optional[Dict]</code> <p>Overrides the instance's content_mapping for this save. Can be in old or new format. If old format is provided, a warning is issued and it's converted internally.</p> <code>None</code> <code>include_defaults</code> <code>Optional[bool]</code> <p>Overrides the instance's include_defaults for this save.</p> <code>None</code> <code>ignore</code> <code>Optional[Sequence[str]]</code> <p>A sequence of top-level keys in the QUAM object to exclude     from the saved output.</p> <code>None</code> Source code in <code>quam/serialisation/json.py</code> <pre><code>def save(\n    self,\n    quam_obj: QuamRoot,\n    path: Optional[Union[Path, str]] = None,\n    content_mapping: Optional[Dict] = None,  # Accept Dict initially\n    include_defaults: Optional[bool] = None,\n    ignore: Optional[Sequence[str]] = None,\n):\n    \"\"\"\n    Saves a QuamRoot object to JSON file(s).\n\n    Determines the save location and format (single file vs. split) based\n    on the provided path and content_mapping arguments, falling back to\n    instance/class defaults if arguments are None.\n\n    Args:\n        quam_obj: The QuamRoot object to serialise.\n        path: The target file or folder path. If None, uses default path logic\n              (checking instance `state_path`, env var, config).\n        content_mapping: Overrides the instance's content_mapping for this save.\n            Can be in old or new format. If old format is provided, a warning is\n            issued and it's converted internally.\n        include_defaults: Overrides the instance's include_defaults for this save.\n        ignore: A sequence of top-level keys in the QUAM object to exclude\n                from the saved output.\n    \"\"\"\n    # Validate and convert the provided content_mapping, or use the instance's\n    # (already validated) one\n    if content_mapping is not None:\n        current_content_mapping = self._validate_and_convert_content_mapping(\n            content_mapping\n        )\n    else:\n        current_content_mapping = self.content_mapping  # Already validated in init\n\n    # Resolve include_defaults with priority:\n    # parameter &gt; instance &gt; config &gt; fallback\n    if include_defaults is not None:\n        current_include_defaults = include_defaults\n    else:\n        current_include_defaults = self._resolve_include_defaults()\n\n    if path is None:\n        path = self._get_state_path()\n    path = Path(path)\n\n    # Get the dictionary representation of the object\n    contents_dict = quam_obj.to_dict(include_defaults=current_include_defaults)\n\n    # Apply ignore filter directly to the source dictionary before saving\n    # This modification is temporary for the save operation.\n    effective_contents = contents_dict.copy()\n    if ignore:\n        current_content_mapping = current_content_mapping.copy()\n        for key in ignore:\n            effective_contents.pop(key, None)  # Modify the copy\n            current_content_mapping.pop(key, None)\n\n    if path.suffix == \".json\":\n        # Target is a json file, save content to it\n        self._save_dict_to_json(effective_contents, path)\n    elif not path.suffix:\n        # Target is a directory, use split logic\n        self._save_split_content(\n            full_contents=effective_contents,\n            folder=path,\n            content_mapping=current_content_mapping,  # Pass validated mapping\n        )\n    else:\n        raise ValueError(\n            f\"Cannot save QUAM: Unsupported path suffix '{path.suffix}'\"\n        )\n</code></pre>"},{"location":"API_references/serialisation/json/#quam.serialisation.json.convert_int_keys","title":"<code>convert_int_keys(obj)</code>","text":"<p>JSON object hook to convert dictionary keys that are strings representing integers back into integers during loading.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object being processed by the JSON decoder.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The processed object, with relevant keys converted to integers.</p> Source code in <code>quam/serialisation/json.py</code> <pre><code>def convert_int_keys(obj: Any) -&gt; Any:\n    \"\"\"\n    JSON object hook to convert dictionary keys that are strings\n    representing integers back into integers during loading.\n\n    Args:\n        obj: The object being processed by the JSON decoder.\n\n    Returns:\n        The processed object, with relevant keys converted to integers.\n    \"\"\"\n    if not isinstance(obj, dict):\n        return obj\n\n    new_obj = {}\n    for key, value in obj.items():\n        try:\n            # Attempt to convert key to int if it represents a digit\n            int_key = int(key)\n            new_obj[int_key] = value\n        except ValueError:\n            # Keep the original string key if conversion fails\n            new_obj[key] = value\n    return new_obj\n</code></pre>"},{"location":"API_references/utils/config/","title":"Config","text":""},{"location":"API_references/utils/config/#quam.utils.config.generate_config_final_actions","title":"<code>generate_config_final_actions(qua_config)</code>","text":"<p>Performs final actions on the generated qua config.</p> <p>This is called at the end of <code>QuamRoot.generate_config()</code>. In this case it ensures that all analog outputs and inputs have a defined offset</p> <p>Parameters:</p> Name Type Description Default <code>qua_config</code> <code>dict</code> <p>The generated qua config.</p> required Source code in <code>quam/utils/config.py</code> <pre><code>def generate_config_final_actions(qua_config):\n    \"\"\"Performs final actions on the generated qua config.\n\n    This is called at the end of `QuamRoot.generate_config()`.\n    In this case it ensures that all analog outputs and inputs have a defined offset\n\n    Args:\n        qua_config (dict): The generated qua config.\n    \"\"\"\n    # Add default dc offset 0V to all analog outputs and inputs if not set\n    for controller_cfg in qua_config[\"controllers\"].values():\n        for fem in controller_cfg.get(\"fems\", {}).values():\n            if fem.get(\"type\") != \"LF\":\n                continue\n            for analog_output in fem.get(\"analog_outputs\", {}).values():\n                analog_output.setdefault(\"offset\", 0.0)\n            for analog_input in fem.get(\"analog_inputs\", {}).values():\n                analog_input.setdefault(\"offset\", 0.0)\n\n        if \"analog_outputs\" in controller_cfg:\n            for analog_output in controller_cfg[\"analog_outputs\"].values():\n                analog_output.setdefault(\"offset\", 0.0)\n        if \"analog_inputs\" in controller_cfg:\n            for analog_input in controller_cfg[\"analog_inputs\"].values():\n                analog_input.setdefault(\"offset\", 0.0)\n</code></pre>"},{"location":"API_references/utils/dataclass/","title":"Dataclass","text":""},{"location":"API_references/utils/dataclass/#quam.utils.dataclass.REQUIRED","title":"<code>REQUIRED</code>","text":"<p>Flag used by <code>quam_dataclass</code> when a required dataclass arg needs a kwarg</p> Source code in <code>quam/utils/dataclass.py</code> <pre><code>class REQUIRED:\n    \"\"\"Flag used by `quam_dataclass` when a required dataclass arg needs a kwarg\"\"\"\n\n    ...\n</code></pre>"},{"location":"API_references/utils/dataclass/#quam.utils.dataclass.dataclass_field_has_default","title":"<code>dataclass_field_has_default(field)</code>","text":"<p>Check if a dataclass field has a default value</p> Source code in <code>quam/utils/dataclass.py</code> <pre><code>def dataclass_field_has_default(field: dataclasses.field) -&gt; bool:\n    \"\"\"Check if a dataclass field has a default value\"\"\"\n    if field.default is not dataclasses.MISSING:\n        return True\n    elif field.default_factory is not dataclasses.MISSING:\n        return True\n    return False\n</code></pre>"},{"location":"API_references/utils/dataclass/#quam.utils.dataclass.get_dataclass_attr_annotations","title":"<code>get_dataclass_attr_annotations(cls_or_obj)</code>","text":"<p>Get the attributes and annotations of a dataclass</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>The dataclass to get the attributes of.</p> required <p>Returns:</p> Type Description <code>Dict[str, Dict[str, type]]</code> <p>A dictionary where the keys are \"required\", \"optional\" and \"allowed\". - \"required\": Required attributes of the class. - \"optional\": Optional attributes of the class, i.e. with a default value. - \"allowed\": allowed attributes of the class := \"required\" + \"optional\".</p> <code>Dict[str, Dict[str, type]]</code> <p>For each key, the values are dictionaries with the attribute names as keys</p> <code>Dict[str, Dict[str, type]]</code> <p>and the attribute types as values.</p> Source code in <code>quam/utils/dataclass.py</code> <pre><code>def get_dataclass_attr_annotations(\n    cls_or_obj: Union[type, object],\n) -&gt; Dict[str, Dict[str, type]]:\n    \"\"\"Get the attributes and annotations of a dataclass\n\n    Args:\n        cls: The dataclass to get the attributes of.\n\n    Returns:\n        A dictionary where the keys are \"required\", \"optional\" and \"allowed\".\n            - \"required\": Required attributes of the class.\n            - \"optional\": Optional attributes of the class, i.e. with a default value.\n            - \"allowed\": allowed attributes of the class := \"required\" + \"optional\".\n        For each key, the values are dictionaries with the attribute names as keys\n        and the attribute types as values.\n    \"\"\"\n\n    annotated_attrs = get_type_hints(cls_or_obj)\n\n    annotated_attrs.pop(\"_root\", None)\n    annotated_attrs.pop(\"_references\", None)\n    annotated_attrs.pop(\"_skip_attrs\", None)\n    annotated_attrs.pop(\"parent\", None)\n    annotated_attrs.pop(\"config_settings\", None)\n    annotated_attrs.pop(\"_value_annotation\", None)\n    annotated_attrs.pop(\"_initialized\", None)\n\n    attr_annotations = {\"required\": {}, \"optional\": {}}\n    for attr, attr_type in annotated_attrs.items():\n        if getattr(attr_type, \"__origin__\", None) == ClassVar:\n            continue\n        # TODO Try to combine with third elif statement\n        if getattr(cls_or_obj, attr, None) is REQUIRED:  # See \"patch_dataclass()\"\n            if attr not in getattr(cls_or_obj, \"__dataclass_fields__\", {}):\n                attr_annotations[\"required\"][attr] = attr_type\n            else:\n                field_attr = cls_or_obj.__dataclass_fields__[attr]\n                if field_attr.default_factory is not dataclasses.MISSING:\n                    attr_annotations[\"optional\"][attr] = attr_type\n                else:\n                    attr_annotations[\"required\"][attr] = attr_type\n        elif hasattr(cls_or_obj, attr):\n            attr_annotations[\"optional\"][attr] = attr_type\n        elif attr in getattr(cls_or_obj, \"__dataclass_fields__\", {}):\n            data_field = cls_or_obj.__dataclass_fields__[attr]\n            if data_field.default_factory is not dataclasses.MISSING:\n                attr_annotations[\"optional\"][attr] = attr_type\n            else:\n                attr_annotations[\"required\"][attr] = attr_type\n        else:\n            attr_annotations[\"required\"][attr] = attr_type\n    attr_annotations[\"allowed\"] = {\n        **attr_annotations[\"required\"],\n        **attr_annotations[\"optional\"],\n    }\n    return attr_annotations\n</code></pre>"},{"location":"API_references/utils/dataclass/#quam.utils.dataclass.handle_inherited_required_fields","title":"<code>handle_inherited_required_fields(cls)</code>","text":"<p>Adds a default REQUIRED flag for dataclass fields when necessary</p> <p>see quam_dataclass docs for details</p> Source code in <code>quam/utils/dataclass.py</code> <pre><code>def handle_inherited_required_fields(cls):\n    \"\"\"Adds a default REQUIRED flag for dataclass fields when necessary\n\n    see quam_dataclass docs for details\n    \"\"\"\n    if not is_dataclass(cls):\n        return\n\n    # Check if dataclass has fields with default value\n    optional_fields = [\n        field.name\n        for field in dataclasses.fields(cls)\n        if dataclass_field_has_default(field)\n    ]\n    if not optional_fields:\n        # All fields of the dataclass are required, we don't have to handle situations\n        # where the parent class has fields with default values and the subclass has\n        # required fields.\n        return\n\n    # Check if class (not parents) has required fields\n    for attr, attr_type in cls.__annotations__.items():\n        if attr in cls.__dict__:\n            continue\n        if attr in optional_fields:\n            continue\n        if getattr(attr_type, \"__origin__\", None) is ClassVar:\n            continue\n        setattr(cls, attr, REQUIRED)\n</code></pre>"},{"location":"API_references/utils/dataclass/#quam.utils.dataclass.patch_dataclass","title":"<code>patch_dataclass(module_name)</code>","text":"<p>Patch Python dataclass within a file to allow subclasses have args</p> Note <p>Patch is only applied when Python &lt; 3.10.</p> Note <p>This function should be called at the top of a file, before dataclasses are defined: <pre><code>patch_dataclass(__name__)  # Ensure dataclass \"kw_only\" also works with python &lt; 3.10\n</code></pre></p> <p>Prior to Python 3.10, it was not possible for a dataclass to be a subclass of another dataclass when - the parent dataclass has an arg with default - the child dataclass has a required arg</p> <p>From Python 3.10, this was fixed by including the flag @dataclass(kw_only=True). To ensure QUAM remains compatible with Python &lt;3.10, we include a method to patch the dataclass such that it still works in the case described above.</p> <p>We achieve this by first checking if the above condition is met. If so, all the args without a default value receive a default REQUIRED flag. The post_init method is then overridden such that an error is raised whenever an attribute still has the REQUIRED flag after instantiation.</p> Note <p>The python dataclass is patched in a non-standard way by calling <code>setattr</code> on the module. This is done to ensure that the patch is not recognized by any static analysis tools, such as mypy. This is necessary as mypy otherwise will no longer recognize the dataclass as a dataclass.</p> Source code in <code>quam/utils/dataclass.py</code> <pre><code>def patch_dataclass(module_name):\n    \"\"\"Patch Python dataclass within a file to allow subclasses have args\n\n    Note:\n        Patch is only applied when Python &lt; 3.10.\n\n    Note:\n        This function should be called at the top of a file, before dataclasses are\n        defined:\n        ```\n        patch_dataclass(__name__)  # Ensure dataclass \"kw_only\" also works with python &lt; 3.10\n        ```\n\n    Prior to Python 3.10, it was not possible for a dataclass to be a subclass of\n    another dataclass when\n    - the parent dataclass has an arg with default\n    - the child dataclass has a required arg\n\n    From Python 3.10, this was fixed by including the flag @dataclass(kw_only=True).\n    To ensure QUAM remains compatible with Python &lt;3.10, we include a method to patch\n    the dataclass such that it still works in the case described above.\n\n    We achieve this by first checking if the above condition is met. If so, all the\n    args without a default value receive a default REQUIRED flag. The post_init method\n    is then overridden such that an error is raised whenever an attribute still has\n    the REQUIRED flag after instantiation.\n\n    Note:\n        The python dataclass is patched in a non-standard way by calling `setattr`\n        on the module. This is done to ensure that the patch is not recognized by any\n        static analysis tools, such as mypy. This is necessary as mypy otherwise will\n        no longer recognize the dataclass as a dataclass.\n    \"\"\"\n    DeprecationWarning(\n        \"patch_dataclass is deprecated and will be removed in QUAM v1.0. \"\n        \"Please use 'from quam.core import quam_dataclass' as a decorator instead of \"\n        \"the regular Python dataclass.\"\n    )\n    if sys.version_info.minor &lt; 10:\n        setattr(sys.modules[module_name], \"dataclass\", _quam_patched_dataclass)\n</code></pre>"},{"location":"API_references/utils/exceptions/","title":"Exceptions","text":""},{"location":"API_references/utils/exceptions/#quam.utils.exceptions.InvalidReferenceError","title":"<code>InvalidReferenceError</code>","text":"<p>               Bases: <code>LookupError</code></p> <p>Exception raised when a reference cannot be resolved.</p> Source code in <code>quam/utils/exceptions.py</code> <pre><code>class InvalidReferenceError(LookupError):\n    \"\"\"Exception raised when a reference cannot be resolved.\"\"\"\n\n    pass\n</code></pre>"},{"location":"API_references/utils/general/","title":"General","text":""},{"location":"API_references/utils/general/#quam.utils.general.get_class_from_path","title":"<code>get_class_from_path(class_str)</code>","text":"<p>Extract the class from a class path.</p> Example <pre><code>from quam.components import Mixer\nassert get_class_from_path(\"quam.components.hardware.Mixer\") == Mixer\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>class_str</code> <p>The class path, e.g. \"quam.components.hardware.Mixer\"</p> required <p>Returns:</p> Type Description <code>type</code> <p>Class object corresponding to the class path.</p> Source code in <code>quam/utils/general.py</code> <pre><code>def get_class_from_path(class_str) -&gt; type:\n    \"\"\"Extract the class from a class path.\n\n    Example:\n        ```\n        from quam.components import Mixer\n        assert get_class_from_path(\"quam.components.hardware.Mixer\") == Mixer\n        ```\n\n    Args:\n        class_str: The class path, e.g. \"quam.components.hardware.Mixer\"\n\n    Returns:\n        Class object corresponding to the class path.\n    \"\"\"\n    try:\n        module_path, class_name = class_str.rsplit(\".\", 1)\n    except ValueError as e:\n        raise ValueError(\n            \"Could not extract module and class name from class path, be sure that the \"\n            \"class path is of the form '{module_name}.{class_name}'. \"\n            f\"class_str: '{class_str}'\"\n        ) from e\n    module = importlib.import_module(module_path)\n    quam_class = getattr(module, class_name)\n    return quam_class\n</code></pre>"},{"location":"API_references/utils/general/#quam.utils.general.get_full_class_path","title":"<code>get_full_class_path(cls_or_obj)</code>","text":"<p>Returns the full path of a class or object, including the module name.</p> <p>Example: <pre><code>from quam.components import Mixer\nassert get_full_class_path(Mixer) == \"quam.components.hardware.Mixer\"\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>cls_or_obj</code> <code>Union[type, object]</code> <p>The class or object to get the path of.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The full path of the class or object. Generally this is of the form</p> <code>str</code> <p>\"module_name.class_name\".</p> Source code in <code>quam/utils/general.py</code> <pre><code>def get_full_class_path(cls_or_obj: Union[type, object]) -&gt; str:\n    \"\"\"Returns the full path of a class or object, including the module name.\n\n    Example:\n    ```\n    from quam.components import Mixer\n    assert get_full_class_path(Mixer) == \"quam.components.hardware.Mixer\"\n    ```\n\n    Args:\n        cls_or_obj: The class or object to get the path of.\n\n    Returns:\n        The full path of the class or object. Generally this is of the form\n        \"module_name.class_name\".\n\n    Warnings:\n        If the module name cannot be determined, a warning is raised.\n    \"\"\"\n    if isclass(cls_or_obj):\n        class_name = cls_or_obj.__qualname__\n    else:\n        class_name = cls_or_obj.__class__.__qualname__\n\n    module_name = cls_or_obj.__module__\n    if module_name == \"__main__\" or module_name is None:\n        warnings.warn(\n            f\"Could not determine the module of {class_name}, this may cause issues\"\n            \" when trying to load QUAM from a file. Please ensure that all QUAM\"\n            \" classes are defined in a Python module\"\n        )\n        return class_name\n    else:\n        return f\"{module_name}.{class_name}\"\n</code></pre>"},{"location":"API_references/utils/general/#quam.utils.general.validate_obj_type","title":"<code>validate_obj_type(elem, required_type, allow_none=True, str_repr='')</code>","text":"<p>Validate whether the object is an instance of the correct type</p> <p>References (strings starting with \"#\") are not checked. None is always allowed.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>Any</code> <p>The object to validate the type of.</p> required <code>required_type</code> <code>type</code> <p>The required type of the object.</p> required <code>allow_none</code> <code>bool</code> <p>Whether None is allowed as a value even if it's the wrong type.</p> <code>True</code> <code>str_repr</code> <code>str</code> <p>A string representation of the object, used for error messages.</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>quam/utils/general.py</code> <pre><code>def validate_obj_type(\n    elem: Any, required_type: type, allow_none: bool = True, str_repr: str = \"\"\n) -&gt; None:\n    \"\"\"Validate whether the object is an instance of the correct type\n\n    References (strings starting with \"#\") are not checked.\n    None is always allowed.\n\n    Args:\n        elem: The object to validate the type of.\n        required_type: The required type of the object.\n        allow_none: Whether None is allowed as a value even if it's the wrong type.\n        str_repr: A string representation of the object, used for error messages.\n\n    Returns:\n        None\n\n    Raises:\n        TypeError if the type of the attribute is not the required type\n    \"\"\"\n    # Do not check type if the value is a reference\n    if string_reference.is_reference(elem):\n        return\n    if elem is None and allow_none:\n        return\n    try:\n        check_type(elem, required_type)\n    except TypeCheckError as e:\n        if elem is None:\n            raise TypeError(\n                f\"None is not allowed for required attribute {str_repr}\"\n            ) from e\n        else:\n            raise TypeError(\n                \"Wrong object type found during validation.\\n\"\n                f\"Path: {str_repr}\\n\"\n                f\"Required type: {required_type}\\n\"\n                f\"Actual type: {type(elem)}\\n\"\n                f\"value of actual type: {elem}\"\n            ) from e\n</code></pre>"},{"location":"API_references/utils/pulse/","title":"Pulse","text":""},{"location":"API_references/utils/pulse/#quam.utils.pulse.add_amplitude_scale_to_pulse_name","title":"<code>add_amplitude_scale_to_pulse_name(pulse_name, amplitude_scale)</code>","text":"<p>Adds an amplitude scale to a pulse name.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_name</code> <code>str</code> <p>The name of the pulse.</p> required <code>amplitude_scale</code> <code>Optional[Union[ScalarFloat, Sequence[ScalarFloat]]]</code> <p>The amplitude scale to add to the pulse name. If None, the pulse name is returned unchanged.</p> required <p>Returns:</p> Type Description <code>Union[str, tuple]</code> <p>amplitude_scale == None \u2192 pulse_name</p> <code>Union[str, tuple]</code> <p>amplitude_scale == float \u2192 pulse_name * qua.amp(amplitude_scale)</p> <code>Union[str, tuple]</code> <p>amplitude_scale == list[float] \u2192 pulse_name * qua.amp(*amplitude_scale)</p> Source code in <code>quam/utils/pulse.py</code> <pre><code>def add_amplitude_scale_to_pulse_name(\n    pulse_name: str,\n    amplitude_scale: Optional[Union[ScalarFloat, Sequence[ScalarFloat]]],\n) -&gt; Union[str, tuple]:\n    \"\"\"Adds an amplitude scale to a pulse name.\n\n    Args:\n        pulse_name: The name of the pulse.\n        amplitude_scale: The amplitude scale to add to the pulse name.\n            If None, the pulse name is returned unchanged.\n\n    Returns:\n        amplitude_scale == None \u2192 pulse_name\n        amplitude_scale == float \u2192 pulse_name * qua.amp(amplitude_scale)\n        amplitude_scale == list[float] \u2192 pulse_name * qua.amp(*amplitude_scale)\n    \"\"\"\n    if amplitude_scale is None:\n        return pulse_name\n\n    try:\n        check_type(amplitude_scale, Sequence[ScalarFloat])\n        return pulse_name * qua.amp(*amplitude_scale)\n    except TypeCheckError:\n        pass\n\n    try:\n        check_type(amplitude_scale, ScalarFloat)\n        return pulse_name * qua.amp(amplitude_scale)\n    except TypeCheckError:\n        pass\n\n    raise ValueError(f\"Invalid amplitude scale: {amplitude_scale}\")\n</code></pre>"},{"location":"API_references/utils/pulse/#quam.utils.pulse.pulse_str_to_axis_axis_angle","title":"<code>pulse_str_to_axis_axis_angle(pulse_str)</code>","text":"<p>Converts a pulse string to a tuple of axis and angle.</p> <p>Parameters:</p> Name Type Description Default <code>pulse_str</code> <code>str</code> <p>A pulse string, e.g. 'X90'.</p> required <p>Returns:</p> Type Description <code>Tuple[str, int]</code> <p>Tuple[str, int]: A tuple containing the axis (one of \"X\", \"Y\" or \"Z\") and the rotation angle in degrees.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the pulse string is incorrect</p> Source code in <code>quam/utils/pulse.py</code> <pre><code>def pulse_str_to_axis_axis_angle(pulse_str: str) -&gt; Tuple[str, int]:\n    \"\"\"Converts a pulse string to a tuple of axis and angle.\n\n    Args:\n        pulse_str: A pulse string, e.g. 'X90'.\n\n    Returns:\n        Tuple[str, int]: A tuple containing the axis (one of \"X\", \"Y\" or \"Z\")\n            and the rotation angle in degrees.\n\n    Raises:\n        ValueError: If the pulse string is incorrect\n    \"\"\"\n    if pulse_str[0] not in \"XYZ\":\n        raise ValueError(f\"Invalid pulse string: {pulse_str}\")\n\n    axis = pulse_str[0]\n    angle_str = pulse_str[1:]\n\n    if angle_str[0] == \"m\":\n        angle_str = f\"-{angle_str[1:]}\"\n\n    angle = int(angle_str)\n\n    return axis, angle\n</code></pre>"},{"location":"API_references/utils/qua_types/","title":"Qua types","text":""},{"location":"API_references/utils/reference_class/","title":"Reference class","text":""},{"location":"API_references/utils/reference_class/#quam.utils.reference_class.ReferenceClass","title":"<code>ReferenceClass</code>","text":"<p>Class whose attributes can by references to other attributes</p> Source code in <code>quam/utils/reference_class.py</code> <pre><code>class ReferenceClass:\n    \"\"\"Class whose attributes can by references to other attributes\"\"\"\n\n    _initialized: ClassVar[bool] = False\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post init function\"\"\"\n        self._initialized = True\n\n    def _get_referenced_value(self, attr: str) -&gt; Any:\n        \"\"\"Get the value of an attribute by reference\n\n        This function should generally be overwritten by subclasses\n        \"\"\"\n        raise NotImplementedError\n\n    def _is_reference(self, attr: str) -&gt; bool:\n        \"\"\"Check if an attribute is a reference\n\n        This function should generally be overwritten by subclasses\n        \"\"\"\n        raise NotImplementedError\n\n    def get_raw_value(self, attr: str) -&gt; Any:\n        \"\"\"Get the value of an attribute without following references.\n\n        If the value is a reference, the reference string is returned\n        \"\"\"\n        return super().__getattribute__(attr)\n\n    def get_unreferenced_value(self, attr: str) -&gt; Any:\n        \"\"\"Deprecated method. Use `get_raw_value` instead.\"\"\"\n        warnings.warn(\n            \"get_unreferenced_value is deprecated. Use get_raw_value instead.\",\n            DeprecationWarning,\n        )\n        return self.get_raw_value(attr)\n\n    def __getattribute__(self, attr: str) -&gt; Any:\n        attr_val = super().__getattribute__(attr)\n\n        if attr in [\"_is_reference\", \"_get_referenced_value\", \"__post_init__\"]:\n            return attr_val\n\n        try:\n            if self._is_reference(attr_val):\n                return self._get_referenced_value(attr_val)\n            return attr_val\n        except InvalidReferenceError as e:\n            raise e\n        except Exception as e:\n            error_msg = str(e)\n            if \"is not a valid reference\" in error_msg:\n                raise e\n            return attr_val\n\n    def _is_valid_setattr(\n        self, attr: str, value: Any, error_on_False: bool = False\n    ) -&gt; bool:\n        \"\"\"Check if an attribute can be set to a value\n\n        This will be called by __setattr__ to check if the attribute can be set to the\n        given value.\n\n        Args:\n            attr: The attribute to set\n            value: The value to set the attribute to\n            error_on_False: If True, raise an error if the attribute cannot be set to\n                the value. If False, return False if the attribute cannot be set to the\n                value.\n\n        Returns:\n            True if\n            - The new value is None\n            - The attribute does not exist yet\n            - The attribute's previous value is not a reference\n            - The new value is a reference\n            False otherwise, in particular if the previous value is a reference and the\n            new value is not and is also not None.\n\n        Raises:\n            ValueError: If error_on_False is True and the attribute cannot be set to\n                the value.\n        \"\"\"\n        if value is None:\n            return True\n\n        try:\n            original_value = self.get_raw_value(attr)\n        except AttributeError:\n            return True\n\n        if not self._initialized:\n            return True\n\n        if self._is_reference(original_value):\n            if self._is_reference(value):\n                return True\n\n            if not error_on_False:\n                return False\n\n            raise ValueError(\n                f\"Cannot set attribute {attr} to {value} because it is a reference. \"\n                \"To overwrite the reference, set the attribute to None first.\\n\"\n                f\"Object: {self}\\n\"\n                f\"Original value: {original_value}\"\n            )\n\n        return True\n\n    def __setattr__(self, attr: str, value: Any) -&gt; None:\n        self._is_valid_setattr(attr, value, error_on_False=True)\n\n        super().__setattr__(attr, value)\n</code></pre>"},{"location":"API_references/utils/reference_class/#quam.utils.reference_class.ReferenceClass.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post init function</p> Source code in <code>quam/utils/reference_class.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post init function\"\"\"\n    self._initialized = True\n</code></pre>"},{"location":"API_references/utils/reference_class/#quam.utils.reference_class.ReferenceClass.get_raw_value","title":"<code>get_raw_value(attr)</code>","text":"<p>Get the value of an attribute without following references.</p> <p>If the value is a reference, the reference string is returned</p> Source code in <code>quam/utils/reference_class.py</code> <pre><code>def get_raw_value(self, attr: str) -&gt; Any:\n    \"\"\"Get the value of an attribute without following references.\n\n    If the value is a reference, the reference string is returned\n    \"\"\"\n    return super().__getattribute__(attr)\n</code></pre>"},{"location":"API_references/utils/reference_class/#quam.utils.reference_class.ReferenceClass.get_unreferenced_value","title":"<code>get_unreferenced_value(attr)</code>","text":"<p>Deprecated method. Use <code>get_raw_value</code> instead.</p> Source code in <code>quam/utils/reference_class.py</code> <pre><code>def get_unreferenced_value(self, attr: str) -&gt; Any:\n    \"\"\"Deprecated method. Use `get_raw_value` instead.\"\"\"\n    warnings.warn(\n        \"get_unreferenced_value is deprecated. Use get_raw_value instead.\",\n        DeprecationWarning,\n    )\n    return self.get_raw_value(attr)\n</code></pre>"},{"location":"API_references/utils/string_reference/","title":"String reference","text":""},{"location":"API_references/utils/string_reference/#quam.utils.string_reference.get_referenced_value","title":"<code>get_referenced_value(obj, string, root=None)</code>","text":"<p>Get the value of a reference string</p> <p>A string reference is a string that starts with \"#/\", \"#./\" or \"#../\". See documentation for details.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The reference string</p> required <code>root</code> <p>The root object to start the search from (default: None) Only relevant if the string is an absolute reference.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value that the reference string points to</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not a valid reference format, i.e. doesn't start correctly.</p> <code>InvalidReferenceError</code> <p>If the reference format is valid but the path cannot be resolved.</p> Source code in <code>quam/utils/string_reference.py</code> <pre><code>def get_referenced_value(obj, string: str, root=None) -&gt; Any:\n    \"\"\"Get the value of a reference string\n\n    A string reference is a string that starts with \"#/\", \"#./\" or \"#../\".\n    See documentation for details.\n\n    Args:\n        string: The reference string\n        root: The root object to start the search from (default: None)\n            Only relevant if the string is an absolute reference.\n\n    Returns:\n        The value that the reference string points to\n\n    Raises:\n        ValueError: If the string is not a valid reference format, i.e. doesn't start\n            correctly.\n        InvalidReferenceError: If the reference format is valid but the path cannot be\n            resolved.\n    \"\"\"\n    if not is_reference(string):\n        # Keep ValueError for format issues\n        raise ValueError(\n            f\"String {string} is not a reference format. \"\n            \"It should start with '#/', '#./' or '#../'\"\n        )\n\n    if is_absolute_reference(string):\n        obj = root\n\n    try:\n        return get_relative_reference_value(obj, string)\n    except (AttributeError, KeyError) as e:\n        # Raise the specific error here, chaining the original exception\n        msg = f\"Could not resolve reference '{string}'\"\n        raise InvalidReferenceError(msg) from e\n</code></pre>"},{"location":"API_references/utils/string_reference/#quam.utils.string_reference.get_relative_reference_value","title":"<code>get_relative_reference_value(obj, string)</code>","text":"<p>Get the value of a reference string relative to an object</p> <p>Performs recursive calls to get the value of nested references</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The reference string</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the reference string relative to the object</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the object does not have the attribute</p> Source code in <code>quam/utils/string_reference.py</code> <pre><code>def get_relative_reference_value(obj, string: str) -&gt; Any:\n    \"\"\"Get the value of a reference string relative to an object\n\n    Performs recursive calls to get the value of nested references\n\n    Args:\n        string: The reference string\n\n    Returns:\n        The value of the reference string relative to the object\n\n    Raises:\n        AttributeError: If the object does not have the attribute\n    \"\"\"\n    string = string.lstrip(\"#/\")\n\n    if not string:\n        return obj\n    if string.startswith(\"../\"):\n        return get_relative_reference_value(obj.parent, string[3:])\n    elif string.startswith(\"./\"):\n        return get_relative_reference_value(obj, string[2:])\n\n    next_attr, remaining_string = split_next_attribute(string)\n\n    if next_attr.isdigit() and isinstance(obj, (list, UserList)):\n        try:\n            obj_attr = obj[int(next_attr)]\n        except KeyError as e:\n            raise AttributeError(f\"Object {obj} has no attribute {next_attr}\") from e\n    elif isinstance(obj, (dict, UserDict)):\n        if next_attr in obj:\n            obj_attr = obj[next_attr]\n        elif next_attr.isdigit() and int(next_attr) in obj:\n            obj_attr = obj[int(next_attr)]\n        else:\n            raise AttributeError(f\"Object {obj} has no attribute {next_attr}\")\n    else:\n        obj_attr = getattr(obj, next_attr)\n\n    return get_relative_reference_value(obj_attr, remaining_string)\n</code></pre>"},{"location":"API_references/utils/string_reference/#quam.utils.string_reference.is_absolute_reference","title":"<code>is_absolute_reference(string)</code>","text":"<p>Check if a string is an absolute reference</p> <p>A relative reference starts with \"#./\" or \"#../\" An absolute reference starts with \":\" but is not followed by \"./\" or \"../\"</p> Source code in <code>quam/utils/string_reference.py</code> <pre><code>def is_absolute_reference(string: str) -&gt; bool:\n    \"\"\"Check if a string is an absolute reference\n\n    A relative reference starts with \"#./\" or \"#../\"\n    An absolute reference starts with \":\" but is not followed by \"./\" or \"../\"\n    \"\"\"\n    if not is_reference(string):\n        return False\n    return string.startswith(\"#/\")\n</code></pre>"},{"location":"API_references/utils/string_reference/#quam.utils.string_reference.is_reference","title":"<code>is_reference(string)</code>","text":"<p>Check if a string is a reference,</p> <p>A reference should be a string that starts with \"#/\", \"#./\" or \"#../\"</p> Source code in <code>quam/utils/string_reference.py</code> <pre><code>def is_reference(string: str) -&gt; bool:\n    \"\"\"Check if a string is a reference,\n\n    A reference should be a string that starts with \"#/\", \"#./\" or \"#../\"\n    \"\"\"\n    if not isinstance(string, str):\n        return False\n    return string.startswith((\"#/\", \"#./\", \"#../\"))\n</code></pre>"},{"location":"API_references/utils/string_reference/#quam.utils.string_reference.join_references","title":"<code>join_references(base, relative)</code>","text":"<p>Joins a base reference (absolute '#/something...' or relative '#./...', '#../...') with another relative reference ('#./...', '#../...', etc.).</p> Disallows <ul> <li>Joining an absolute relative path ('#/...') with any base (raises ValueError).</li> <li>Navigating above the root of an absolute base (#/...) (raises ValueError).</li> </ul> <p>For an absolute base (e.g. '#/a/b'):     - If we end up with a trailing slash (like '#/a/'), we remove it,       unless it's the root path '#/'.</p> <p>For a relative base (e.g. '#./a/b'):     - We allow accumulating extra '..' if we pop everything (no \"true root\").     - We don't remove trailing slashes for relative references (e.g. '#../' remains '#../').</p> Source code in <code>quam/utils/string_reference.py</code> <pre><code>def join_references(base, relative):\n    \"\"\"\n    Joins a base reference (absolute '#/something...' or relative '#./...', '#../...')\n    with another relative reference ('#./...', '#../...', etc.).\n\n    Disallows:\n      - Joining an absolute relative path ('#/...') with any base (raises ValueError).\n      - Navigating above the root of an absolute base (#/...) (raises ValueError).\n\n    For an absolute base (e.g. '#/a/b'):\n        - If we end up with a trailing slash (like '#/a/'), we remove it,\n          unless it's the root path '#/'.\n\n    For a relative base (e.g. '#./a/b'):\n        - We allow accumulating extra '..' if we pop everything (no \"true root\").\n        - We don't remove trailing slashes for relative references (e.g. '#../' remains '#../').\n    \"\"\"\n    # 1) Disallow if 'relative' starts with \"#/\" (i.e., another absolute path)\n    if relative.startswith(\"#/\"):\n        raise ValueError(\"Cannot join an absolute path with another absolute path\")\n\n    # Determine if base is absolute (#/...)\n    is_absolute = base.startswith(\"#/\")\n\n    # 2) Split the base and relative references (dropping the '#' prefix)\n    base_segments = [\"\"] if base == \"#/\" else base[1:].split(\"/\")\n    relative_segments = relative[1:].split(\"/\")\n\n    # 3) Process each segment from the relative path\n    for seg in relative_segments:\n        if seg in [\".\", \"\"]:\n            # \"current directory\": do nothing\n            continue\n        elif seg == \"..\":\n            _handle_go_up(base_segments, is_absolute)\n        else:\n            # Normal segment: just append\n            base_segments.append(seg)\n\n    # Remove empty segments\n    base_segments = [seg for seg in base_segments if seg != \"\"]\n\n    # Reassemble and return\n    if is_absolute:\n        return \"#/\" + \"/\".join(base_segments)\n    else:\n        return \"#\" + \"/\".join(base_segments)\n</code></pre>"},{"location":"API_references/utils/string_reference/#quam.utils.string_reference.split_next_attribute","title":"<code>split_next_attribute(string, splitter='/')</code>","text":"<p>Get the next attribute of a reference string, i.e. until a splitter (default: /)</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>string to split</p> required <code>splitter</code> <code>str</code> <p>splitter to split the string at (default: \"/\")</p> <code>'/'</code> <p>Returns:     Tuple[str, str]: A tuple containing the next attribute (until the first         splitter) and the remaining string from the first splitter.</p> Source code in <code>quam/utils/string_reference.py</code> <pre><code>def split_next_attribute(string: str, splitter: str = \"/\") -&gt; Tuple[str, str]:\n    \"\"\"Get the next attribute of a reference string, i.e. until a splitter (default: /)\n\n    Args:\n        string: string to split\n        splitter:  splitter to split the string at (default: \"/\")\n    Returns:\n        Tuple[str, str]: A tuple containing the next attribute (until the first\n            splitter) and the remaining string from the first splitter.\n    \"\"\"\n    string = string.lstrip(\"#/\")\n\n    if not len(string):\n        return \"\", \"\"\n\n    if splitter in string:\n        return tuple(string.split(splitter, 1))\n\n    return string, \"\"\n</code></pre>"},{"location":"API_references/utils/string_reference/#quam.utils.string_reference.split_reference","title":"<code>split_reference(string)</code>","text":"<p>Split a string reference into its parent reference and attribute</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The reference string</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple[str, str]: A tuple containing the parent reference string and the attribute.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the string is not a valid reference</p> <code>ValueError</code> <p>If the string equals \"#/\"</p> <p>Examples:</p> <p>split_reference(\"#/a/b/c\") == (\"#/a/b\", \"c\") split_reference(\"#/a/b\") == (\"#/a\", \"b\") split_reference(\"#/a\") == (\"#/\", \"a\")</p> Source code in <code>quam/utils/string_reference.py</code> <pre><code>def split_reference(string: str) -&gt; Tuple[str, str]:\n    \"\"\"Split a string reference into its parent reference and attribute\n\n    Args:\n        string: The reference string\n\n    Returns:\n        Tuple[str, str]: A tuple containing the parent reference string and\n            the attribute.\n\n    Raises:\n        ValueError: If the string is not a valid reference\n        ValueError: If the string equals \"#/\"\n\n    Examples:\n        split_reference(\"#/a/b/c\") == (\"#/a/b\", \"c\")\n        split_reference(\"#/a/b\") == (\"#/a\", \"b\")\n        split_reference(\"#/a\") == (\"#/\", \"a\")\n    \"\"\"\n    if not is_reference(string):\n        raise ValueError(f\"String {string} is not a reference\")\n    if string == \"#/\":\n        raise ValueError(f\"String {string} has no parent\")\n    if string == \"#./\":\n        return \"#../\", \"\"\n    if string == \"#../\":\n        return \"#../../\", \"\"\n\n    parent_reference, attr = string.rsplit(\"/\", 1)\n    if parent_reference in (\"#\", \"#.\", \"#..\"):\n        parent_reference += \"/\"\n    return parent_reference, attr\n</code></pre>"},{"location":"API_references/utils/type_checking/","title":"Type checking","text":""},{"location":"API_references/utils/type_checking/#quam.utils.type_checking.type_is_optional","title":"<code>type_is_optional(type_)</code>","text":"<p>Check if a type is Optional[T] for some type T.</p> <p>Parameters:</p> Name Type Description Default <code>type_</code> <p>The type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the type is Optional[T] for some type T, False otherwise.</p> Notes <p>This function does not check if the type is a Union of None and some other type, only if it is a Union of exactly two types, one of which is None. So Optional[Union[str, int]] will return False, but Optional[str] will return True.</p> Source code in <code>quam/utils/type_checking.py</code> <pre><code>def type_is_optional(type_) -&gt; bool:\n    \"\"\"Check if a type is Optional[T] for some type T.\n\n    Args:\n        type_: The type to check.\n\n    Returns:\n        True if the type is Optional[T] for some type T, False otherwise.\n\n    Notes:\n        This function does not check if the type is a Union of None and some other\n        type, only if it is a Union of exactly two types, one of which is None.\n        So Optional[Union[str, int]] will return False, but Optional[str] will return\n        True.\n    \"\"\"\n    if not hasattr(type_, \"__origin__\"):\n        return False\n    if type_.__origin__ is not Union:\n        return False\n    if len(type_.__args__) != 2:\n        return False\n    if type_.__args__[1] is not type(None):\n        return False\n    return True\n</code></pre>"},{"location":"components/","title":"QUAM Components","text":"<p>The components section of the Quantum Abstract Machine (QUAM) documentation outlines the modular parts of the QUAM framework, each designed to enable flexible and efficient quantum programming. Below, you'll find an overview of the main components that you can utilize and extend in your quantum projects.</p>"},{"location":"components/#channels","title":"Channels","text":"<p>Channels are fundamental building blocks in QUAM that facilitate the routing of quantum signals to various hardware components. They serve as the conduits for pulses and other quantum operations, translating abstract quantum actions into physical outcomes on a quantum processor.</p> <ul> <li>Channels Documentation: Explore the detailed documentation on different types of channels including IQ Channels, Single Analog Output Channels, and more.</li> </ul>"},{"location":"components/#channel-ports","title":"Channel Ports","text":"<p>Ports represent the physical connection points between quantum control hardware and quantum devices. QUAM provides port containers for centralized port management, supporting LF-FEM, MW-FEM, and OPX+ hardware with advanced features like port sharing, references, and hardware-specific configurations.</p> <ul> <li>Channel Ports Documentation: Learn how to use port containers, create port references, and configure hardware-specific port properties for FEM and OPX+ systems.</li> </ul>"},{"location":"components/#pulses","title":"Pulses","text":"<p>Pulses in QUAM are used to manipulate qubit states through precise control over their quantum properties. These are defined with specific parameters like amplitude, duration, and waveform, allowing detailed control over quantum operations.</p> <ul> <li>Pulses Documentation: Learn how to define and use different types of pulses such as Gaussian, Square, and DRAG pulses in your quantum circuits.</li> </ul>"},{"location":"components/#qubits-and-qubit-pairs","title":"Qubits and Qubit Pairs","text":"<p>Qubits in QUAM provide an abstraction for physical quantum bits, and similarly combinations of qubits are represented by QubitPairs. This structure provides a gateway to intuitive circuit-level programming with quantum systems.</p> <ul> <li>Qubits and Qubit Pairs Documentation: Learn how to define qubits and qubit pairs. This section is followed by a guide on defining gate-level operations.</li> </ul>"},{"location":"components/#octave","title":"Octave","text":"<p>The Octave component in QUAM handles the upconversion and downconversion of frequencies, enabling high-fidelity signal processing for quantum experiments. This is particularly important for setups requiring complex signal manipulations across multiple frequency bands.</p> <ul> <li>Octave Documentation: Discover how to integrate and configure Octave components to work seamlessly within your QUAM environment.</li> </ul>"},{"location":"components/#custom-quam-components","title":"Custom QUAM Components","text":"<p>For users looking to expand beyond the standard QUAM toolkit, custom components provide a way to introduce novel functionalities tailored to specific quantum computing needs or experimental setups.</p> <ul> <li>Custom QUAM Components: Get guidance on how to develop and integrate your own custom components into the QUAM framework.</li> </ul>"},{"location":"components/channel-ports/","title":"Channel Ports","text":"<p>In the section Channels, we have seen how to create analog channels and attach digital outputs to them. In these examples, the ports are defined by simple tuples like <code>(controller, fem, port)</code>. However, for more advanced use cases and better organization, it is recommended to define ports using dedicated Port QUAM components managed through port containers. This approach provides several benefits:</p> <ol> <li>Centralized port management: Define all ports in one location and reference them from channels.</li> <li>Port sharing: Multiple channels can reference the same physical port with consistent properties.</li> <li>Advanced port properties: Access hardware-specific features like crosstalk compensation, filters, sampling rates, and frequency conversion settings.</li> </ol> <p>QUAM supports ports for three types of quantum control hardware:</p> <ul> <li>LF-FEM Ports: Low-frequency FEM modules using 3-element tuples <code>(controller_id, fem_id, port_id)</code> with support for high sampling rates and flexible output modes.</li> <li>MW-FEM Ports: Microwave FEM modules using 3-element tuples <code>(controller_id, fem_id, port_id)</code> with built-in frequency conversion, replacing the need for separate IQ channels with Octave frequency converters.</li> <li>OPX+ Ports: OPX+ controllers using 2-element tuples <code>(controller_id, port_id)</code> for simpler setups.</li> </ul> <p>All port types are defined in the quam.components.ports module.</p>"},{"location":"components/channel-ports/#port-containers-with-basicquam","title":"Port Containers with BasicQuam","text":"<p>The recommended way to work with ports is to use a FEMPortsContainer attached to your QuamRoot object. This provides centralized port management and enables port references.</p>"},{"location":"components/channel-ports/#setting-up-the-ports-container","title":"Setting Up the Ports Container","text":"<p>Here's how to integrate a ports container into your QUAM state. For this example, we will be using BasicFEMQuam to create the QUAM instance:</p> <pre><code>from quam.components import BasicFEMQuam\nfrom quam.components.ports import FEMPortsContainer\n\n# Create a QUAM instance with ports container\nmachine = BasicFEMQuam(\n    ports=FEMPortsContainer()\n)\n\n# Create ports using the container methods\nmachine.ports.get_analog_output(\n    \"con1\", 1, 2,  # controller, fem_id, port_id\n    create=True,\n    offset=0.15,\n    sampling_rate=2e9,  # 2 GHz sampling\n)\n\nmachine.ports.get_mw_output(\n    \"con1\", 1, 1,\n    create=True,\n    band=1,\n    upconverter_frequency=5e9,  # 5 GHz upconverter\n)\n</code></pre> <p>The <code>create=True</code> parameter automatically creates ports if they don't exist, simplifying setup code.</p>"},{"location":"components/channel-ports/#basic-port-usage","title":"Basic Port Usage","text":""},{"location":"components/channel-ports/#lf-fem-analog-output-with-port-references","title":"LF-FEM Analog Output with Port References","text":"<p>For low-frequency control signals, use LF-FEM analog output ports referenced from your channels:</p> <pre><code>from quam.components import BasicFEMQuam, SingleChannel\nfrom quam.components.ports import FEMPortsContainer\n\n# Create QUAM instance with ports\nmachine = BasicFEMQuam(ports=FEMPortsContainer())\n\n# Create the port\nport = machine.ports.get_analog_output(\n    \"con1\", 1, 2,  # controller, fem_id, port_id\n    create=True,\n    offset=0.15,\n    sampling_rate=2e9,\n    output_mode=\"amplified\",\n)\n\n# Create channel that references this port\nmachine.channels[\"drive\"] = SingleChannel(\n    opx_output=port.get_reference()  # Get reference from port\n)\n</code></pre> <p>Notice that the channel uses <code>port.get_reference()</code> to get a string reference instead of passing the port object directly. This is the recommended pattern for port usage.</p>"},{"location":"components/channel-ports/#mw-fem-for-microwave-control","title":"MW-FEM for Microwave Control","text":"<p>For microwave applications, MW-FEM ports provide built-in frequency conversion, eliminating the need for separate IQ channels and external mixers:</p> <pre><code>from quam.components import BasicFEMQuam\nfrom quam.components.channels import MWChannel\nfrom quam.components.ports import FEMPortsContainer\n\n# Create QUAM instance with ports\nmachine = BasicFEMQuam(ports=FEMPortsContainer())\n\n# Create MW-FEM output port for microwave drive\nmw_port = machine.ports.get_mw_output(\n    \"con1\", 1, 1,\n    create=True,\n    band=1,\n    upconverter_frequency=5.5e9,  # 5.5 GHz LO frequency\n    sampling_rate=1e9,\n)\n\n# Create MW channel with reference to MW-FEM port\nmachine.channels[\"qubit_xy\"] = MWChannel(\n    opx_output=mw_port.get_reference(),\n    intermediate_frequency=100e6,  # 100 MHz IF\n)\n</code></pre> <p>The MW-FEM port handles both I and Q components internally. Use MWChannel for output-only, InMWChannel for input-only, or InOutMWChannel for input+output applications.</p>"},{"location":"components/channel-ports/#mw-fem-readout-with-linked-frequencies","title":"MW-FEM Readout with Linked Frequencies","text":"<p>For readout, link the downconverter frequency to the upconverter frequency:</p> <pre><code>from quam.components.channels import InOutMWChannel\n\nmw_output = machine.ports.get_mw_output(\"con1\", 1, 1, create=True, band=1, upconverter_frequency=6e9)\nmw_input = machine.ports.get_mw_input(\n    \"con1\", 1, 1, create=True, band=1,\n    downconverter_frequency=mw_output.get_reference(\"upconverter_frequency\"),\n)\n\nmachine.channels[\"readout\"] = InOutMWChannel(\n    opx_output=mw_output.get_reference(),\n    opx_input=mw_input.get_reference(),\n)\n</code></pre>"},{"location":"components/channel-ports/#port-types-and-hardware","title":"Port Types and Hardware","text":""},{"location":"components/channel-ports/#lf-fem-ports","title":"LF-FEM Ports","text":"<p>Low-frequency FEM ports support high sampling rates and various output modes:</p> <pre><code># LF-FEM analog output with advanced features\nmachine.ports.get_analog_output(\n    \"con1\", 1, 2,  # controller, fem_id, port_id\n    create=True,\n    offset=0.15,\n    sampling_rate=2e9,  # 1 GHz or 2 GHz\n    output_mode=\"amplified\",  # \"direct\" or \"amplified\"\n    exponential_filter=[(10, 0.1), (20, 0.2)],  # For QOP &gt;= 3.3.0\n)\n</code></pre>"},{"location":"components/channel-ports/#mw-fem-ports","title":"MW-FEM Ports","text":"<p>Microwave FEM ports integrate frequency conversion for direct RF/microwave control:</p> <pre><code># MW-FEM output with upconverter\nmachine.ports.get_mw_output(\n    \"con1\", 1, 1,  # controller, fem_id, port_id\n    create=True,\n    band=1,  # Required: 1 or 2\n    upconverter_frequency=5.5e9,  # Upconversion LO frequency (Hz)\n)\n</code></pre> <p>MW-FEM ports eliminate the need for external mixers and frequency converters.</p>"},{"location":"components/channel-ports/#opx-ports","title":"OPX+ Ports","text":"<p>For systems using OPX+ controllers, ports use a simpler 2-tuple addressing scheme.</p>"},{"location":"components/channel-ports/#opx-port-types","title":"OPX+ Port Types","text":"<pre><code># Analog output with filters\nmachine.ports.get_analog_output(\n    \"con1\", 3,  # controller, port_id (note: only 2 elements)\n    create=True,\n    offset=0.2,\n    feedforward_filter=[0.7, 0.2, 0.1],  # FIR filter\n    feedback_filter=[0.3, 0.4, 0.5],  # IIR filter\n)\n</code></pre>"},{"location":"components/channel-ports/#opx-with-iq-channels","title":"OPX+ with IQ Channels","text":"<p>When using OPX+ hardware, you may need IQ channels with separate I and Q ports:</p> <pre><code>from quam.components import BasicOPXPlusQuam, IQChannel\nfrom quam.components.ports import OPXPlusPortsContainer\nfrom quam.components.hardware import FrequencyConverter, LocalOscillator, Mixer\n\n# For OPX+ systems, use OPXPlusPortsContainer\nmachine = BasicOPXPlusQuam(ports=OPXPlusPortsContainer())\n\n# Create I and Q ports\nport_I = machine.ports.get_analog_output(\"con1\", 1, create=True, offset=0.1)\nport_Q = machine.ports.get_analog_output(\"con1\", 2, create=True, offset=-0.05)\n\n# Create IQ channel with port references\nmachine.channels[\"qubit_xy\"] = IQChannel(\n    opx_output_I=port_I.get_reference(),\n    opx_output_Q=port_Q.get_reference(),\n    intermediate_frequency=100e6,\n    frequency_converter_up=FrequencyConverter(\n        local_oscillator=LocalOscillator(frequency=6e9, power=10),\n        mixer=Mixer(),\n    )\n)\n</code></pre> <p>Note: MW-FEM ports are preferred over this approach for microwave applications as they integrate frequency conversion.</p>"},{"location":"components/channel-ports/#port-container-methods","title":"Port Container Methods","text":"<p>The FEMPortsContainer provides methods for each port type:</p> <pre><code># LF-FEM ports (3 parameters: controller, fem_id, port_id)\nmachine.ports.get_analog_output(\"con1\", 1, 2, create=True)\nmachine.ports.get_analog_input(\"con1\", 1, 1, create=True)\nmachine.ports.get_digital_output(\"con1\", 1, 1, create=True)\n\n# MW-FEM ports\nmachine.ports.get_mw_output(\"con1\", 1, 1, create=True, band=1, upconverter_frequency=5e9)\nmachine.ports.get_mw_input(\"con1\", 1, 1, create=True, band=1, downconverter_frequency=5e9)\n</code></pre> <p>For OPXPlusPortsContainer, use 2 parameters (controller, port_id):</p> <pre><code>machine.ports.get_analog_output(\"con1\", 3, create=True)\nmachine.ports.get_digital_input(\"con1\", 1, create=True)\n</code></pre>"},{"location":"components/channel-ports/#port-references","title":"Port References","text":"<p>Use <code>port.get_reference()</code> to get string references for ports. See basic examples in Basic Port Usage above.</p> <p>To reference specific attributes, use <code>port.get_reference(\"attribute_name\")</code>. This is useful for linking converter frequencies:</p> <pre><code>mw_output = machine.ports.get_mw_output(\"con1\", 1, 1, create=True, upconverter_frequency=5e9)\nmw_input = machine.ports.get_mw_input(\n    \"con1\", 1, 1, create=True,\n    downconverter_frequency=mw_output.get_reference(\"upconverter_frequency\"),\n)\n</code></pre>"},{"location":"components/channel-ports/#advanced-features","title":"Advanced Features","text":"<p>Ports support crosstalk compensation, FIR/IIR filters (OPX+), and exponential filters (LF-FEM). Refer to the API documentation for complete parameter details.</p>"},{"location":"components/channel-ports/#best-practices","title":"Best Practices","text":"<ul> <li>Use port references: Always use <code>port.get_reference()</code> instead of passing port objects directly</li> <li>Centralized management: Create all ports before channels for better organization</li> <li>Configure properties on ports: Set properties like <code>offset</code>, <code>shareable</code>, <code>inverted</code>, and filters directly on Port objects, not on channels. Channel-level port properties are deprecated and will be removed in a future version.</li> <li>Avoid deprecated channel properties: Do not use <code>opx_output_offset</code>, <code>opx_input_offset</code>, <code>filter_fir_taps</code>, <code>filter_iir_taps</code>, <code>shareable</code>, or <code>inverted</code> on channel objects. These emit deprecation warnings and will be removed.</li> <li>Port sharing: Set <code>shareable=True</code> when multiple channels use the same port</li> <li>Choose the right type: MW-FEM for microwave/RF, LF-FEM for high-rate baseband/IF</li> </ul>"},{"location":"components/channel-ports/#migrating-from-channel-level-port-properties","title":"Migrating from Channel-Level Port Properties","text":"Deprecated Channel Properties <p>type: warning As of QUAM v0.5.0, setting port properties on channels is deprecated. Runtime warnings are emitted to help you migrate your code. See the Channels Migration Guide for detailed examples.</p>"},{"location":"components/channel-ports/#quick-migration-guide","title":"Quick Migration Guide","text":"<p>If you're currently setting port properties on channels, migrate to explicit Port objects:</p> Channel Property Port Property Port Class <code>opx_output_offset</code> <code>offset</code> <code>OPXPlusAnalogOutputPort</code>, <code>LFFEMAnalogOutputPort</code> <code>opx_input_offset</code> <code>offset</code> <code>OPXPlusAnalogInputPort</code>, <code>LFFEMAnalogInputPort</code> <code>filter_fir_taps</code> <code>feedforward_filter</code> <code>LFAnalogOutputPort</code> (all output ports) <code>filter_iir_taps</code> <code>feedback_filter</code> (OPX+) or <code>exponential_filter</code> (LF-FEM) <code>LFAnalogOutputPort</code> (all output ports) <code>shareable</code> (any channel) <code>shareable</code> All port types <code>inverted</code> (digital) <code>inverted</code> <code>DigitalOutputPort</code> types <p>Example:</p> <pre><code># Old (deprecated - emits warning)\nchannel = SingleChannel(opx_output=(\"con1\", 1), opx_output_offset=0.15)\n\n# New (recommended)\nfrom quam.components.ports import OPXPlusAnalogOutputPort\nport = OPXPlusAnalogOutputPort(\"con1\", 1, offset=0.15)\nchannel = SingleChannel(opx_output=port)\n</code></pre> <p>See the complete migration guide in the Channels documentation for more examples.</p>"},{"location":"components/channels/","title":"Channels","text":"<p>In the QUAM library, channels are a fundamental concept that represent the physical connections to the quantum hardware. They are defined in the quam.components.channels module.</p> <p>We distinguish between the following channel types, where the terms \"output\" and \"input\" are always from the perspective of the OPX hardware:</p> <p>1. Analog output channels</p> <ul> <li>SingleChannel: Represents a single OPX output channel.</li> <li>IQChannel: Represents an IQ OPX output channel.</li> </ul> <p>2. Analog output + input channels</p> <ul> <li>InOutSingleChannel: Represents a single OPX output + input channel.</li> <li>InOutIQChannel: Represents an IQ OPX output + input channel.</li> </ul> <p>3. Digital channels</p> <ul> <li>DigitalOutputChannel: Represents a digital output channel.</li> </ul> <p>Each analog Channel corresponds to an element in QUA, whereas the digital channel is part of an analog channel.</p> <p>These channel combinations cover most use cases, although there are exceptions (input-only channels and single-output, IQ-input channels) which will be implemented in a subsequent QUAM release. If you need such channels, please create a Github issue.</p>"},{"location":"components/channels/#analog-output-channels","title":"Analog Output Channels","text":"<p>Analog output channels are the primary means of controlling the quantum hardware. They can be used to send various types of signals, such as microwave or RF signals, to control the quantum system. The two types of analog output channels are the SingleChannel and the IQChannel.</p>"},{"location":"components/channels/#analog-channel-ports","title":"Analog Channel Ports","text":"<p>A SingleChannel is always attached to a single OPX output port, and similarly an IQChannel has an associated pair of IQ ports:</p> <pre><code>from quam.components import SingleChannel, IQChannel\n\nsingle_channel = SingleChannel(\n    opx_output=(\"con1\", 1),\n    ...\n)\nIQ_channel = IQChannel(\n    opx_output_I=(\"con1\", 2),\n    opx_output_Q=(\"con1\", 3),\n    ...\n)\n</code></pre> Port Properties in Channels (Deprecated) <p>type: warning Some properties such as <code>opx_output_offset</code>, <code>opx_input_offset</code>, <code>filter_fir_taps</code>, <code>filter_iir_taps</code>, <code>shareable</code>, and <code>inverted</code> are currently available as channel attributes for backwards compatibility. However, these properties belong to ports and should be configured through explicit Port objects.</p> <p>These properties are deprecated and will be removed in a future version. Runtime deprecation warnings are now emitted when these properties are used, providing migration guidance. See the Migration Guide below for details on how to update your code.</p> <p>For more advanced port management, including port containers, port references, and hardware-specific configurations (LF-FEM, MW-FEM, OPX+), see the Channel Ports documentation.</p>"},{"location":"components/channels/#using-explicit-ports-recommended","title":"Using Explicit Ports (Recommended)","text":"<p>For advanced control over port properties, define ports explicitly and reference them from channels:</p> <pre><code>from quam.components import BasicQuam, SingleChannel\nfrom quam.components.ports import FEMPortsContainer\n\n# Create QUAM instance with port container\nmachine = BasicQuam(ports=FEMPortsContainer())\n\n# Define port with its properties\nport = machine.ports.get_analog_output(\n    \"con1\", 1, 2,  # controller, fem_id, port_id\n    create=True,\n    offset=0.15,  # DC offset configured on port\n    shareable=True,  # Port sharing configured on port\n    sampling_rate=2e9,\n)\n\n# Create channel that references the port\nmachine.channels[\"drive\"] = SingleChannel(\n    opx_output=port.get_reference()  # Reference to configured port\n)\n</code></pre> <p>This approach ensures centralized port configuration and enables port sharing across channels. See Channel Ports for complete documentation.</p>"},{"location":"components/channels/#dc-offset","title":"DC Offset","text":"<p>Each analog channel can have a specified DC offset that remains for the duration of the QUA program.</p> <p>Recommended Approach - Configure DC offset on the port:</p> <pre><code>from quam.components.ports import OPXPlusAnalogOutputPort\n\n# For single channels\nport = OPXPlusAnalogOutputPort(\"con1\", 1, offset=0.15)\nchannel = SingleChannel(opx_output=port)\n\n# For IQ channels with different I/Q offsets\nport_I = OPXPlusAnalogOutputPort(\"con1\", 2, offset=0.10)\nport_Q = OPXPlusAnalogOutputPort(\"con1\", 3, offset=0.12)\nIQ_channel = IQChannel(opx_output_I=port_I, opx_output_Q=port_Q)\n</code></pre> <p>Deprecated Approach - Setting offset on channel (emits deprecation warning):</p> <pre><code># Still works but will be removed in a future version\nchannel = SingleChannel(opx_output=(\"con1\", 1), opx_output_offset=0.15)\nIQ_channel = IQChannel(\n    opx_output_I=(\"con1\", 2),\n    opx_output_Q=(\"con1\", 3),\n    opx_output_offset_I=0.10,\n    opx_output_offset_Q=0.12\n)\n</code></pre> <p>Note that if multiple channels are attached to the same OPX output port(s), they may not have different output offsets. This raises a warning and chooses the DC offset of the last channel.</p> <p>The DC offset can also be modified while a QUA program is running:</p> <pre><code>from qm.qua import program\n\nwith program() as prog:\n    single_channel.set_dc_offset(offset=0.1)\n    IQ_channel.set_dc_offset(offset=0.25, element_input=\"I\")  # Set offset of port I\n</code></pre> <p>The offsets can also be QUA variables. Channel.set_dc_offset() is a light wrapper around <code>qm.qua.set_dc_offset</code> to attach it to the channel.</p>"},{"location":"components/channels/#frequency-converters","title":"Frequency Converters","text":"<p>The <code>IQChannel</code> is usually connected to a mixer to upconvert the signal using a local oscillator. This frequency upconversion is represented in QUAM by a FrequencyConverter</p> <pre><code>from quam.components.hardware import FrequencyConverter, LocalOscillator, Mixer\n\nIQ_channel = IQChannel(\n    opx_output_I=(\"con1\", 2),\n    opx_output_Q=(\"con1\", 3),\n    intermediate_frequency=100e6,  # Hz\n    frequency_converter=FrequencyConverter(\n        local_oscillator=LocalOscillator(frequency=6e9, power=10),\n        mixer=Mixer(),\n    )\n)\n</code></pre> <p>Integrated frequency conversion systems such as QM's Octave usually have additional features such as auto-calibration. For this reason they have a specialized frequency converter such as the OctaveUpConverter. See the QUAM Octave Documentation documentation for details.</p>"},{"location":"components/channels/#analog-pulses","title":"Analog Pulses","text":"<p>QUAM has a range of standard Pulse components in quam.components.pulses. These pulses can be registered as part of the analog channel via <code>Channel.operations</code> such that the channel can output the associated pulse waveforms:</p> <pre><code>from quam.components import pulses\n\nchannel.operations[\"X180\"] = pulses.SquarePulse(\n    amplitude=0.1,  # V\n    length=16,  # ns\n)\n</code></pre> <p>Once a pulse has been registered in a channel, it can be played within a QUA program:</p> <pre><code>with program() as prog:\n    channel.play(\"X180\")\n</code></pre> <p>Channel.play() is a light wrapper around qm.qua.play() to attach it to the channel.</p> <p>Details on pulses in QUAM can be found at the Pulses Documentation.</p>"},{"location":"components/channels/#analog-output-input-channels","title":"Analog Output + Input Channels","text":"<p>Aside from sending signals to the quantum hardware, data is usually also received back, and subsequently read out through the hardware's input ports. In QUAM, this is represented using the InOutSingleChannel and the InOutIQChannel. These channels don't only have associated output port(s) but also input port(s):</p> <pre><code>from quam.components import InOutSingleChannel, InOutIQChannel\n\nsingle_io_channel = InOutSingleChannel(\n    opx_output=(\"con1\", 1),\n    opx_input=(\"con1\", 1)\n    ...\n)\nIQ_io_channel = InOutIQChannel(\n    opx_output_I=(\"con1\", 2),\n    opx_output_Q=(\"con1\", 3),\n    opx_input_I=(\"con1\", 1),\n    opx_input_Q=(\"con1\", 2)\n    ...\n)\n</code></pre> <p>These are extensions of the SingleChannel and the IQChannel that add relevant features for readout.</p> <p>Both the InOutSingleChannel and the InOutIQChannel combine output + input as in most cases a signal is also sent to probe the quantum hardware. Support for input-only analog channels is planned for a future release.</p>"},{"location":"components/channels/#readout-pulses","title":"Readout Pulses","text":"<p>Channels that have input ports can also have readout pulses:</p> <pre><code>from quam.components import pulses\nio_channel.operations[\"readout\"] = pulses.SquareReadoutPulse(\n    length=16,  # ns\n    amplitude=0.1,  # V\n    integration_weights_angle=0.0,  # rad, optional rotation of readout signal\n)\n</code></pre> <p>As can be seen, the readout pulse (in this case SquareReadoutPulse) is similar to the regular pulses, but with additional parameters for readout. Specifically, it contains the attributes <code>integration_weights_angle</code> and <code>integration_weights</code> to specify how the readout signal should be integrated.</p>"},{"location":"components/channels/#digital-channels","title":"Digital Channels","text":"<p>QUAM supports digital output channels (output from the OPX perspective) through the component DigitalOutputChannel. These can be added to any analog channel through the attribute <code>Channel.digital_outputs</code>. As an example:</p> <pre><code>from quam.components import SingleChannel, DigitalOutputChannel\n\nanalog_channel = SingleChannel(\n    opx_output=(\"con1\", 1),\n    digital_outputs={\n        \"dig_out1\": DigitalOutputChannel(opx_output=(\"con1\", 1))\n    }\n)\n</code></pre> <p>The docstring of DigitalOutputChannel describes all the available properties.</p> <p>Multiple digital outputs can be attached to the same analog channel:</p> <pre><code>analog_channel.digital_outputs = {\n    \"dig_out1\": DigitalOutputChannel(opx_output=(\"con1\", 1)),\n    \"dig_out2\": DigitalOutputChannel(opx_output=(\"con1\", 2)),\n}\n</code></pre> <p>In this case, any digital pulses will be played to all digital channels.</p>"},{"location":"components/channels/#digital-only-channel","title":"Digital-only Channel","text":"<p>It is also possible to create a digital-only channel, i.e. using digital ports without any analog ports.</p> <pre><code>from quam.components import Channel, DigitalOutputChannel\nchannel = Channel(\n    id=\"channel\",\n    digital_outputs={\"1\": DigitalOutputChannel(opx_output=(\"con1\", 1))},\n)\n</code></pre>"},{"location":"components/channels/#digital-pulses","title":"Digital Pulses","text":"<p>Once a DigitalOutputChannel is added to a Channel, digital waveforms can be played on it. This is done by attaching a digital waveform to a Pulse through the attribute <code>Pulse.digital_marker</code>:</p> <pre><code>from quam.components import pulses\n\npulse = pulses.SquarePulse(\n    length=80,\n    amplitude=0.2,\n    digital_marker=[(1, 20), (0, 20), (1, 40)]\n)\n</code></pre> <p>In the example above, the square pulse will also output digital waveform: \"high\" for 20 ns \u21e8 \"low\" for 20 ns \u21e8 \"high\" for 40 ns. This digital waveform will be played on all digital channels that are attached to the analog channel.</p>"},{"location":"components/channels/#digital-only-pulses","title":"Digital-only Pulses","text":"<p>A digital pulse can also be played without a corresponding analog pulse. This can be done by directly using the base pulses.Pulse class:</p> <pre><code>channel.operations[\"digital\"] = pulses.Pulse(length=100, digital_marker=[(1, 20, 0, 10)])\n</code></pre>"},{"location":"components/channels/#sticky-channels","title":"Sticky channels","text":"<p>A channel can be set to be sticky, meaning that the voltage after a pulse will remain at the last value of the pulse. Details can be found in the Sticky channel QUA documentation. Any channel can be made sticky by adding the channels.StickyChannelAddon to it:</p> <pre><code>from quam.components.channels import StickyChannelAddon\n\nchannel.sticky = StickyChannelAddon(duration=...)\n</code></pre>"},{"location":"components/channels/#time-tagging","title":"Time Tagging","text":"<p>Time tagging is a feature that allows for the measurement of the time of arrival of a signal. It is implemented as the TimeTaggingAddon to the InSingleChannel.</p> <p>To use the time tagging feature, the TimeTaggingAddon must be added to the InSingleChannel:</p> <pre><code>from quam.components.channels import InSingleChannel, TimeTaggingAddon\n\nchannel = InSingleChannel(\n    id=\"channel\",\n    opx_input=(\"con1\", 1),\n    time_tagging=TimeTaggingAddon(\n        signal_threshold=0.195,  # in units of V\n        signal_polarity=\"below\",\n        derivative_threshold=0.073,  # in units of V/ns\n        derivative_polarity=\"below\",\n    )\n)\n</code></pre> <p>All parameters are optional, and are by default set to the values shown above.</p> <p>Once the time tagging addon is added, the InSingleChannel.measure_time_tagging() method can be used within a QUA program to measure the time of arrival of the signal:</p> <pre><code>times, counts = channel.measure_time_tagging(size=1000, max_duration=3000)\n</code></pre> <ul> <li>The <code>size</code> parameter specifies the maximum number of samples to collect.</li> <li>The <code>max_duration</code> parameter specifies the maximum duration to collect samples for.</li> </ul> <p>Two QUA variables are returned:</p> <ul> <li><code>times</code> is a QUA array containing the times of arrival of the signal.   It will contain at most <code>size</code> entries, though it may contain fewer if the maximum duration is reached first.</li> <li><code>counts</code> is a QUA integer containing the number of measured events, being at most equal to <code>size</code>.</li> </ul> <p>Additional information on time tagging can be found in the Time Tagging QUA documentation.</p>"},{"location":"components/channels/#migrating-from-channel-level-port-properties","title":"Migrating from Channel-Level Port Properties","text":"<p>As of QUAM v0.5.0, port-related properties on channels are deprecated. This section provides guidance on migrating your code to use explicit Port objects instead.</p>"},{"location":"components/channels/#why-migrate","title":"Why Migrate?","text":"<p>Port properties such as <code>opx_output_offset</code>, <code>filter_fir_taps</code>, <code>shareable</code>, and <code>inverted</code> logically belong to ports, not channels. Using explicit Port objects:</p> <ul> <li>Clarifies ownership: Properties are configured where they belong</li> <li>Enables port sharing: Multiple channels can reference the same configured port</li> <li>Centralizes configuration: Port containers provide unified port management</li> <li>Prepares for future: Channel-level properties will be removed in a future version</li> </ul>"},{"location":"components/channels/#migration-examples","title":"Migration Examples","text":""},{"location":"components/channels/#dc-offsets","title":"DC Offsets","text":"<p>Before (Deprecated):</p> <pre><code>channel = SingleChannel(\n    opx_output=(\"con1\", 1),\n    opx_output_offset=0.15\n)\n</code></pre> <p>After (Recommended):</p> <pre><code>from quam.components.ports import OPXPlusAnalogOutputPort\n\nport = OPXPlusAnalogOutputPort(\"con1\", 1, offset=0.15)\nchannel = SingleChannel(opx_output=port)\n</code></pre>"},{"location":"components/channels/#filter-configuration","title":"Filter Configuration","text":"<p>Before (Deprecated):</p> <pre><code>channel = SingleChannel(\n    opx_output=(\"con1\", 1),\n    filter_fir_taps=[0.1, 0.2, 0.3],\n    filter_iir_taps=[0.5, 0.6]\n)\n</code></pre> <p>After (Recommended):</p> <pre><code>from quam.components.ports import OPXPlusAnalogOutputPort\n\nport = OPXPlusAnalogOutputPort(\n    \"con1\", 1,\n    feedforward_filter=[0.1, 0.2, 0.3],\n    feedback_filter=[0.5, 0.6]\n)\nchannel = SingleChannel(opx_output=port)\n</code></pre>"},{"location":"components/channels/#digital-channel-properties","title":"Digital Channel Properties","text":"<p>Before (Deprecated):</p> <pre><code>digital_channel = DigitalOutputChannel(\n    opx_output=(\"con1\", 1),\n    shareable=True,\n    inverted=True\n)\n</code></pre> <p>After (Recommended):</p> <pre><code>from quam.components.ports import OPXPlusDigitalOutputPort\n\nport = OPXPlusDigitalOutputPort(\"con1\", 1, shareable=True, inverted=True)\ndigital_channel = DigitalOutputChannel(opx_output=port)\n</code></pre>"},{"location":"components/channels/#iq-channels-with-offsets","title":"IQ Channels with Offsets","text":"<p>Before (Deprecated):</p> <pre><code>IQ_channel = IQChannel(\n    opx_output_I=(\"con1\", 2),\n    opx_output_Q=(\"con1\", 3),\n    opx_output_offset_I=0.10,\n    opx_output_offset_Q=0.12\n)\n</code></pre> <p>After (Recommended):</p> <pre><code>from quam.components.ports import OPXPlusAnalogOutputPort\n\nport_I = OPXPlusAnalogOutputPort(\"con1\", 2, offset=0.10)\nport_Q = OPXPlusAnalogOutputPort(\"con1\", 3, offset=0.12)\nIQ_channel = IQChannel(opx_output_I=port_I, opx_output_Q=port_Q)\n</code></pre>"},{"location":"components/channels/#using-port-containers-best-practice","title":"Using Port Containers (Best Practice)","text":"<p>For complex systems with many ports, use a port container for centralized management:</p> <pre><code>from quam.components import BasicQuam\nfrom quam.components.ports import FEMPortsContainer\n\n# Set up port container\nmachine = BasicQuam(ports=FEMPortsContainer())\n\n# Create ports with properties\noutput_port = machine.ports.get_analog_output(\n    \"con1\", 1, 2,  # controller, fem_id, port_id\n    create=True,\n    offset=0.15,\n    shareable=True\n)\n\n# Reference port in channel\nmachine.channels[\"drive\"] = SingleChannel(\n    opx_output=output_port.get_reference()\n)\n</code></pre> <p>See the Channel Ports documentation for more details on port containers and advanced port management.</p>"},{"location":"components/custom-components/","title":"Custom QUAM Components","text":"<p>To create custom QUAM components, their classes should be defined in a Python module that can be accessed from Python. The reason for this is that otherwise QUAM cannot load QUAM from a JSON file as it cannot determine where the classes are defined. If you already have a Python module that you use for your own QUA code, it is recommended to add QUAM components to that module. If you don't already have such a module, please follow the guide below.</p>"},{"location":"components/custom-components/#creating-a-custom-python-module","title":"Creating a Custom Python Module","text":"<p>Here we describe how to create a minimal Python module that can be used for your custom QUAM components. In this example, we will give the top-level folder the name <code>my-quam</code> and the Python module will be called <code>my_quam</code> (note the underscore instead of dash). First create the following folder structure <pre><code>my-quam\n\u251c\u2500\u2500 my_quam\n\u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 components\n\u2502       \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 pyproject.toml\n</code></pre> The <code>__init__.py</code> files should be empty, and <code>pyproject.toml</code> should have the following contents:</p> pyproject.toml <pre><code>[project]\nname = \"my-quam\"\nversion = \"0.1.0\"\ndescription = \"User QUAM repository\"\nauthors = [{ name = \"Jane Doe\", email = \"jane.doe@quantum-machines.co\" }]\nrequires-python = \"&gt;=3.9\"\n\n[build-system]\nrequires = [\"setuptools\", \"setuptools-scm\"]\nbuild-backend = \"setuptools.build_meta\"\n\n\n[tool.setuptools]\npackages = [\"my_quam\"]\n</code></pre> <p>Feel free to modify details such as <code>description</code> and <code>authors</code>.</p> <p>Finally, to install the package, first make sure you're in the correct environment, then navigate to the top-level folder <code>my-quam</code> and run: <pre><code>pip install .\n</code></pre> The custom QUAM components can then be loaded as <pre><code>from my_quam.components import *\n</code></pre> All the custom QUAM components should be placed as Python files in <code>my-quam/my_quam/components</code>.</p>"},{"location":"components/custom-components/#creating-a-custom-quam-component","title":"Creating a Custom QUAM Component","text":"<p>Once a designated Python module has been chosen / created, it can be populated with a custom component. We will assume that the newly-created Python module <code>my_quam</code> is used. In this example, we will make a basic QUAM component representing a DC gate, with two properties: <code>name</code> and <code>dc_voltage</code>:</p> <p>my_quam/components/gates.py<pre><code>from typing import Union\nfrom quam.core import QuamComponent, quam_dataclass\n\n@quam_dataclass\nclass DcGate(QuamComponent):\n    id: Union[int, str]\n    dc_voltage: float\n</code></pre> which can be instantiated as follows: <pre><code>from my_quam.components.gates import DcGate\ndc_gate = DcGate(id=\"plunger_gate\", dc_voltage=0.43)\n</code></pre></p> <p>A few notes about the above:</p> <ul> <li>Each QuamComponent inherits from QuamComponent.</li> <li>QUAM components are decorated with <code>@quam_dataclass</code>, which is a variant of the Python @dataclass.</li> </ul> Reason for <code>@quam_dataclass</code> instead of <code>@dataclass</code> <p>Inheriting from a dataclass is not directly possible when the parent class has keyword arguments and the child class does not. To illustrate this, the following example will raise a <code>TypeError</code>: <pre><code>@dataclass\nclass Parent:\n    optional_attr: int = 42\n\n@dataclass\nclass Child(Parent):\n    required_attr: int\n</code></pre></p> <p>In Python 3.10 and up, this can be solved by adding the <code>kw_only=True</code> keyword argument: <pre><code>@dataclass\nclass Parent:\n    optional_attr: int = 42\n\n@dataclass(kw_only=True)\nclass Child(Parent):\n    required_attr: int\n\nchild = Child(required_attr=12)  # Note that we now need to explicitly pass keywords\n</code></pre></p> <p>The keyword <code>kw_only</code> was only introduced in Python 3.10, and so the example above would raise an error in Python &lt;3.10. However, to ensure QUAM is compatible with Python 3.9 and above, we introduced <code>@quam_dataclass</code> which fixes this problem:</p> <pre><code>@quam_dataclass\nclass Child(Parent):\n    required_attr: int\n</code></pre> <p>An additional benefit is that <code>kw_only=True</code> is automatically passed along. From Python 3.10 onwards, <code>@quam_dataclass</code> is equivalent to <code>@dataclass(kw_only=True, eq=False)</code></p>"},{"location":"components/custom-components/#quam-component-subclassing","title":"QUAM Component Subclassing","text":"<p>QUAM components can also be subclassed to add functionalities to the parent class. For example, we now want to combine a DC and AC gate together, where the AC part corresponds to an OPX channel. To do this, we create a class called <code>AcDcGate</code> that inherits from both <code>DcGate</code> and SingleChannel:</p> <pre><code>from quam.components import SingleChannel\n\n\n@quam_dataclass\nclass AcDcGate(DcGate, SingleChannel):\n    pass\n</code></pre> <p>It can be instantiated using <pre><code>ac_dc_gate = AcDcGate(id=\"plunger_gate\", dc_voltage=0.43, opx_output=(\"con1\", 1))\n</code></pre></p> <p>Notice that the keyword argument <code>opx_output</code> now also needs to be passed. This is because it's a required argument for SingleChannel.</p>"},{"location":"components/octave/","title":"Octave","text":"<p>An Octave is represented in QUAM through the quam.components.octave.Octave class. Below we describe the three steps needed to configuring an Octave in QUAM:</p> <ol> <li>Creating the Octave</li> <li>Adding frequency converters</li> <li>Attaching channels</li> </ol>"},{"location":"components/octave/#creating-the-root-quam-machine","title":"Creating the Root QUAM Machine","text":"<p>Before we get started, we need a top-level QUAM class that matches our components:</p> <pre><code>from typing import Dict\nfrom dataclasses import field\nfrom quam.core import QuamRoot, quam_dataclass\nfrom quam.components import Octave, OctaveUpConverter, OctaveDownConverter, Channel\n\n@quam_dataclass\nclass Quam(QuamRoot):\n    octave: Octave = None\n    channels: Dict[str, Channel] = field(default_factory=dict)\n\nmachine = Quam()\n</code></pre> <p>This will be used later to generate our QUA configuration</p>"},{"location":"components/octave/#creating-the-octave","title":"Creating the Octave","text":"<p>Below we show how an Octave is instantiated using some example arguments:</p> <pre><code>octave = Octave(name=\"octave1\", ip=\"127.0.0.1\", port=80)\nmachine.octave = octave\n</code></pre> <p>We can next retrieve the Octave config <code>QmOctaveConfig</code>, used to create the <code>QuantumMachinesManager</code></p> <pre><code>octave_config = octave.get_octave_config()\n# The calibration_db and device_info are automatically configured\n\nqmm = QuantumMachinesManager(host={opx_host}, port={opx_port}, octave=octave_config)\n</code></pre> <p>At this point the channel connectivity of the Octave hasn't yet been configured. We can do so by adding frequency converters.</p>"},{"location":"components/octave/#adding-frequency-converters","title":"Adding Frequency Converters","text":"<p>A frequency converter is a grouping of the components needed to upconvert or downconvert a signal. These typically consist of a local oscillator, mixer, as well as IF, LO, and RF ports. For the Octave we have two types of frequency converters:</p> <ul> <li>OctaveUpConverter: Used to upconvert a pair of IF signals to an RF signal</li> <li>OctaveDownConverter: Used to downconvert an RF signal to a pair of IF signals</li> </ul> <p>We can add all relevant frequency converters as follows:</p> <pre><code>octave.initialize_frequency_converters()\n\noctave.print_summary()\n</code></pre> <code>octave.print_summary()</code> output <pre><code>Octave (parent unknown):\n  name: \"octave1\"\n  ip: \"127.0.0.1\"\n  port: 80\n  calibration_db_path: None\n  RF_outputs: QuamDict\n    1: OctaveUpConverter\n      id: 1\n      channel: None\n      LO_frequency: None\n      LO_source: \"internal\"\n      gain: 0\n      output_mode: \"always_off\"\n      input_attenuators: \"off\"\n    2: OctaveUpConverter\n      id: 2\n      channel: None\n      LO_frequency: None\n      LO_source: \"internal\"\n      gain: 0\n      output_mode: \"always_off\"\n      input_attenuators: \"off\"\n    3: OctaveUpConverter\n      id: 3\n      channel: None\n      LO_frequency: None\n      LO_source: \"internal\"\n      gain: 0\n      output_mode: \"always_off\"\n      input_attenuators: \"off\"\n    4: OctaveUpConverter\n      id: 4\n      channel: None\n      LO_frequency: None\n      LO_source: \"internal\"\n      gain: 0\n      output_mode: \"always_off\"\n      input_attenuators: \"off\"\n    5: OctaveUpConverter\n      id: 5\n      channel: None\n      LO_frequency: None\n      LO_source: \"internal\"\n      gain: 0\n      output_mode: \"always_off\"\n      input_attenuators: \"off\"\n  RF_inputs: QuamDict\n    1: OctaveDownConverter\n      id: 1\n      channel: None\n      LO_frequency: None\n      LO_source: \"internal\"\n      IF_mode_I: \"direct\"\n      IF_mode_Q: \"direct\"\n      IF_output_I: 1\n      IF_output_Q: 2\n    2: OctaveDownConverter\n      id: 2\n      channel: None\n      LO_frequency: None\n      LO_source: \"internal\"\n      IF_mode_I: \"direct\"\n      IF_mode_Q: \"direct\"\n      IF_output_I: 1\n      IF_output_Q: 2\n  loopbacks: QuamList = []\n</code></pre> <p>We can see five <code>OctaveUpConverter</code> elements in <code>Octave.RF_outputs</code>, and two <code>OctaveDownConverter</code> elements in <code>Octave.RF_inputs</code>, matching with the number of RF outputs / inputs, respectively. It is important to specify the <code>LO_frequency</code> of the frequency converters that are used, otherwise they will not add information to the QUA configuration when it is generated.</p> <p>At this point, our <code>Octave</code> does not yet contain any information on which OPX output / input is connected to each <code>OctaveUpconverter</code> / <code>OctaveDownConverter</code>. This is done in the third stage</p>"},{"location":"components/octave/#attaching-channels","title":"Attaching Channels","text":"<p>Once the frequency converters have been setup, it is time to attach the ones that are in use to corresponding channels in QUAM. In the example below, we connect an <code>IQChannel</code> to the <code>OctaveUpconverter</code> at <code>octave.RF_outputs[1]</code></p> <pre><code>from quam.components import IQChannel, InOutIQChannel\n\nmachine.channels[\"IQ1\"] = IQChannel(\n    opx_output_I=(\"con1\", 1),\n    opx_output_Q=(\"con1\", 2),\n    frequency_converter_up=octave.RF_outputs[1].get_reference()\n)\noctave.RF_outputs[1].channel = machine.channels[\"IQ1\"].get_reference()\noctave.RF_outputs[1].LO_frequency = 2e9  # Remember to set the LO frequency\n</code></pre> <p>Similarly, we can connect an <code>InOutIQChannel</code> to a combination of an <code>OctaveUpConverter</code> and <code>OctaveDownConverter</code></p> <pre><code>machine.channels[\"IQ2\"] = InOutIQChannel(\n    opx_output_I=(\"con1\", 3),\n    opx_output_Q=(\"con1\", 4),\n    opx_input_I=(\"con1\", 1),\n    opx_input_Q=(\"con1\", 2),\n    frequency_converter_up=octave.RF_outputs[2].get_reference(),\n    frequency_converter_down=octave.RF_inputs[1].get_reference()\n)\noctave.RF_outputs[2].channel = machine.channels[\"IQ2\"].get_reference()\noctave.RF_inputs[1].channel = machine.channels[\"IQ2\"].get_reference()\noctave.RF_outputs[2].LO_frequency = 2e9\noctave.RF_inputs[2].LO_frequency = 2e9\n</code></pre>"},{"location":"components/octave/#generating-the-config","title":"Generating the Config","text":"<p>Once everything is setup, we can generate the QUA configuration</p> <pre><code>qua_config = machine.generate_config()\n</code></pre> qua_config <pre><code>{\n  \"version\": 1,\n  \"controllers\": {\n    \"con1\": {\n      \"analog_outputs\": {\n        \"1\": { \"offset\": 0.0 },\n        \"2\": { \"offset\": 0.0 },\n        \"3\": { \"offset\": 0.0 },\n        \"4\": { \"offset\": 0.0 }\n      },\n      \"digital_outputs\": {},\n      \"analog_inputs\": { \"1\": { \"offset\": 0.0 }, \"2\": { \"offset\": 0.0 } }\n    }\n  },\n  \"elements\": {\n    \"IQ1\": {\n      \"operations\": {},\n      \"intermediate_frequency\": 0.0,\n      \"RF_inputs\": { \"port\": [\"octave1\", 1] }\n    },\n    \"IQ2\": {\n      \"operations\": {},\n      \"intermediate_frequency\": 0.0,\n      \"RF_inputs\": { \"port\": [\"octave1\", 2] },\n      \"smearing\": 0,\n      \"time_of_flight\": 140,\n      \"RF_outputs\": { \"port\": [\"octave1\", 1] }\n    }\n  },\n  \"pulses\": {\n    \"const_pulse\": {\n      \"operation\": \"control\",\n      \"length\": 1000,\n      \"waveforms\": { \"I\": \"const_wf\", \"Q\": \"zero_wf\" }\n    }\n  },\n  \"waveforms\": {\n    \"zero_wf\": { \"type\": \"constant\", \"sample\": 0.0 },\n    \"const_wf\": { \"type\": \"constant\", \"sample\": 0.1 }\n  },\n  \"digital_waveforms\": { \"ON\": { \"samples\": [[1, 0]] } },\n  \"integration_weights\": {},\n  \"mixers\": {},\n  \"oscillators\": {},\n  \"octaves\": {\n    \"octave1\": {\n      \"RF_outputs\": {\n        \"1\": {\n          \"LO_frequency\": 2000000000.0,\n          \"LO_source\": \"internal\",\n          \"gain\": 0,\n          \"output_mode\": \"always_off\",\n          \"input_attenuators\": \"off\",\n          \"I_connection\": [\"con1\", 1],\n          \"Q_connection\": [\"con1\", 2]\n        },\n        \"2\": {\n          \"LO_frequency\": 2000000000.0,\n          \"LO_source\": \"internal\",\n          \"gain\": 0,\n          \"output_mode\": \"always_off\",\n          \"input_attenuators\": \"off\",\n          \"I_connection\": [\"con1\", 3],\n          \"Q_connection\": [\"con1\", 4]\n        }\n      },\n      \"IF_outputs\": {\n        \"IF_out1\": { \"port\": [\"con1\", 1], \"name\": \"out1\" },\n        \"IF_out2\": { \"port\": [\"con1\", 2], \"name\": \"out2\" }\n      },\n      \"RF_inputs\": {\n        \"1\": {\n          \"RF_source\": \"RF_in\",\n          \"LO_frequency\": 2000000000.0,\n          \"LO_source\": \"internal\",\n          \"IF_mode_I\": \"direct\",\n          \"IF_mode_Q\": \"direct\"\n        }\n      },\n      \"loopbacks\": []\n    }\n  }\n}\n</code></pre>"},{"location":"components/octave/#combined-example","title":"Combined Example","text":"<pre><code>from typing import Dict\nfrom dataclasses import field\nfrom quam.core import QuamRoot, quam_dataclass\nfrom quam.components import Octave, OctaveUpConverter, OctaveDownConverter, Channel\n\n@quam_dataclass\nclass Quam(QuamRoot):\n    octave: Octave = None\n    channels: Dict[str, Channel] = field(default_factory=dict)\n\nmachine = Quam()\n\n\noctave = Octave(\n    name=\"octave1\",\n    ip=\"127.0.0.1\",\n    port=80,\n)\nmachine.octave = octave\n\noctave.initialize_frequency_converters()\n\noctave.print_summary()\n\n\nfrom quam.components import IQChannel, InOutIQChannel\n\nmachine.channels[\"IQ1\"] = IQChannel(\n    opx_output_I=(\"con1\", 1),\n    opx_output_Q=(\"con1\", 2),\n    frequency_converter_up=octave.RF_outputs[1].get_reference()\n)\noctave.RF_outputs[1].channel = machine.channels[\"IQ1\"].get_reference()\noctave.RF_outputs[1].LO_frequency = 2e9\n\n\nmachine.channels[\"IQ2\"] = InOutIQChannel(\n    opx_output_I=(\"con1\", 3),\n    opx_output_Q=(\"con1\", 4),\n    opx_input_I=(\"con1\", 1),\n    opx_input_Q=(\"con1\", 2),\n    frequency_converter_up=octave.RF_outputs[2].get_reference(),\n    frequency_converter_down=octave.RF_inputs[1].get_reference()\n)\noctave.RF_outputs[2].channel = machine.channels[\"IQ2\"].get_reference()\noctave.RF_inputs[1].channel = machine.channels[\"IQ2\"].get_reference()\noctave.RF_outputs[2].LO_frequency = 2e9\noctave.RF_inputs[1].LO_frequency = 2e9\n\n\nqua_config = machine.generate_config()\n</code></pre>"},{"location":"components/pulses/","title":"Pulses","text":"<p>In the QUAM framework, pulses are the fundamental building blocks for crafting signals that interact with quantum processors. These parametrized representations of waveforms, emitted from the OPX analog outputs, allow precise control over the shape and timing of signals. For instance, a square pulse, defined by its amplitude and duration, can be used to initialize a quantum state or implement a gate operation. This section explains how pulses are used in QUAM to facilitate quantum computing experiments.</p> <p>All pulses in QUAM are instances of the Pulse class. The QUAM library includes several predefined pulse types, such as:</p> <ul> <li>SquarePulse: Typically used for simple quantum operations like flips or resets, characterized by a constant amplitude throughout its duration.</li> <li>GaussianPulse: Ideal for minimizing spectral leakage due to its smooth rise and fall, commonly used in operations requiring high fidelity.</li> <li>DragGaussianPulse: Designed to correct phase errors in quantum gates, enhancing the accuracy of operations involving superconducting qubits.</li> </ul> <p>The full list of predefined pulses can be found in the pulses module. Users can also define custom pulses by subclassing the <code>Pulse</code> class. This flexibility allows the creation of tailored waveforms that suit specific experimental requirements.</p> <p>All pulses in QUAM are instances of the Pulse class. The QUAM library contains a set of common pulse types in the pulses module. Typical examples are SquarePulse, GaussianPulse, and DragGaussianPulse. Users can supplement these common pulses with their own custom pulses by subclassing the Pulse class (see Custom QUAM Components for details). </p>"},{"location":"components/pulses/#usage","title":"Usage","text":"<p>To implement pulses in a QUAM program, you first need to register them to a specific channel. Here's how to set up a channel and register a square pulse for an operation labeled <code>\"X180\"</code>:</p> <pre><code>from quam.components import pulses, SingleChannel\n\n# Create a channel associated with the first output on connector 1\nchannel = SingleChannel(opx_output=(\"con1\", 1))\n\n# Register a square pulse with a duration of 1000 units and amplitude of 0.5\nchannel.operations[\"X180\"] = pulses.SquarePulse(duration=1000, amplitude=0.5)\n</code></pre> <p>After registering a pulse, you can utilize it in a QUAM program. Below is a simple example where the <code>\"X180\"</code> pulse is played:</p> <pre><code>from qm.qua import program\n\n# Start a new QUAM program\nwith program() as prog:\n    # Play the \"X180\" pulse on the previously defined channel\n    channel.play(\"X180\")\n</code></pre>"},{"location":"components/pulses/#readout-pulses","title":"Readout Pulses","text":"<p>In addition to control pulses, QUAM also supports readout pulses, which are used to measure the state of a quantum system. These pulses should be attached to an input channel, either InOutIQChannel or InOutSingleChannel.</p> <p>Here's an example of how to define a readout pulse for a channel:</p> <pre><code>readout_channel.operations[\"readout\"] = pulses.SquareReadoutPulse(\n    length=1000, \n    amplitude=0.1\n    integration_weights=[(1, 500)]    \n)\n</code></pre> <p>Once a readout pulse is defined, it can be used in a QUAM program to measure the state of the quantum system:</p> <pre><code>with program() as prog:\n    # Measure the state of the quantum system using the \"readout\" pulse\n    qua_result = readout_channel.measure(\"readout\")\n</code></pre>"},{"location":"components/pulses/#creating-custom-pulses","title":"Creating Custom Pulses","text":"<p>To create custom pulses in QUAM, you can extend the functionality of the Pulse class by subclassing it and defining your own waveform generation logic. This allows for precise control over the pulse characteristics.</p>"},{"location":"components/pulses/#example-creating-a-ramp-pulse","title":"Example: Creating a Ramp Pulse","text":"<p>To illustrate, let's create a pulse that ramps in amplitude. This involves subclassing the Pulse class from the QUAM library and defining specific parameters and the waveform function.</p> <p><pre><code>import numpy as np\nfrom quam.core import quam_dataclass\nfrom quam.components import pulses\n\n@quam_dataclass\nclass RampPulse(pulses.Pulse):\n    # Define the starting and stopping amplitudes for the ramp pulse\n    amplitude_start: float\n    amplitude_stop: float\n\n    def waveform_function(self) -&gt; np.ndarray:\n        # This function generates a linearly spaced array to form a ramp waveform\n        return np.linspace(self.amplitude_start, self.amplitude_stop, self.length)\n</code></pre> Ensure this code is saved in a properly structured Python module within your project so that it can be imported as needed. For details on organizing custom components, refer to the Custom QUAM Components section of the QUAM documentation</p>"},{"location":"components/pulses/#extending-to-readout-pulses","title":"Extending to Readout Pulses","text":"<p>To create a readout pulse derived from a control pulse, subclass both the specific control pulse and the ReadoutPulse class. Below is an example of how to adapt the RampPulse into a readout pulse.</p> <p><pre><code>@quam_dataclass\nclass RampReadoutPulse(pulses.ReadoutPulse, RampPulse):\n    \"\"\"Extend RampPulse to include readout-specific functionality.\"\"\"\n    # No additional fields needed; inherits all from RampPulse and ReadoutPulse\n    pass\n</code></pre> Readout pulses utilize additional parameters for integration weights which are crucial for signal processing:</p> <ul> <li><code>ReadoutPulse.integration_weights</code>: A list of floats or tuples specifying the weights over time.</li> <li><code>ReadoutPulse.integration_weights_angle</code>: The angle (in radians) applied to the integration weights.</li> </ul> <p>These two parameters are used to calculate the readout pulse's integration weights (<code>sine</code>, <code>-sine</code> and <code>cosine</code>), which are essential for signal processing in readout operations.</p> <p>These parameters are typically used to manage the integration weights (<code>sine</code>, <code>-sine</code>, and <code>cosine</code>) for the readout operations. By default, these weights assume a fixed angle. If variable angles are needed, subclass the BaseReadoutPulse class and override the <code>integration_weights_function()</code> to customize this behavior.</p> <p>This approach ensures your custom pulse configurations are both flexible and compatible with the broader QUAM framework.</p>"},{"location":"components/pulses/#pulses-in-quam-and-qua","title":"Pulses in QUAM and QUA","text":"<p>The handling of pulses in QUAM and QUA presents fundamental differences in design philosophy and implementation, which can impact both usability and functionality. Understanding these differences is key for users who are transitioning to QUAM. Here's a comparison of how pulses are configured in each system:</p>"},{"location":"components/pulses/#qua-configuration","title":"QUA Configuration","text":"<p>In the QUA configuration, pulses are decomposed into multiple components, such as <code>\"waveforms\"</code> and <code>\"integration_weights\"</code>. These components are defined separately and referenced by name within the <code>\"pulses\"</code> section of the configuration:</p> <ul> <li>Decomposition: Each pulse is linked to a specific waveform and optionally, integration weights. This modular approach is more memory-efficient but may lead to fragmented configuration, where information about a single pulse is scattered across multiple sections.</li> <li>Pulse Mapping: The elements (channels) use an <code>operations</code> mapping to link a label (e.g., \"X180\") to  a specific pulse setup. This system allows multiple channels to share a pulse, enhancing reusability but potentially complicating pulse modifications.</li> <li>External Functions: Typically, the lack of a parametrized representation means that external functions are often required to populate waveform entries.</li> </ul>"},{"location":"components/pulses/#quam-configuration","title":"QUAM Configuration","text":"<p>Conversely, QUAM adopts a parametrized approach that encapsulates all pulse characteristics within a single class, aiming to simplify pulse definition and manipulation:</p> <ul> <li>Parametrized Representation: Pulses in QUAM are instances of a parametrized class, where the type of pulse and its parameters (such as length and amplitude) are directly defined by the user. This simplifies the initial setup and modification of pulse configurations.</li> <li>Waveform Generation: These parameters are used to generate the waveform dynamically using the method <code>waveform_function()</code>. This approach integrates waveform generation within the pulse definition, streamlining the configuration process.</li> <li>No built-in waveform reuse: QUAM does not currently support sharing waveforms across pulses, as each pulse is defined independently. This can have implications for memory usage on the OPX. Reusing waveforms in QUAM is planned in a future release.</li> </ul>"},{"location":"components/pulses/#conclusion","title":"Conclusion","text":"<p>Understanding the relationship between QUAM and QUA helps users navigate the choices available to them, balancing ease of use with the power and flexibility offered by direct QUA scripting.  By considering these aspects, users can better choose or adapt their system according to their specific needs and technical preferences.</p>"},{"location":"components/quam-root/","title":"QUAM Root","text":"<p>The Quantum Abstract Machine (QUAM) utilizes a hierarchical data structure in which each QUAM component can contain nested child components. This architecture is centered around the root QUAM object, which acts as the top-level component and, uniquely, does not have a parent.</p>"},{"location":"components/quam-root/#overview","title":"Overview","text":"<p>The root QUAM object is structured as a subclass of QuamRoot module. For straightforward implementations, such as those described in the Migrating to QUAM section, the BasicQuam class typically suffices:</p> <pre><code>from quam.components import BasicQuam\n\nmachine = BasicQuam()\nmachine.channels[\"qubit_xy\"] = IQChannel(opx_output_I=(\"con1\", 1), opx_output_Q=(\"con1\", 2), ...)\n</code></pre>"},{"location":"components/quam-root/#customizing-the-root-object","title":"Customizing the Root Object","text":"<p>For more complex setups requiring custom components, you can extend the QUAM root by subclassing and adding your specific components as attributes. This approach allows the QUAM root to be flexible and adaptable to various quantum machine configurations.</p>"},{"location":"components/quam-root/#example-of-a-custom-quam-class","title":"Example of a Custom QUAM Class","text":"custom_components/quam.py<pre><code>from typing import Dict\nfrom quam.core import QuamRoot, quam_dataclass\nfrom quam.components import Octave\nfrom custom_components.qubit import Qubit\n\n@quam_dataclass\nclass Quam(QuamRoot):\n    qubits: Dict[str, Qubit]\n    octaves: Dict[str, Octave]\n</code></pre> <p>You can then instantiate your customized QUAM object, adding components as required for your specific quantum machine setup:</p> <pre><code>from quam.components import Octave\nfrom custom_components import Quam, Qubit\n\nmachine = Quam(\n    qubits={\"qubit1\": Qubit(...), \"qubit2\": Qubit(...)},\n    octaves={\"octave1\": Octave(...), \"octave2\": Octave(...)}\n)\n</code></pre> <p>This structured approach ensures that all components of the quantum machine are integrated seamlessly, maintaining a clear and manageable codebase.</p>"},{"location":"components/qubits-and-qubit-pairs/","title":"Qubits and Qubit Pairs","text":""},{"location":"components/qubits-and-qubit-pairs/#overview","title":"Overview","text":"<p>Qubits and qubit pairs are essential components in quantum processing units (QPUs), implemented as subclasses of <code>QuantumComponent</code>.</p>"},{"location":"components/qubits-and-qubit-pairs/#quantum-components","title":"Quantum Components","text":"<p>The <code>QuantumComponent</code> class is the base class for qubits and qubit pairs, providing:</p> <ul> <li>A unique identifier via the <code>id</code> property</li> <li>A collection of macros defining operations</li> <li>An abstract <code>name</code> property that derived classes must implement</li> <li>A standardized method to apply operations through the <code>apply()</code> method</li> </ul>"},{"location":"components/qubits-and-qubit-pairs/#qubits","title":"Qubits","text":"<p>The <code>Qubit</code> class models a physical qubit on the QPU, encapsulating:</p> <ul> <li>Qubit-specific attributes (e.g., frequency)</li> <li>Quantum control channels (drive, flux, readout)</li> <li>Single-qubit gate operations</li> <li>Hardware-specific logic and calibration data</li> </ul> <p>The <code>Qubit</code> class is typically subclassed to add channels and other qubit-specific information as properties. Here's an example using a <code>Transmon</code> class:</p> <pre><code>from typing import Dict\nfrom dataclasses import field\nfrom quam.components import Qubit, QubitPair, IQChannel, SingleChannel\nfrom quam.core import QuamRoot, quam_dataclass\n\n@quam_dataclass\nclass Transmon(Qubit):\n    drive: IQChannel\n    flux: SingleChannel\n\n@quam_dataclass\nclass Quam(QuamRoot):\n    qubits: Dict[str, Qubit] = field(default_factory=dict)\n    qubit_pairs: Dict[str, QubitPair] = field(default_factory=dict)\n\nmachine = Quam()\n\nq1 = machine.qubits[\"q1\"] = Transmon(\n    drive=IQChannel(\n        opx_output_I=(\"con1\", 1, 1),\n        opx_output_Q=(\"con1\", 1, 2),\n        frequency_converter_up=None  # Frequency converter not needed for this example\n    ),\n    flux=SingleChannel(opx_output=(\"con1\", 1, 3)),\n)\n\nq2 = machine.qubits[\"q2\"] = Transmon(\n    drive=IQChannel(\n        opx_output_I=(\"con1\", 1, 4),\n        opx_output_Q=(\"con1\", 1, 5),\n        frequency_converter_up=None\n    ),\n    flux=SingleChannel(opx_output=(\"con1\", 1, 6)),\n)\n</code></pre>"},{"location":"components/qubits-and-qubit-pairs/#key-features","title":"Key Features","text":"<pre><code># Accessing channels\nchannels = q1.channels  # Returns a dictionary of all channels\n\n# Finding pulses\npulse = q1.get_pulse(\"pi\")  # Retrieves the pulse named \"pi\" from any channel\n\n# Aligning operations\nq1.align()  # Synchronizes all channels of q1\nq1.align(q2)  # Synchronizes all channels of q1 and q2\n</code></pre>"},{"location":"components/qubits-and-qubit-pairs/#qubit-pairs","title":"Qubit Pairs","text":"<p>The <code>QubitPair</code> class models the interaction between two qubits, managing:</p> <ul> <li>Two-qubit gate operations</li> <li>Coupling elements (e.g., tunable couplers)</li> <li>These can be addd by creating a subclass of <code>QubitPair</code> and adding the coupling elements as properties</li> <li>Interaction-specific properties and calibrations</li> <li>Hardware topology constraints</li> </ul> <p>We create a <code>QubitPair</code> using previously defined qubits:</p> <pre><code>machine.qubit_pairs[\"q1@q2\"] = QubitPair(\n    qubit_control=q1.get_reference(),  # = \"#/qubits/q1\"\n    qubit_target=q2.get_reference()  # = \"#/qubits/q2\"\n)\n</code></pre> <p>The <code>get_reference()</code> method ensures each QUAM component has a single parent, which for qubits is the <code>machine.qubits</code> dictionary.</p>"},{"location":"components/qubits-and-qubit-pairs/#key-features_1","title":"Key Features","text":"<p>Once the qubit pair is added to the root-level [QuamRoot.qubit_pairs][quam.core.quam_classes.QuamRoot.qubit_pairs] dictionary, it can be accessed using the <code>@</code> operator:</p> <pre><code># Access qubit pair using @ operator\nq1 @ q2  # Returns the qubit pair\n\n# Automatic naming\npair = machine.qubit_pairs[\"q1@q2\"]\npair.name  # Returns \"q1@q2\"\n\n# Applying two-qubit operations\npair.apply(\"cz_gate\")  # Applies the CZ gate macro\n</code></pre>"},{"location":"components/qubits-and-qubit-pairs/#macros-and-operations","title":"Macros and Operations","text":"<p>Both qubits and qubit pairs can contain macros, which serve as high-level interfaces to quantum operations. These macros:</p> <ul> <li>Define the implementation of quantum gates</li> <li>Can be registered in two ways:</li> <li>As instances of a <code>QuamMacro</code> subclass, added to <code>QuantumComponent.macros</code></li> <li>As class methods, using the <code>@QuantumComponent.register_macro</code> decorator</li> <li>Are accessible through the <code>apply()</code> method or directly as methods</li> <li>Provide a bridge between pulse-level operations and gate-level operations</li> </ul> <p>For detailed information about macros and gate-level operations, see Gate-Level Operations Documentation</p>"},{"location":"features/","title":"QUAM Features","text":"<p>The features section of the Quantum Abstract Machine (QUAM) documentation highlights the unique capabilities and functionalities that enhance the usability and performance of the QUAM framework. Here, you will find detailed explanations and examples of how to leverage these features in your quantum projects.</p>"},{"location":"features/#serialization-and-state-management","title":"Serialization and State Management","text":"<p>QUAM provides comprehensive serialization capabilities to save and load quantum machine configurations, enabling persistent state management between sessions. The serialization system supports flexible control over what gets saved, including the ability to exclude runtime-only fields from persisted state.</p> <ul> <li>Serialization Documentation: Learn how to save and load QUAM configurations, control default value inclusion, and exclude specific fields from serialization using the <code>skip_save</code> metadata. This feature is essential for managing machine state, version controlling configurations, and separating runtime data from persistent configuration.</li> </ul>"},{"location":"features/#gate-level-operations","title":"Gate-Level Operations","text":"<p>Gate-level operations provide an abstraction layer that transforms low-level pulse definitions into high-level quantum gate operations. This feature allows users to build circuit-level QUA programs by working with quantum components (qubits and qubit pairs) and applying macros that represent common quantum gates.</p> <ul> <li>Gate-Level Operations Documentation: Discover how to implement single-qubit and two-qubit gates through macros, create custom operations, and transform pulse-level control into circuit-level instructions. This abstraction simplifies the creation of quantum algorithms while maintaining the connection to the underlying hardware implementation.</li> </ul>"},{"location":"features/#quam-referencing","title":"QUAM Referencing","text":"<p>QUAM referencing is a sophisticated feature designed to streamline the management and modification of quantum configurations. It allows users to define relationships and dependencies between various components within a QUAM setup, facilitating easier updates and scalability.</p> <ul> <li>QUAM Referencing Documentation: Learn about the syntax and usage of QUAM's powerful referencing system. This feature simplifies the process of modifying and scaling quantum experiments by allowing users to reference previously defined elements, parameters, and configurations, thus avoiding redundancy and reducing the potential for errors.</li> </ul> <p>This section of the documentation provides insights into the foundational features that make QUAM a robust and adaptable framework for quantum computing. Explore the detailed documentation to fully utilize these features in your work.</p>"},{"location":"features/gate-level-operations/","title":"Gate-Level Operations","text":"<p>In this guide, we introduce how to build circuit-level QUA programs by focusing on three core concepts:</p> <ol> <li>Defining qubits (or qubit pairs)</li> <li>Organizing them within a stateful container (the QUAM)</li> <li>Transforming pulse-level operations into gate-level operations.</li> </ol> <p>By the end of this tutorial, you will be able to construct a simple program of the form:</p> <pre><code>with program() as prog:\n    X(q1)              # Single-qubit gate\n    clifford(q1, 4)    # Clifford gate from a predefined set\n    qubit_state = measure(q1)\n</code></pre> <p>This short snippet will apply specific gate operations to qubit q1 and then measure its state.</p> <p>Below is the outline of what we'll cover:</p> <ul> <li>Defining a custom Transmon qubit class (inheriting from Qubit)</li> <li>Creating a stateful QUAM container to hold multiple qubits or qubit pairs</li> <li>Registering a qubit pulse macro (e.g., x180) and using it as a gate</li> <li>Building custom macros for measurement and more complex gates (Cliffords)</li> </ul> <p>The goal is to clearly demonstrate the flow from hardware-level pulse definitions all the way to abstract, gate-level instructions in a QUA program.</p>"},{"location":"features/gate-level-operations/#defining-a-qubit-level-component","title":"Defining a Qubit-Level Component","text":"<p>We'll begin by importing all the modules we need. Then, we'll define a Transmon class that inherits from Qubit. In this example, a Transmon has an XY channel and an optional resonator channel for readout.</p> <p>Inheriting from Qubit allows us to attach hardware-specific parameters (like channels) and any additional properties relevant to our hardware setup.</p> <pre><code>from typing import Dict, Optional\nimport numpy as np\nfrom dataclasses import field\n\nfrom quam.components.ports import FEMPortsContainer\nfrom quam.core import QuamRoot, quam_dataclass\nfrom quam.components.quantum_components import Qubit, QubitPair\nfrom quam.components import MWChannel, InOutMWChannel, pulses\n\n@quam_dataclass\nclass Transmon(Qubit):\n    xy: MWChannel\n    resonator: Optional[InOutMWChannel] = None\n\n@quam_dataclass\nclass Quam(QuamRoot):\n    ports: FEMPortsContainer\n    qubits: Dict[str, Qubit] = field(default_factory=dict)\n    qubit_pairs: Dict[str, QubitPair] = field(default_factory=dict)\n</code></pre>"},{"location":"features/gate-level-operations/#instantiate-quam","title":"Instantiate QUAM","text":"<p>QUAM is our top-level container for organizing ports, qubits, and qubit pairs. We start by creating a Quam instance that includes a FEMPortsContainer, which helps route signals to and from the hardware. Then we add two Transmon qubits, \"q1\" and \"q2,\" referencing their microwave (MW) channels. These channels are used for generating pulses that interact with the qubits.</p> <pre><code>machine = Quam(ports=FEMPortsContainer())\n\n## Add qubits\n# Here we create the MW output and input ports for q1.\nq1_xy_port = machine.ports.get_mw_output(\"con1\", 1, 1, create=True)\nq1_resonator_out_port = machine.ports.get_mw_output(\"con1\", 1, 2, create=True)\nq1_resonator_in_port = machine.ports.get_mw_input(\"con1\", 1, 2, create=True)\n\n# Next, we instantiate q1 and specify its XY and resonator channels.\nq1 = machine.qubits[\"q1\"] = Transmon(\n    id=\"q1\",\n    xy=MWChannel(intermediate_frequency=100e6, opx_output=q1_xy_port.get_reference()),\n    resonator=InOutMWChannel(\n        intermediate_frequency=100e6,\n        opx_output=q1_resonator_out_port.get_reference(),\n        opx_input=q1_resonator_in_port.get_reference(),\n    ),\n)\n\n# We create another qubit, q2. Here, the resonator channel is omitted for brevity.\nq2_xy_mw_output = machine.ports.get_mw_output(\"con1\", 1, 2, create=True)\nq2 = machine.qubits[\"q2\"] = Transmon(\n    id=\"q2\",\n    xy=MWChannel(\n        intermediate_frequency=100e6, opx_output=q2_xy_mw_output.get_reference()\n    ),\n)\n</code></pre> <p>We can view a quick summary of a qubit's configuration:</p> <pre><code>q1.print_summary()\n</code></pre> <code>q1.print_summary()</code> output <pre><code>q1: Transmon\n  id: \"q1\"\n  macros: QuamDict Empty\n  xy: MWChannel\n    operations: QuamDict Empty\n    id: None\n    digital_outputs: QuamDict Empty\n    sticky: None\n    intermediate_frequency: 100000000.0\n    thread: None\n    core: None\n    LO_frequency: \"#./upconverter_frequency\"\n    RF_frequency: \"#./inferred_RF_frequency\"\n    opx_output: \"#/ports/mw_outputs/con1/1/1\"\n    upconverter: 1\n  resonator: InOutMWChannel\n    operations: QuamDict Empty\n    id: None\n    digital_outputs: QuamDict Empty\n    sticky: None\n    intermediate_frequency: 100000000.0\n    thread: None\n    core: None\n    opx_input: \"#/ports/mw_inputs/con1/1/2\"\n    time_of_flight: 140\n    smearing: 0\n    LO_frequency: \"#./upconverter_frequency\"\n    RF_frequency: \"#./inferred_RF_frequency\"\n    opx_output: \"#/ports/mw_outputs/con1/1/2\"\n    upconverter: 1\n</code></pre>"},{"location":"features/gate-level-operations/#qubit-pairs","title":"Qubit pairs","text":"<p>Qubit pairs provide an abstraction for interactions between two qubits. For example, you might need a specific gate that involves both a control qubit and a target qubit. Here, we create a pair named \"q1@q2\" which references q1 as control and q2 as target.</p> <pre><code>machine.qubit_pairs[\"q1@q2\"] = QubitPair(\n    qubit_control=q1.get_reference(), qubit_target=q2.get_reference()\n)\n</code></pre> <p>You can then access this pair using:</p> <pre><code>q1 @ q2\n</code></pre> <code>q1 @ q2</code> output <pre><code>QubitPair(id='q1@q2', macros={}, qubit_control=Transmon(id='q1', macros={}, xy=MWChannel(operations={}, id=None, digital_outputs={}, sticky=None, intermediate_frequency=100000000.0, thread=None, core=None, LO_frequency=5000000000.0, RF_frequency=5100000000.0, opx_output=MWFEMAnalogOutputPort(controller_id='con1', fem_id=1, port_id=1, band=1, upconverter_frequency=5000000000.0, upconverters=None, delay=0, shareable=False, sampling_rate=1000000000.0, full_scale_power_dbm=-11), upconverter=1), resonator=InOutMWChannel(operations={}, id=None, digital_outputs={}, sticky=None, intermediate_frequency=100000000.0, thread=None, core=None, opx_input=MWFEMAnalogInputPort(controller_id='con1', fem_id=1, port_id=2, band=1, downconverter_frequency=5000000000.0, gain_db=None, sampling_rate=1000000000.0, shareable=False), time_of_flight=140, smearing=0, LO_frequency=5000000000.0, RF_frequency=5100000000.0, opx_output=MWFEMAnalogOutputPort(controller_id='con1', fem_id=1, port_id=2, band=1, upconverter_frequency=5000000000.0, upconverters=None, delay=0, shareable=False, sampling_rate=1000000000.0, full_scale_power_dbm=-11), upconverter=1)), qubit_target=Transmon(id='q2', macros={}, xy=MWChannel(operations={}, id=None, digital_outputs={}, sticky=None, intermediate_frequency=100000000.0, thread=None, core=None, LO_frequency=5000000000.0, RF_frequency=5100000000.0, opx_output=MWFEMAnalogOutputPort(controller_id='con1', fem_id=1, port_id=2, band=1, upconverter_frequency=5000000000.0, upconverters=None, delay=0, shareable=False, sampling_rate=1000000000.0, full_scale_power_dbm=-11), upconverter=1), resonator=None))\n</code></pre> <p>A qubit pair can also be subclassed (similar to how Transmon subclasses Qubit) if you need extra functionality (e.g., controlling tunable couplers).</p>"},{"location":"features/gate-level-operations/#transforming-a-pulse-into-a-qubit-gate","title":"Transforming a Pulse into a Qubit Gate","text":"<p>In QUAM, a common pattern is to define a pulse (e.g., a square pulse) and then wrap it in a macro class. This macro can be registered as a gate-level operation, allowing us to write high-level QUA code.</p> <p>For example, below we define an \"x180\" pulse (a typical pi rotation around the X axis) and then create a \"PulseMacro\". This macro is stored in \"q1.macros[\"X\"]\" so we can call it as a gate.</p> <pre><code>from quam.components.macro import PulseMacro\n\n# Define the actual pulse \u2014 a simple square envelope with amplitude and duration.\nq1.xy.operations[\"x180\"] = pulses.SquarePulse(amplitude=0.2, length=100)\n\n# Wrap the pulse in a macro so it can be invoked as a logical gate.\nq1.macros[\"X\"] = PulseMacro(pulse=q1.xy.operations[\"x180\"].get_reference())\n\n# Now we can use this macro in a QUA program:\nfrom qm import generate_qua_script, qua\n\nwith qua.program() as prog:\n    # Apply the X gate to q1. This calls the macro we just defined.\n    q1.apply(\"X\")\n\n# Print out the generated QUA code to see how it expands.\nprint(generate_qua_script(prog))\n</code></pre> Pulse macro output <pre><code># Single QUA script generated at 2025-03-31 19:28:57.397848\n# QUA library version: 1.2.2a4\n\nfrom qm import CompilerOptionArguments\nfrom qm.qua import *\n\nwith program() as prog:\n    play(\"x180\", \"q1.xy\")\n\n\nconfig = None\n\nloaded_config = None\n</code></pre>"},{"location":"features/gate-level-operations/#creating-operations","title":"Creating operations","text":"<p>To make a macro like \"X\" accessible as a gate-level operation in QUA, we use an OperationsRegistry. The registry maps gate names (like X) to the correct macro for each qubit.</p> <pre><code>from quam.core.operation import OperationsRegistry\n\noperations_registry = OperationsRegistry()\n\n@operations_registry.register_operation\n# The function name below becomes the gate-level call (e.g., X(q1)).\n# Note that internally, it will trigger the macro we assigned to \"q1.macros[\"X\"]\".\ndef X(qubit: Qubit, **kwargs):\n    # Implementation is resolved by the macros attached to the qubit.\n    pass\n</code></pre> <p>Now calling X(q1) in QUA code triggers the macro q1.macros[\"X\"].</p> <pre><code>with qua.program() as prog:\n    # This uses the registry to look up the correct macro.\n    X(q1)\n\nprint(generate_qua_script(prog))\n</code></pre> Operation program output <pre><code>from quam.components.macro import PulseMacro\n\n# Define the actual pulse \u2014 a simple square envelope with amplitude and duration.\nq1.xy.operations[\"x180\"] = pulses.SquarePulse(amplitude=0.2, length=100)\n\n# Wrap the pulse in a macro so it can be invoked as a logical gate.\nq1.macros[\"X\"] = PulseMacro(pulse=q1.xy.operations[\"x180\"].get_reference())\n\n# Now we can use this macro in a QUA program:\nfrom qm import generate_qua_script, qua\n\nwith qua.program() as prog:\n    # Apply the X gate to q1. This calls the macro we just defined.\n    q1.apply(\"X\")\n\n# Print out the generated QUA code to see how it expands.\nprint(generate_qua_script(prog))\n</code></pre>"},{"location":"features/gate-level-operations/#creating-custom-macros","title":"Creating custom macros","text":"<p>Often, a gate corresponds to a single pulse, and \"PulseMacro\" is enough. But sometimes, a gate may require multiple pulses or more complex logic. In that case, we can define a custom macro by subclassing QubitMacro (or QubitPairMacro if it involves two qubits).</p> <p>Below, we create two macros as examples: a \"measure\" macro and a \"clifford\" macro. These illustrate how to embed logic into your macros and integrate them with the QUAM.</p>"},{"location":"features/gate-level-operations/#measure-macro","title":"Measure macro","text":"<p>For the measure macro, we define a readout pulse on q1's resonator channel. The macro itself, when called, plays that pulse, reads I/Q data, and assigns a boolean state based on a threshold.</p> <pre><code>q1.resonator.operations[\"readout\"] = pulses.SquareReadoutPulse(\n    length=1000, amplitude=0.1, threshold=0.215\n)\n</code></pre> <pre><code>from quam.components.macro import QubitMacro\nfrom quam.utils.qua_types import QuaVariableBool\n\n@quam_dataclass\nclass MeasureMacro(QubitMacro):\n    threshold: float\n\n    def apply(self, **kwargs) -&gt; QuaVariableBool:\n        # The macro reads I/Q data from the resonator channel.\n        I, Q = self.qubit.resonator.measure(\"readout\")\n        # We declare a QUA variable to store the boolean result of thresholding the I value.\n        qubit_state = qua.declare(bool)\n        qua.assign(qubit_state, I &gt; self.threshold)\n        return qubit_state\n</code></pre> <p>We attach an instance of this MeasureMacro to our qubit q1.</p> <pre><code>q1.macros[\"measure\"] = MeasureMacro(threshold=0.215)\n</code></pre> <p>Now we can perform the \"measure\" operation within a QUA program:</p> <pre><code>with qua.program() as prog:\n    qubit_state = q1.apply(\"measure\")  # returns a boolean variable\n\nprint(generate_qua_script(prog))\n</code></pre> <p>Similar to the X gate, we can register a generic measure() operation:</p> <pre><code>@operations_registry.register_operation\ndef measure(qubit: Qubit, **kwargs) -&gt; QuaVariableBool:\n    pass\n</code></pre> <p>This lets us call measure(q1) in a gate-like manner:</p> <pre><code>with qua.program() as prog:\n    qubit_state = measure(q1)\n\nprint(generate_qua_script(prog))\n</code></pre> Measure macro output <pre><code># Single QUA script generated at 2025-03-31 19:28:57.445853\n# QUA library version: 1.2.2a4\n\nfrom qm import CompilerOptionArguments\nfrom qm.qua import *\n\nwith program() as prog:\n    v1 = declare(fixed, )\n    v2 = declare(fixed, )\n    v3 = declare(bool, )\n    measure(\"readout\", \"q1.resonator\", dual_demod.full(\"iw1\", \"iw2\", v1), dual_demod.full(\"iw3\", \"iw1\", v2))\n    assign(v3, (v1&gt;0.215))\n\n\nconfig = None\n\nloaded_config = None\n</code></pre>"},{"location":"features/gate-level-operations/#method-macros","title":"Method Macros","text":"<p>In addition to defining macros as separate classes, QUAM supports defining macros directly as methods within your qubit class using the <code>@QuantumComponent.register_macro</code> decorator (or <code>@method_macro</code>). This provides a cleaner way to organize qubit-specific operations.</p> <p>Here's an example of adding a reset method to the Transmon class:</p> <pre><code>from quam.core import QuantumComponent\nfrom qm import qua\n\n@quam_dataclass\nclass Transmon(Qubit):\n    xy: MWChannel\n    resonator: Optional[InOutMWChannel] = None\n\n    @QuantumComponent.register_macro\n    def reset(self, threshold: float = 0.0):\n        \"\"\"Reset the qubit to ground state using active reset\"\"\"\n        # Measure the qubit state\n        I, Q = self.resonator.measure(\"readout\")\n\n        # Apply a conditional \u03c0-pulse if qubit is in excited state\n        with qua.if_(I &gt; threshold):\n            self.xy.play(\"x180\")\n\n        # Add a wait time for relaxation\n        self.xy.wait(100)\n</code></pre> <p>Key Requirements:</p> <ol> <li>Any pulses referenced in a method macro (like <code>\"readout\"</code> and <code>\"x180\"</code>) must be registered in the appropriate channel's <code>operations</code> dictionary before the macro is called</li> <li>Method macros automatically become available via both <code>qubit.apply(\"method_name\")</code> and direct method calls <code>qubit.method_name()</code></li> <li>If a qubit doesn't have a specific channel (e.g., no <code>resonator</code>), calling that channel in a method macro will raise an <code>AttributeError</code></li> </ol> Complete working example with setup and usage <p>Here's a full example showing how to set up qubits with channels, register pulses, and use the method macro:</p> <pre><code>from typing import Dict, Optional\nfrom dataclasses import field\n\nfrom quam.core import QuamRoot, quam_dataclass\nfrom quam.components.ports import FEMPortsContainer\nfrom quam.components.quantum_components import Qubit, QuantumComponent\nfrom quam.components import MWChannel, InOutMWChannel, pulses\nfrom qm import qua\n\n# Define the Transmon qubit class with a method macro for reset\n@quam_dataclass\nclass Transmon(Qubit):\n    xy: MWChannel\n    resonator: Optional[InOutMWChannel] = None\n\n    @QuantumComponent.register_macro\n    def reset(self, threshold: float = 0.0):\n        \"\"\"Reset the qubit to ground state using active reset\"\"\"\n        # Measure the qubit state\n        I, Q = self.resonator.measure(\"readout\")\n\n        # Apply a conditional \u03c0-pulse if qubit is in excited state\n        with qua.if_(I &gt; threshold):\n            self.xy.play(\"x180\")\n\n        # Add a wait time for relaxation\n        self.xy.wait(100)\n\n# Set up the QUAM machine with a qubit\n@quam_dataclass\nclass Quam(QuamRoot):\n    ports: FEMPortsContainer\n    qubits: Dict[str, Qubit] = field(default_factory=dict)\n\n\nmachine = Quam(ports=FEMPortsContainer())\n\n# Create the qubit with XY and resonator channels\nq1_xy_port = machine.ports.get_mw_output(\"con1\", 1, 1, create=True)\nq1_resonator_out_port = machine.ports.get_mw_output(\"con1\", 1, 2, create=True)\nq1_resonator_in_port = machine.ports.get_mw_input(\"con1\", 1, 2, create=True)\n\nq1 = Transmon(\n    id=\"q1\",\n    xy=MWChannel(intermediate_frequency=100e6, opx_output=q1_xy_port.get_reference()),\n    resonator=InOutMWChannel(\n        intermediate_frequency=100e6,\n        opx_output=q1_resonator_out_port.get_reference(),\n        opx_input=q1_resonator_in_port.get_reference(),\n    ),\n)\n\n# Register the pulses required by the reset method macro\nq1.xy.operations[\"x180\"] = pulses.SquarePulse(amplitude=0.2, length=100)\nq1.resonator.operations[\"readout\"] = pulses.SquareReadoutPulse(\n    length=1000, amplitude=0.1, threshold=0.215\n)\n\n# Create a QUA program that uses the reset method macro\nwith qua.program() as prog:\n    # Call the reset method macro directly\n    q1.reset(threshold=0.1)\n    # OR use the apply method to call the macro by name\n    q1.apply(\"reset\", threshold=0.1)\n\n# Method macros appear in the macro registry\nprint(q1.get_macros())  # {'reset': &lt;MethodMacro 'reset'&gt;, 'align': &lt;MethodMacro 'align'&gt;, ...}\n</code></pre> <p>Method macros provide better code organization by keeping qubit-specific logic within the qubit class itself, while still maintaining full compatibility with the QUAM macro system.</p>"},{"location":"features/gate-level-operations/#clifford-macro","title":"Clifford macro","text":"<p>Next, we define a single-qubit \"CliffordMacro\". For illustration, we will define a few pulses that correspond to some of the first five Clifford gates.</p> <pre><code># Define additional pulses for x90, x180, y90, y180, etc.\nq1.xy.operations[\"x90\"] = pulses.SquarePulse(amplitude=0.1, length=100, axis_angle=0)\nq1.xy.operations[\"x180\"] = pulses.SquarePulse(amplitude=0.2, length=100, axis_angle=0)\nq1.xy.operations[\"y90\"] = pulses.SquarePulse(amplitude=0.1, length=100, axis_angle=np.pi / 2)\nq1.xy.operations[\"y180\"] = pulses.SquarePulse(amplitude=0.2, length=100, axis_angle=np.pi / 2)\n</code></pre> <pre><code>@quam_dataclass\nclass CliffordMacro(QubitMacro):\n    def apply(self, clifford_idx: int, **kwargs):\n        # We use a QUA switch_ statement to choose which pulses to play in real time.\n        with qua.switch_(clifford_idx, unsafe=True):\n            with qua.case_(0):\n                # Identity operation: do nothing except wait to preserve timing.\n                wait_duration = self.qubit.xy.operations[\"x180\"].length // 4\n                self.qubit.xy.wait(wait_duration)\n            with qua.case_(1):\n                self.qubit.xy.play(\"x180\")\n            with qua.case_(2):\n                self.qubit.xy.play(\"y180\")\n            with qua.case_(3):\n                self.qubit.xy.play(\"y180\")\n                self.qubit.xy.play(\"x180\")\n            with qua.case_(4):\n                # This is a composite gate (x90 followed by y90)\n                self.qubit.xy.play(\"x90\")\n                self.qubit.xy.play(\"y90\")\n            # You can continue defining more Clifford cases here...\n\n# Attach the macro to q1\nq1.macros[\"clifford\"] = CliffordMacro()\n\n# We can now call this macro using q1.apply(\"clifford\", clifford_idx):\nwith qua.program() as prog:\n    clifford_idx = qua.declare(int, 0)\n    q1.apply(\"clifford\", clifford_idx)\n\n\n# As before, we register a qubit-generic function:\n@operations_registry.register_operation\ndef clifford(qubit: Qubit, clifford_idx: int, **kwargs):\n    pass\n\n# Now we can call clifford(q1, clifford_idx) in our QUA program:\nwith qua.program() as prog:\n    clifford_idx = qua.declare(int, 0)\n    clifford(q1, clifford_idx)\n\nprint(generate_qua_script(prog))\n</code></pre> Clifford output <pre><code># Single QUA script generated at 2025-03-31 19:28:57.522055\n# QUA library version: 1.2.2a4\n\nfrom qm import CompilerOptionArguments\nfrom qm.qua import *\n\nwith program() as prog:\n    v1 = declare(int, value=0)\n    with if_((v1==0), unsafe=True):\n        wait(25, \"q1.xy\")\n    with elif_((v1==1)):\n        play(\"x180\", \"q1.xy\")\n    with elif_((v1==2)):\n        play(\"y180\", \"q1.xy\")\n    with elif_((v1==3)):\n        play(\"y180\", \"q1.xy\")\n        play(\"x180\", \"q1.xy\")\n    with elif_((v1==4)):\n        play(\"x90\", \"q1.xy\")\n        play(\"y90\", \"q1.xy\")\n\n\nconfig = None\n\nloaded_config = None\n</code></pre>"},{"location":"features/quam-references/","title":"Referencing Between Components","text":""},{"location":"features/quam-references/#quam-tree-structure","title":"QUAM Tree Structure","text":"<p>QUAM follows a tree structure, meaning that each QUAM component can have a parent component and it can have children.</p> <p>The top-level object is always an instance of QUAMRoot, e.g. <pre><code>from dataclasses import dataclass\nfrom quam.core import QuamRoot, quam_dataclass\nfrom quam.components import *\n\n@quam_dataclass\nclass Quam(QuamRoot):\n    qubit: superconducting_qubits.Transmon = None\n\nmachine = Quam()\n</code></pre></p> <p>Next, we can add a qubit as a component: <pre><code>qubit = superconducting_qubits.Transmon(xy=IQChannel(opx_output_I=(\"con1\", 1), opx_output_Q=(\"con1\", 2\"))\nmachine.qubit = qubit\nassert qubit.parent == machine\n</code></pre></p> <p>One of the rules in QUAM is that a component can only have one parent. This is enforced by the <code>parent</code> attribute, which is set when a component is added to another component. As a result, the following raises an error:</p> <p><pre><code>channel = IQChannel(opx_output_I=(\"con1\", 1), opx_output_Q=(\"con1\", 2\")\nqubit1 = superconducting_qubits.Transmon(xy=channel)\nqubit2 = superconducting_qubits.Transmon(xy=channel)  # Raises ValueError\n</code></pre> additionally, situations often arise where a component needs access to another part of QUAM that is not directly one of its children.  To accomodate both of these situations, we introduce the concept of references.</p>"},{"location":"features/quam-references/#quam-references","title":"QUAM References","text":"<p>A reference in QUAM is a way for a component's attribute to be a reference to another part of QUAM. An example is shown here</p> <p><pre><code>@quam_dataclass\nclass Component(QuamComponent):\n    a: int\n    b: int\n\ncomponent = Component(a=42, b=\"#./a\")\nprint(component.b)  # Prints 42\n</code></pre> As can be seen, the QUAM component attribute <code>component.b</code> was set to a reference, i.e. a string starting with <code>\"#\"</code>. This reference indicates that when the component is retrieved, e.g. through the <code>print()</code> statement, it should instead return the value of its reference.</p> <p>QUAM references follow the JSON reference syntax (For a description see https://json-spec.readthedocs.io/reference.html), but further allow for relative references, i.e. references w.r.t the current QUAM component. We will next describe the three types of references.</p>"},{"location":"features/quam-references/#absolute-references","title":"Absolute References","text":"<p>Absolute references always start with <code>\"#/\"</code>, e.g. <code>\"#/absolute/path/to/value</code>. They are references from the top-level QUAM object which inherits from <code>QuamRoot</code> For example: <pre><code>machine = Quam()\nmachine.frequency = 6e9\nmachine.qubit = Transmon(frequency=\"#/frequency\")\nprint(machine.qubit.frequency)  # Prints 6e9\n</code></pre></p>"},{"location":"features/quam-references/#relative-references","title":"Relative References","text":"<p>Relative references start with <code>\"#./\"</code>, e.g. <code>\"#./relative/path/to/value</code> These are references with respect to the current QUAM component. An example was given above, and is reiterated here:</p> <pre><code>@quam_dataclass\nclass Component(QuamComponent):\n    a: int\n    b: int\n\ncomponent = Component(a=42, b=\"#./a\")\nprint(component.b)  # Prints 42\n</code></pre>"},{"location":"features/quam-references/#relative-parent-references","title":"Relative Parent References","text":"<p>Relative parent references start with <code>\"#../\"</code>, e.g. <code>\"#../relative/path/from/parent/to/value</code> These are references with respect to the parent of the current QUAM component.</p> <p>To illustrate relative parent references, we modify <code>Component</code> to allow for a subcomponent:</p> <pre><code>@quam_dataclass\nclass Component(QuamComponent):\n    sub_component: \"Component\" = None\n    a: int = None\n    b: int = None\n\ncomponent = Component(a=42)\ncomponent.subcomponent = Component(a=\"#../a\")\nprint(component.subcomponent.a)  # Prints 42\n</code></pre> <p>As can be seen in this example, <code>component.subcomponent.a = \"#../a\"</code> is a relative parent reference, which means that <code>component.subcomponent.a</code> should be the same as <code>component.a</code>.</p> <p>Parent references can also be stacked, e.g. <code>\"#../../a\"</code> would be a reference to the grandparent of the current component.</p>"},{"location":"features/quam-references/#additional-notes-on-references","title":"Additional Notes on References","text":""},{"location":"features/quam-references/#directly-overwriting-references-is-not-allowed","title":"Directly Overwriting References is not Allowed","text":"<p>Since QUAM references behave like regular attributes, the user might accidentally overwrite a reference without realizing it. To prohibit this, it is not possible to directly overwrite a reference:</p> <pre><code>component = Component()\ncomponent.a = 42\ncomponent.b = \"#./a\"\n\ncomponent.b = 43  # Raises ValueError\n</code></pre> <p>Instead, a reference must first be set to None, after which it can be set to an arbitrary new value (including a new reference): <pre><code>component.b = \"#./a\"\ncomponent.b = None\ncomponent.b = 43  # Does not raise an error\n</code></pre></p>"},{"location":"features/serialization/","title":"Serialization and State Management","text":"<p>QUAM provides powerful serialization capabilities to save and load your quantum machine configurations. This allows you to persist your setup between sessions, version control your configurations, and easily share setups with collaborators.</p>"},{"location":"features/serialization/#basic-serialization","title":"Basic Serialization","text":""},{"location":"features/serialization/#saving-a-quam-state","title":"Saving a QUAM State","text":"<p>You can save your QUAM configuration to a JSON file using the <code>save()</code> method:</p> <pre><code>from quam import QuamRoot, quam_dataclass\n\nmachine = QuamRoot()\n# ... configure your machine ...\nmachine.save(\"state.json\")\n</code></pre>"},{"location":"features/serialization/#loading-a-quam-state","title":"Loading a QUAM State","text":"<p>Load a previously saved configuration using the <code>load()</code> class method:</p> <pre><code>machine = QuamRoot.load(\"state.json\")\n</code></pre>"},{"location":"features/serialization/#converting-to-dictionary","title":"Converting to Dictionary","text":"<p>Convert a QUAM object to a dictionary representation without saving to disk:</p> <pre><code>config_dict = machine.to_dict()\n</code></pre>"},{"location":"features/serialization/#controlling-default-values","title":"Controlling Default Values","text":"<p>By default, QUAM includes all field values (including defaults) in serialized output. You can control this behavior using the <code>include_defaults</code> parameter:</p> <pre><code># Include default values (default behavior)\nmachine.save(\"state.json\", include_defaults=True)\n\n# Exclude default values (only save non-default values)\nmachine.save(\"state.json\", include_defaults=False)\n</code></pre>"},{"location":"features/serialization/#excluding-fields-from-serialization","title":"Excluding Fields from Serialization","text":"<p>Sometimes you may want certain fields to be accessible at runtime but not saved to disk. Common use cases include:</p> <ul> <li>Temporary cached data</li> <li>Runtime-only connections (e.g., <code>qm</code> or <code>qmm</code> objects from QM)</li> <li>Computed properties that shouldn't be persisted</li> <li>Sensitive information that shouldn't be stored</li> </ul>"},{"location":"features/serialization/#using-skip_save-metadata","title":"Using <code>skip_save</code> Metadata","text":"<p>You can exclude specific fields from serialization using the <code>skip_save</code> metadata flag:</p> <pre><code>from dataclasses import field\nfrom quam import quam_dataclass, QuamComponent\n\n@quam_dataclass\nclass MyComponent(QuamComponent):\n    # This field will be saved\n    persistent_value: int = 1\n\n    # This field will NOT be saved (skip_save=True)\n    runtime_only_value: int = field(default=2, metadata={\"skip_save\": True})\n\n    # You can also skip complex objects\n    cached_data: dict = field(default_factory=dict, metadata={\"skip_save\": True})\n</code></pre> <p>Key behaviors:</p> <ul> <li>Fields marked with <code>skip_save=True</code> are excluded from both <code>to_dict()</code> and <code>save()</code> operations</li> <li>These fields remain fully accessible at runtime (you can read and write them normally)</li> <li>If a field contains a <code>QuamComponent</code>, the entire component tree is excluded from serialization</li> </ul>"},{"location":"features/serialization/#example-quantum-machine-manager","title":"Example: Quantum Machine Manager","text":"<p>A common use case is excluding the Quantum Machines manager objects from serialization:</p> <pre><code>from dataclasses import field\nfrom quam import QuamRoot, quam_dataclass\n\n@quam_dataclass\nclass QuantumMachine(QuamRoot):\n    # Configuration that should be saved\n    ip_address: str = \"127.0.0.1\"\n    port: int = 9510\n\n    # Runtime objects that should NOT be saved\n    qm: object = field(default=None, metadata={\"skip_save\": True})\n    qmm: object = field(default=None, metadata={\"skip_save\": True})\n\n    def connect(self):\n        \"\"\"Connect to the quantum machine.\"\"\"\n        from qm.QuantumMachinesManager import QuantumMachinesManager\n        self.qmm = QuantumMachinesManager(host=self.ip_address, port=self.port)\n        self.qm = self.qmm.open_qm(self.generate_config())\n\n# Usage\nmachine = QuantumMachine()\nmachine.connect()  # Creates qm and qmm objects\n\n# Save configuration (qm and qmm are automatically excluded)\nmachine.save(\"state.json\")\n\n# Load configuration (need to reconnect)\nmachine = QuantumMachine.load(\"state.json\")\nmachine.connect()  # Re-establish connection\n</code></pre>"},{"location":"features/serialization/#nested-component-exclusion","title":"Nested Component Exclusion","text":"<p>When a field containing a <code>QuamComponent</code> is marked with <code>skip_save=True</code>, the entire component tree under that field is excluded:</p> <pre><code>@quam_dataclass\nclass InnerComponent(QuamComponent):\n    inner_value: int = 1\n\n@quam_dataclass\nclass OuterComponent(QuamComponent):\n    visible: int = 2\n    # This entire component (including inner_value) won't be saved\n    hidden: InnerComponent = field(\n        default_factory=InnerComponent,\n        metadata={\"skip_save\": True}\n    )\n\nobj = OuterComponent()\nresult = obj.to_dict()\n# result only contains: {\"visible\": 2, \"__class__\": \"...OuterComponent\"}\n# The entire 'hidden' component and its nested data are excluded\n</code></pre>"},{"location":"features/serialization/#inheritance-and-field-override","title":"Inheritance and Field Override","text":"<p>Field metadata is preserved through inheritance but can be overridden in child classes:</p> <pre><code>@quam_dataclass\nclass Parent(QuamComponent):\n    # Hidden in parent\n    field: int = field(default=1, metadata={\"skip_save\": True})\n\n@quam_dataclass\nclass Child(Parent):\n    # Override to make it visible in child\n    field: int = 2  # No metadata = will be saved\n\nparent = Parent()\nparent.to_dict()  # field excluded\n\nchild = Child()\nchild.to_dict()  # field included\n</code></pre>"},{"location":"features/serialization/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>skip_save</code> for runtime-only data: Mark fields that contain session-specific or computed data</li> <li>Keep configurations portable: Exclude machine-specific or environment-specific data</li> <li>Document exclusions: Comment why certain fields are excluded to help future maintainers</li> <li>Test serialization: Verify that save/load cycles preserve your configuration correctly</li> <li>Version your configs: Keep saved states in version control to track configuration evolution</li> </ol>"},{"location":"features/serialization/#scope-and-limitations","title":"Scope and Limitations","text":"<ul> <li><code>skip_save</code> only applies to dataclass fields, not items within <code>QuamList</code> or <code>QuamDict</code></li> <li>Metadata is class-level (defined at class definition time), not instance-level</li> <li>You cannot dynamically change <code>skip_save</code> behavior for individual instances</li> </ul>"}]}